var searchIndex = {};
searchIndex["libprosic"] = {"doc":"","items":[[3,"ComplementEvent","libprosic","Complement of other given events (i.e. 1 - Pr(other events)).",null,null],[12,"name","","event name",0,null],[4,"BCFError","","",null,null],[13,"MissingTag","","",1,null],[0,"model","","",null,null],[3,"PairModel","libprosic::model","Joint variant calling model, combining two latent variable models.",null,null],[3,"PairPileup","","Pileup of observations associated with marginal probability.",null,null],[4,"VariantType","","",null,null],[13,"Insertion","","",2,null],[13,"Deletion","","",2,null],[13,"SNV","","",2,null],[4,"Variant","","",null,null],[13,"Deletion","","",3,null],[13,"Insertion","","",3,null],[13,"SNV","","",3,null],[5,"AlleleFreq","","",null,{"inputs":[{"name":"f64"}],"output":{"name":"allelefreq"}}],[0,"likelihood","","",null,null],[3,"LatentVariableModel","libprosic::model::likelihood","Variant calling model, taking purity and allele frequencies into account.",null,null],[6,"AlleleFreq","","",null,null],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"new","","Create new model.",4,{"inputs":[{"name":"f64"}],"output":{"name":"self"}}],[11,"likelihood_pileup","","Likelihood to observe a pileup given allele frequencies for case and control.",4,null],[0,"priors","libprosic::model","",null,null],[0,"infinite_sites_neutral_variation","libprosic::model::priors","",null,null],[3,"InfiniteSitesNeutralVariationModel","libprosic::model::priors::infinite_sites_neutral_variation","The classical population genetic model used for variant calling in e.g. GATK and Samtools.",null,null],[11,"new","","Create new model for given ploidy and heterozygosity.",5,{"inputs":[{"name":"u32"},{"name":"prob"}],"output":{"name":"self"}}],[11,"allele_freq_sum","","",5,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[11,"prior_prob","","",5,null],[11,"joint_prob","","",5,null],[11,"marginal_prob","","",5,null],[11,"allele_freqs","","",5,null],[0,"tumor_normal","libprosic::model::priors","",null,null],[3,"TumorNormalModel","libprosic::model::priors::tumor_normal","Tumor-normal prior model using ploidy, heterozygosity (in normal tissue) and tumor mutation rate\nper effective cell division.\nThe latter is the quotient mu/beta, with mu being the mutation rate and beta being the fraction\nof effective cell divisions (both lineages survive). Alone, the parameters are not observable.\nHowever, mu/beta can be estimated from e.g. SNV calls. It is the slope of the linear model\n`y = mu/beta * (x -  1 / fmax)``, with `x` being the reciprocal of the observed allele frequencies\nand y being the number of observed mutations corresponding to each frequency\n(see Williams et al. Nature Genetics 2016).",null,null],[12,"normal_model","","",6,null],[12,"allele_freqs_tumor","","",6,null],[12,"grid_points","","",6,null],[11,"new","","Create new model.",6,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"u64"},{"name":"prob"}],"output":{"name":"self"}}],[11,"somatic_prior_prob","","",6,null],[11,"normal_prior_prob","","",6,null],[11,"prior_prob","","",6,null],[11,"joint_prob","","",6,null],[11,"marginal_prob","","",6,null],[11,"map","","",6,null],[11,"allele_freqs","","",6,null],[0,"tumor_normal_relapse","libprosic::model::priors","",null,null],[3,"TumorNormalRelapseModel","libprosic::model::priors::tumor_normal_relapse","",null,null],[11,"new","","Create new model.",7,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"u64"},{"name":"prob"}],"output":{"name":"self"}}],[11,"prior_prob","","",7,null],[11,"joint_prob","","",7,null],[11,"marginal_prob","","",7,null],[11,"map","","",7,null],[11,"allele_freqs","","",7,null],[0,"flat","libprosic::model::priors","",null,null],[3,"FlatTumorNormalModel","libprosic::model::priors::flat","",null,null],[11,"new","","",8,{"inputs":[{"name":"u32"}],"output":{"name":"self"}}],[11,"prior_prob","","",8,null],[11,"joint_prob","","",8,null],[11,"marginal_prob","","",8,null],[11,"map","","",8,null],[11,"allele_freqs","","",8,null],[8,"Model","libprosic::model::priors","A prior model of the allele frequency spectrum.",null,null],[10,"prior_prob","","Calculate prior probability of given allele frequency.",9,null],[10,"allele_freqs","","Return allele frequency spectrum.",9,null],[10,"marginal_prob","","",9,null],[10,"joint_prob","","",9,null],[8,"PairModel","","",null,null],[10,"prior_prob","","Calculate prior probability of given combination of allele frequencies.",10,null],[10,"joint_prob","","Calculate joint probability of prior with likelihoods for given allele frequency ranges.",10,null],[10,"marginal_prob","","Calculate marginal probability.",10,null],[10,"map","","Calculate maximum a posteriori probability estimate of allele frequencies.",10,null],[10,"allele_freqs","","Return allele frequency spectra.",10,null],[8,"TrioModel","","",null,null],[10,"prior_prob","","Calculate prior probability of given combination of allele frequencies.",11,null],[10,"joint_prob","","Calculate joint probability of prior with likelihoods for given allele frequency ranges.",11,null],[10,"marginal_prob","","Calculate marginal probability.",11,null],[10,"map","","Calculate maximum a posteriori probability estimate of allele frequencies.",11,null],[10,"allele_freqs","","Return allele frequency spectra.",11,null],[0,"sample","libprosic::model","",null,null],[3,"RecordBuffer","libprosic::model::sample","Ringbuffer of BAM records. This data structure ensures that no bam record is read twice while\nextracting observations for given variants.",null,null],[3,"Observation","","An observation for or against a variant.",null,null],[12,"prob_mapping","","Posterior probability that the read/read-pair has been mapped correctly (1 - MAPQ).",12,null],[12,"prob_alt","","Probability that the read/read-pair comes from the alternative allele.",12,null],[12,"prob_ref","","Probability that the read/read-pair comes from the reference allele.",12,null],[12,"prob_mismapped","","Probability of the read/read-pair given that it has been mismapped.",12,null],[12,"evidence","","Type of evidence.",12,null],[3,"InsertSize","","Expected insert size in terms of mean and standard deviation.\nThis should be estimated from unsorted(!) bam files to avoid positional biases.",null,null],[12,"mean","","",13,null],[12,"sd","","",13,null],[3,"Sample","","A sequenced sample, e.g., a tumor or a normal sample.",null,null],[4,"RecordBufferError","","",null,null],[13,"UnknownSequence","","",14,null],[4,"Evidence","","",null,null],[13,"InsertSize","","Insert size of fragment",15,null],[13,"Alignment","","Alignment of a single read",15,null],[5,"prob_mapping","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"logprob"}}],[5,"isize_pmf","","as shown in http://www.milefoot.com/math/stat/pdfc-normaldisc.htm",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"logprob"}}],[5,"isize_density","","Continuous normal density (obsolete).",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"logprob"}}],[5,"isize_density_louis","","Manual normal density (obsolete, we can use GSL (see above)).",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"logprob"}}],[5,"isize_mixture_density_louis","","",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"logprob"}}],[11,"fmt","","",14,null],[11,"fmt","","",14,null],[11,"description","","",14,null],[11,"cause","","",14,null],[11,"new","","Create a new `RecordBuffer`.",16,{"inputs":[{"name":"indexedreader"},{"name":"u32"},{"name":"bool"}],"output":{"name":"self"}}],[11,"fill","","Fill buffer around the given interval.",16,null],[11,"iter","","",16,null],[11,"encode","","",12,null],[11,"decode","","",12,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"fmt","","",12,null],[11,"clone","","",12,null],[11,"encode","","",15,null],[11,"decode","","",15,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"new","","Create a new `Sample`.",17,{"inputs":[{"name":"indexedreader"},{"name":"u32"},{"name":"bool"},{"name":"bool"},{"name":"bool"},{"name":"insertsize"},{"name":"latentvariablemodel"},{"name":"prob"},{"name":"prob"},{"name":"prob"},{"name":"prob"}],"output":{"name":"self"}}],[11,"max_indel_dist","","",17,null],[11,"max_indel_len_diff","","",17,null],[11,"likelihood_model","","Return likelihood model.",17,null],[11,"extract_observations","","Extract observations for the given variant.",17,null],[6,"AlleleFreq","libprosic::model","",null,null],[6,"DiscreteAlleleFreqs","","",null,null],[6,"ContinuousAlleleFreqs","","",null,null],[8,"AlleleFreqs","","",null,null],[11,"clone","","",3,null],[11,"has_fragment_evidence","","",3,null],[11,"is_indel","","",3,null],[11,"is_type","","",3,null],[11,"new","","Create new `JointModel`.",18,{"inputs":[{"name":"sample"},{"name":"sample"},{"name":"p"}],"output":{"name":"self"}}],[11,"pileup","","Calculate pileup and marginal probability for given variant.",18,null],[11,"posterior_prob","","Calculate posterior probability of given allele frequencies.",19,null],[11,"map_allele_freqs","","",19,null],[11,"case_observations","","",19,null],[11,"control_observations","","",19,null],[0,"estimation","libprosic","",null,null],[0,"effective_mutation_rate","libprosic::estimation","",null,null],[3,"Estimate","libprosic::estimation::effective_mutation_rate","",null,null],[12,"observations","","",20,null],[12,"intercept","","",20,null],[12,"slope","","",20,null],[5,"estimate","","",null,{"inputs":[{"name":"f"}],"output":{"name":"estimate"}}],[11,"encode","","",20,null],[11,"decode","","",20,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"fmt","","",20,null],[11,"effective_mutation_rate","","",20,null],[0,"fdr","libprosic::estimation","",null,null],[5,"annotate","libprosic::estimation::fdr","Annotate a given VCF/BCF file with FDR estimates for the given events.",null,null],[0,"fdr_bh","libprosic::estimation","",null,null],[5,"control_fdr","libprosic::estimation::fdr_bh","Print thresholds to control FDR of given calls at multiple levels.",null,{"inputs":[{"name":"reader"},{"name":"reader"},{"name":"w"},{"name":"e"},{"name":"varianttype"}],"output":{"name":"result"}}],[0,"call","libprosic","",null,null],[0,"pairwise","libprosic::call","",null,null],[3,"PairEvent","libprosic::call::pairwise","",null,null],[12,"name","","event name",21,null],[12,"af_case","","allele frequencies for case sample",21,null],[12,"af_control","","allele frequencies for control sample",21,null],[5,"call","","Call variants with the given model.",null,null],[11,"name","","",21,null],[0,"utils","libprosic","",null,null],[5,"collect_variants","libprosic::utils","Collect variants from a given ´bcf::Record`.",null,{"inputs":[{"name":"record"},{"name":"bool"},{"name":"bool"},{"name":"option"}],"output":{"name":"result"}}],[8,"Event","libprosic","Event to call.",null,null],[10,"name","","",22,null],[11,"tag_name","","",22,null],[11,"header_entry","","",22,null],[11,"fmt","","",1,null],[11,"fmt","","",1,null],[11,"description","","",1,null],[11,"cause","","",1,null],[11,"name","","",0,null]],"paths":[[3,"ComplementEvent"],[4,"BCFError"],[4,"VariantType"],[4,"Variant"],[3,"LatentVariableModel"],[3,"InfiniteSitesNeutralVariationModel"],[3,"TumorNormalModel"],[3,"TumorNormalRelapseModel"],[3,"FlatTumorNormalModel"],[8,"Model"],[8,"PairModel"],[8,"TrioModel"],[3,"Observation"],[3,"InsertSize"],[4,"RecordBufferError"],[4,"Evidence"],[3,"RecordBuffer"],[3,"Sample"],[3,"PairModel"],[3,"PairPileup"],[3,"Estimate"],[3,"PairEvent"],[8,"Event"]]};
searchIndex["bio"] = {"doc":"# Rust-bio, a bioinformatics library for Rust.\nThis library provides implementations of many algorithms and data structures\nthat are useful for bioinformatics.\nAll provided implementations are rigorously tested via continuous\nintegration.\nFor installation instructions and a general overview, visit\nhttps://rust-bio.github.io.","items":[[0,"utils","bio","Common utilities.",null,null],[3,"NonNaNFloat","bio::utils","",null,null],[5,"trim_newline","","Remove a trailing newline from the given string in place.",null,{"inputs":[{"name":"string"}],"output":null}],[5,"scan","","In place implementation of scan over a slice.",null,null],[5,"prescan","","",null,null],[6,"Text","","Type alias for an owned text, i.e. ``Vec&lt;u8&gt;``.",null,null],[6,"TextSlice","","Type alias for a text slice, i.e. ``&amp;[u8]``.",null,null],[8,"TextIterator","","Type alias for an iterator over a sequence, i.e. ``Iterator&lt;Item=&amp;u8&gt;``.",null,null],[8,"IntoTextIterator","","Type alias for a type that can be coerced into a `TextIterator`.\nThis includes ``&amp;Vec&lt;u8&gt;``, ``&amp;[u8]``, ``Iterator&lt;Item=&amp;u8&gt;``.",null,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"new","","",0,{"inputs":[{"name":"f"}],"output":{"name":"option"}}],[11,"unwrap","","",0,null],[11,"cmp","","",0,null],[0,"alphabets","bio","Implementation of alphabets and useful utilities.",null,null],[3,"Alphabet","bio::alphabets","Representation of an alphabet.",null,null],[12,"symbols","","",1,null],[3,"RankTransform","","Tools based on transforming the alphabet symbols to their lexicographical ranks.",null,null],[12,"ranks","","",2,null],[3,"QGrams","","Iterator over q-grams.",null,null],[0,"dna","","Implementation of the DNA alphabet.",null,null],[5,"alphabet","bio::alphabets::dna","The DNA alphabet (uppercase and lowercase).",null,{"inputs":[],"output":{"name":"alphabet"}}],[5,"n_alphabet","","The DNA alphabet including N (uppercase and lowercase).",null,{"inputs":[],"output":{"name":"alphabet"}}],[5,"iupac_alphabet","","The IUPAC DNA alphabet (uppercase and lowercase).",null,{"inputs":[],"output":{"name":"alphabet"}}],[5,"complement","","Return complement of given DNA alphabet character (IUPAC alphabet supported).",null,{"inputs":[{"name":"u8"}],"output":{"name":"u8"}}],[5,"revcomp","","Calculate reverse complement of given text (IUPAC alphabet supported).",null,{"inputs":[{"name":"t"}],"output":{"name":"vec"}}],[0,"protein","bio::alphabets","Implementation of the protein alphabet.",null,null],[5,"alphabet","bio::alphabets::protein","Returns the standard protein alphabet, containing the 20 common amino acids.",null,{"inputs":[],"output":{"name":"alphabet"}}],[6,"SymbolRanks","bio::alphabets","",null,null],[11,"new","","Create new alphabet from given symbols.",1,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"insert","","Insert symbol into alphabet.",1,null],[11,"is_word","","Check if given text is a word over the alphabet.",1,null],[11,"max_symbol","","Return lexicographically maximal symbol.",1,null],[11,"len","","Return size of the alphabet.",1,null],[11,"is_empty","","Is this alphabet empty?",1,null],[11,"new","","Construct a new `RankTransform`.",2,{"inputs":[{"name":"alphabet"}],"output":{"name":"self"}}],[11,"get","","Get the rank of symbol `a`.",2,null],[11,"transform","","Transform a given `text`.",2,null],[11,"qgrams","","Iterate over q-grams (substrings of length q) of given `text`. The q-grams are encoded\nas `usize` by storing the symbol ranks in log2(|A|) bits (with |A| being the alphabet size).",2,null],[11,"alphabet","","Restore alphabet from transform.",2,null],[11,"next","","",3,null],[0,"pattern_matching","bio","This module contains various useful pattern matching algorithms.\nThe implementations are based on the lecture notes\n&quot;Algorithmen auf Sequenzen&quot;, Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015.",null,null],[0,"shift_and","bio::pattern_matching","`ShiftAnd` algorithm for pattern matching.\nPatterns may contain at most 64 symbols.\nComplexity: O(n) with text length n.",null,null],[3,"ShiftAnd","bio::pattern_matching::shift_and","`ShiftAnd` algorithm.",null,null],[3,"Matches","","Iterator over start positions of matches.",null,null],[5,"masks","","Calculate ShiftAnd masks. This function is called automatically when instantiating\na new ShiftAnd for a given pattern.",null,null],[11,"new","","Create new ShiftAnd instance from a given pattern.",4,{"inputs":[{"name":"p"}],"output":{"name":"self"}}],[11,"find_all","","Find all matches of pattern in the given text. Matches are returned as an iterator\nover start positions.",4,null],[11,"next","","",5,null],[0,"kmp","bio::pattern_matching","Algorithm of Knuth Morris and Pratt.\nConstructs an automaton recognizing the pattern, and scans linearly over\na text of length n. Complexity: O(n).\nThe transition function delta is simulated via the lps-function, that assigns to each position\nq in the pattern the longest prefix of the pattern that is suffix of pattern[..q+1].\nThen, in the NFA for the pattern, active states after reading position q are\n{q, lps(q), lps(lps(q)), ... 0}.",null,null],[3,"KMP","bio::pattern_matching::kmp","KMP algorithm.",null,null],[3,"Matches","","Iterator over start positions of matches.",null,null],[11,"new","","Create a new instance for a given pattern.",6,{"inputs":[{"name":"textslice"}],"output":{"name":"self"}}],[11,"find_all","","Find all matches of pattern in a given text. Matches are returned as iterator over start positions.",6,null],[11,"next","","",7,null],[0,"bom","bio::pattern_matching","Backward oracle matching algorithm.\nBest-case complexity: O(n / m) with pattern of length m and text of length n.\nWorst case complexity: O(n * m).",null,null],[3,"BOM","bio::pattern_matching::bom","Backward oracle matching algorithm.",null,null],[3,"Matches","","Iterator over start positions of matches.",null,null],[11,"new","","Create a new instance for a given pattern.",8,{"inputs":[{"name":"p"}],"output":{"name":"self"}}],[11,"find_all","","Find all matches of the pattern in the given text. Matches are returned as an iterator over start positions.",8,null],[11,"next","","",9,null],[0,"horspool","bio::pattern_matching","Algorithm of Horspool.\nWindow-based, similar to but faster than Boyer-Moore.",null,null],[3,"Horspool","bio::pattern_matching::horspool","Algorithm of Horspool.",null,null],[3,"Matches","","Iterator over start positions of matches.",null,null],[11,"new","","Create a new instance for a given pattern.",10,{"inputs":[{"name":"textslice"}],"output":{"name":"self"}}],[11,"find_all","","Find all matches with a given text. Matches are returned as an iterator over start positions.",10,null],[11,"next","","",11,null],[0,"bndm","bio::pattern_matching","Backward nondeterministic DAWG matching (BNDM).\nBest-case complexity: O(n / m) with pattern of length m &lt;= 64 and text of length n.\nWorst case complexity: O(n * m).",null,null],[3,"BNDM","bio::pattern_matching::bndm","BNDM algorithm.",null,null],[3,"Matches","","Iterator over start positions of matches.",null,null],[11,"new","","Create a new instance for a given pattern.",12,{"inputs":[{"name":"p"}],"output":{"name":"self"}}],[11,"find_all","","Find all matches of pattern with a given text. Matches are returned as iterator over start positions.",12,null],[11,"next","","",13,null],[0,"ukkonen","bio::pattern_matching","Bounded version of Ukkonens DP algorithm for approximate pattern matching.\nComplexity: O(n * k) on random texts.",null,null],[3,"Ukkonen","bio::pattern_matching::ukkonen","Ukkonens algorithm.",null,null],[3,"Matches","","Iterator over pairs of end positions and distance of matches.",null,null],[5,"unit_cost","","Default cost function (unit costs).",null,{"inputs":[{"name":"u8"},{"name":"u8"}],"output":{"name":"u32"}}],[11,"with_capacity","","Initialize algorithm with given capacity and cost function.",14,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"self"}}],[11,"find_all_end","","Find all matches between pattern and text with up to k errors.\nMatches are returned as an iterator over pairs of end position and distance.",14,null],[11,"next","","",15,null],[0,"myers","bio::pattern_matching","Myers bit-parallel approximate pattern matching algorithm.\nFinds all matches up to a given edit distance. The pattern has to fit into a bitvector,\nand is here limited to 64 symbols.\nComplexity: O(n)",null,null],[3,"Myers","bio::pattern_matching::myers","Myers algorithm.",null,null],[3,"Matches","","Iterator over pairs of end positions and distance of matches.",null,null],[11,"new","","Create a new instance of Myers algorithm for a given pattern.",16,{"inputs":[{"name":"p"}],"output":{"name":"self"}}],[11,"with_wildcard","","Create a new instance of Myers algorithm for a given pattern and a wildcard character\nthat shall match any character.",16,{"inputs":[{"name":"textslice"},{"name":"u8"}],"output":{"name":"self"}}],[11,"distance","","Calculate the global distance of the pattern to the given text.",16,null],[11,"find_all_end","","Find all matches of pattern in the given text up to a given maximum distance.\nMatches are returned as an iterator over pairs of end position and distance.",16,null],[11,"next","","",17,null],[0,"data_structures","bio","Various useful data structures.",null,null],[0,"rank_select","bio::data_structures","Rank/Select data structure based on Gonzalez, Grabowski, Mäkinen, Navarro (2005).\nThis implementation uses only a single level of blocks, and performs well for large n.",null,null],[3,"RankSelect","bio::data_structures::rank_select","A rank/select data structure.",null,null],[11,"new","","Create a new instance.",18,{"inputs":[{"name":"bitvec"},{"name":"usize"}],"output":{"name":"rankselect"}}],[11,"rank","","Get the rank of a given bit, i.e. the number of 1-bits in the bitvector up to i (inclusive).\nComplexity: O(k).",18,null],[11,"select","","Get the smallest bit with a given rank.\nComplexity: O(log (n / k) + k).",18,null],[0,"suffix_array","bio::data_structures","Suffix arrays and related algorithms.\nThe implementation is based on the lecture notes\n&quot;Algorithmen auf Sequenzen&quot;, Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015.",null,null],[5,"suffix_array","bio::data_structures::suffix_array","Construct suffix array for given text of length n.\nComplexity: O(n).\nThis is an implementation of the induced sorting as presented by\nGe Nong, Sen Zhang und Wai Hong Chan (2009), also known as SAIS.\nThe implementation is based on the following lecture notes:\nhttp://ls11-www.cs.tu-dortmund.de/people/rahmann/algoseq.pdf",null,null],[5,"lcp","","Construct lcp array for given text and suffix array of length n.\nComplexity: O(n).",null,null],[5,"shortest_unique_substrings","","Calculate all locally shortest unique substrings from a given suffix and lcp array\n(Ohlebusch (2013). &quot;Bioinformatics Algorithms&quot;. ISBN 978-3-00-041316-2).\nComplexity: O(n)",null,{"inputs":[{"name":"sa"},{"name":"lcparray"}],"output":{"name":"vec"}}],[6,"LCPArray","","",null,null],[6,"RawSuffixArray","","",null,null],[8,"SuffixArray","","A trait exposing general functionality of suffix arrays.",null,null],[10,"get","","",19,null],[10,"len","","",19,null],[11,"get","","",20,null],[11,"len","","",20,null],[0,"bwt","bio::data_structures","The Burrows-Wheeler-Transform and related data structures.\nThe implementation is based on the lecture notes\n&quot;Algorithmen auf Sequenzen&quot;, Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015.",null,null],[3,"Occ","bio::data_structures::bwt","An occurence array implementation.",null,null],[5,"bwt","","Calculate Burrows-Wheeler-Transform of the given text of length n.\nComplexity: O(n).",null,null],[5,"invert_bwt","","Calculate the inverse of a BWT of length n, which is the original text.\nComplexity: O(n).",null,{"inputs":[{"name":"bwtslice"}],"output":{"name":"vec"}}],[5,"less","","Calculate the less array for a given BWT. Complexity O(n).",null,{"inputs":[{"name":"bwtslice"},{"name":"alphabet"}],"output":{"name":"less"}}],[5,"bwtfind","","Calculate the bwtfind array needed for inverting the BWT. Complexity O(n).",null,{"inputs":[{"name":"bwtslice"},{"name":"alphabet"}],"output":{"name":"bwtfind"}}],[6,"BWT","","",null,null],[6,"BWTSlice","","",null,null],[6,"Less","","",null,null],[6,"BWTFind","","",null,null],[8,"DerefBWT","","",null,null],[8,"DerefOcc","","",null,null],[8,"DerefLess","","",null,null],[11,"new","","Calculate occ array with sampling from BWT of length n.\nTime complexity: O(n).\nSpace complexity: O(n / k * A) with A being the alphabet size.\nAlphabet size is determined on the fly from the BWT.\nFor large texts, it is therefore advisable to transform\nthe text before calculating the BWT (see alphabets::rank_transform).",21,{"inputs":[{"name":"bwtslice"},{"name":"usize"},{"name":"alphabet"}],"output":{"name":"self"}}],[11,"get","","Get occurrence count of symbol a in BWT[..r+1].\nComplexity: O(k).",21,null],[0,"bitenc","bio::data_structures","A fixed-width bit encoding implementation. This allows to store a sequence of values over\na reduced alphabet by packing them bit-encoded into a sequence of bytes.",null,null],[3,"BitEnc","bio::data_structures::bitenc","A sequence of bitencoded values.",null,null],[3,"BitEncIter","","Iterator over values of a bitencoded sequence (values will be unpacked into bytes).",null,null],[11,"new","","Create a new instance with a given encoding width (e.g. width=2 for using two bits per value).",22,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"with_capacity","","Create a new instance with a given capacity and encoding width (e.g. width=2 for using two bits per value).",22,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"push","","Append a value.",22,null],[11,"push_values","","Append `n` times the given value.",22,null],[11,"set","","Set the value as position `i`.",22,null],[11,"get","","Get the value at position `i`.",22,null],[11,"iter","","Iterate over stored values (values will be unpacked into bytes).",22,null],[11,"clear","","Clear the sequence.",22,null],[11,"len","","",22,null],[11,"is_empty","","",22,null],[11,"next","","",23,null],[0,"smallints","bio::data_structures","A data structure for a sequence of small integers with a few big integers.\nSmall ints are stored in type S (e.g. a byte), big ints are stored separately (in type B) in a BTree.\nThe implementation provides vector-like operations on the data structure (e.g. retrieve a position,\nadd an integer, etc.).",null,null],[3,"SmallInts","bio::data_structures::smallints","Data structure for storing a sequence of small integers with few big ones space efficiently\nwhile supporting classical vector operations.",null,null],[3,"Iter","","Iterator over the elements of a `SmallInts` sequence.",null,null],[11,"new","","Create a new instance.",24,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new instance with a given capacity.",24,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from_elem","","Create a new instance containing `n` times the integer `v` (and `v` is expected to be small).",24,{"inputs":[{"name":"s"},{"name":"usize"}],"output":{"name":"self"}}],[11,"get","","Return the integer at position `i`.",24,null],[11,"push","","Append `v` to the sequence. This will determine whether `v` is big or small and store it accordingly.",24,null],[11,"set","","Set value of position `i` to `v`. This will determine whether `v` is big or small and store it accordingly.",24,null],[11,"iter","","Iterate over sequence. Values will be returned in the big integer type (`B`).",24,null],[11,"decompress","","Decompress into a normal vector of big integers (type `B`).",24,null],[11,"len","","Length of the sequence.",24,null],[11,"is_empty","","is the sequence empty?",24,null],[11,"next","","",25,null],[0,"fmindex","bio::data_structures","FM-Index and FMD-Index for finding suffix array intervals matching a given pattern in linear time.",null,null],[3,"Interval","bio::data_structures::fmindex","A suffix array interval.",null,null],[12,"lower","","",26,null],[12,"upper","","",26,null],[3,"FMIndex","","The Fast Index in Minute space (FM-Index, Ferragina and Manzini, 2000) for finding suffix array\nintervals matching a given pattern.",null,null],[3,"BiInterval","","A bi-interval on suffix array of the forward and reverse strand of a DNA text.",null,null],[3,"FMDIndex","","The FMD-Index for linear time search of supermaximal exact matches on forward and reverse\nstrand of DNA texts (Li, 2012).",null,null],[8,"FMIndexable","","",null,null],[10,"occ","","Get occurrence count of symbol a in BWT[..r+1].",27,null],[10,"less","","Also known as",27,null],[10,"bwt","","",27,null],[11,"backward_search","","Perform backward search, yielding suffix array\ninterval denoting exact occurrences of the given pattern of length m in the text.\nComplexity: O(m).",27,null],[11,"fmt","","",26,null],[11,"clone","","",26,null],[11,"occ","","",26,null],[11,"occ","","",28,null],[11,"less","","",28,null],[11,"bwt","","Provide a reference to the underlying BWT.",28,null],[11,"new","","Construct a new instance of the FM index.",28,{"inputs":[{"name":"dbwt"},{"name":"dless"},{"name":"docc"}],"output":{"name":"self"}}],[11,"fmt","","",29,null],[11,"clone","","",29,null],[11,"forward","","",29,null],[11,"revcomp","","",29,null],[11,"occ","","",30,null],[11,"less","","",30,null],[11,"bwt","","Provide a reference to the underlying BWT.",30,null],[11,"from","","Construct a new instance of the FMD index (see Heng Li (2012) Bioinformatics).\nThis expects a BWT that was created from a text over the DNA alphabet with N\n(`alphabets::dna::n_alphabet()`) consisting of the\nconcatenation with its reverse complement, separated by the sentinel symbol `$`.\nI.e., let T be the original text and R be its reverse complement.\nThen, the expected text is T$R$. Further, multiple concatenated texts are allowed, e.g.\nT1$R1$T2$R2$T3$R3$.",30,{"inputs":[{"name":"fmindex"}],"output":{"name":"fmdindex"}}],[11,"smems","","Find supermaximal exact matches of given pattern that overlap position i in the pattern.\nComplexity O(m) with pattern of length m.",30,null],[11,"backward_ext","","",30,null],[11,"forward_ext","","",30,null],[0,"qgram_index","bio::data_structures","A classical, flexible, q-gram index implementation.",null,null],[3,"QGramIndex","bio::data_structures::qgram_index","A classical, flexible, q-gram index implementation.",null,null],[3,"Interval","","An interval, consisting of start and stop position (the latter exclusive).",null,null],[12,"start","","",31,null],[12,"stop","","",31,null],[3,"Match","","A match between the pattern and the text.",null,null],[12,"pattern","","",32,null],[12,"text","","",32,null],[12,"count","","",32,null],[3,"ExactMatch","","An exact match between the pattern and the text.",null,null],[12,"pattern","","",33,null],[12,"text","","",33,null],[11,"new","","Create a new q-gram index.\nThe q has to be smaller than b / log2(|A|) with |A| being the alphabet size and b the number\nbits with the `usize` data type.",34,null],[11,"with_max_count","","Create a new q-gram index, only considering q-grams that occur at most `max_count` times.\nThe q has to be smaller than b / log2(|A|) with |A| being the alphabet size and b the number\nbits with the `usize` data type.",34,null],[11,"q","","The used q.",34,null],[11,"qgram_matches","","Return text positions with matching q-gram. Complexity O(1).",34,null],[11,"matches","","Return matches of the given pattern.\nComplexity O(m + k) for pattern of length m and k being the number of matching q-grams.",34,null],[11,"exact_matches","","Return exact matches (substrings) of the given pattern.\nComplexity O(m + k) for pattern of length m and k being the number of matching q-grams.",34,null],[11,"clone","","",31,null],[11,"fmt","","",31,null],[11,"eq","","",31,null],[11,"ne","","",31,null],[11,"get","","Get the text within the given interval.",31,null],[11,"clone","","",32,null],[11,"fmt","","",32,null],[11,"eq","","",32,null],[11,"ne","","",32,null],[11,"cmp","","",32,null],[11,"partial_cmp","","",32,null],[11,"clone","","",33,null],[11,"fmt","","",33,null],[11,"eq","","",33,null],[11,"ne","","",33,null],[0,"interval_tree","bio::data_structures","",null,null],[3,"IntervalTree","bio::data_structures::interval_tree","",null,null],[3,"Entry","","",null,null],[3,"IntervalTreeIterator","","",null,null],[3,"Node","","",null,null],[11,"clone","","",35,null],[11,"fmt","","",35,null],[11,"eq","","",35,null],[11,"ne","","",35,null],[11,"clone","","",36,null],[11,"fmt","","",36,null],[11,"eq","","",36,null],[11,"ne","","",36,null],[11,"data","","Get a reference to the data for this entry",36,null],[11,"interval","","Get a reference to the interval for this entry",36,null],[11,"next","","",37,null],[11,"new","","",35,{"inputs":[],"output":{"name":"self"}}],[11,"insert","","",35,null],[11,"find","","",35,null],[11,"clone","","",38,null],[11,"fmt","","",38,null],[11,"eq","","",38,null],[11,"ne","","",38,null],[11,"new","","",38,{"inputs":[{"name":"range"},{"name":"d"}],"output":{"name":"self"}}],[11,"insert","","",38,null],[11,"find_iter","","",38,null],[11,"has_match","","",38,null],[0,"alignment","bio","Various alignment and distance computing algorithms.",null,null],[3,"Alignment","bio::alignment","An alignment, consisting of a score, the start and end position of the alignment on\nsequence x and sequence y, the length of sequence x,\nand the alignment edit operations (see `alignment::pairwise` for meaning of x and y).",null,null],[12,"score","","",39,null],[12,"ystart","","",39,null],[12,"xstart","","",39,null],[12,"yend","","",39,null],[12,"xend","","",39,null],[12,"xlen","","",39,null],[12,"operations","","",39,null],[4,"AlignmentOperation","","Alignment operations (Match, Subst, Del and Ins).",null,null],[13,"Match","","",40,null],[13,"Subst","","",40,null],[13,"Del","","",40,null],[13,"Ins","","",40,null],[0,"pairwise","","Calculate alignments with a generalized variant of the Smith Waterman algorithm.\nComplexity: O(n * m) for strings of length m and n.",null,null],[3,"Aligner","bio::alignment::pairwise","A generalized Smith-Waterman aligner.",null,null],[11,"new","","Create new aligner instance with given gap open and gap extend penalties\nand the score function.",41,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"f"}],"output":{"name":"self"}}],[11,"with_capacity","","Create new aligner instance. The size hints help to\navoid unnecessary memory allocations.",41,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"i32"},{"name":"i32"},{"name":"f"}],"output":{"name":"self"}}],[11,"global","","Calculate global alignment of x against y.",41,null],[11,"semiglobal","","Calculate semiglobal alignment of x against y (x is global, y is local).",41,null],[11,"local","","Calculate local alignment of x against y.",41,null],[0,"distance","bio::alignment","Various subroutines for computing a distance between sequences.\nComplexity: O(n) for strings of length n for the Hamming distance;\nO(n * m) for strings of length n and m for the Levenshtein (or edit) distance.",null,null],[5,"hamming","bio::alignment::distance","Compute the Hamming distance between two strings with `hamming`. If returns the `Result&lt;u32, &amp;str&gt;` type\nwith the first element corresponding to the distance between two strings (a number of mismatches) and the second one to the error message\nwhen two strings are not of equal sizes.",null,{"inputs":[{"name":"textslice"},{"name":"textslice"}],"output":{"name":"result"}}],[5,"levenshtein","","Compute the Levenshtein (or Edit) distance between two strings with `levenshtein`. It returns a distance between two strings,\ni.e. minimal number of mismatches, insertions and deletions between two strings.",null,{"inputs":[{"name":"textslice"},{"name":"textslice"}],"output":{"name":"u32"}}],[11,"clone","bio::alignment","",40,null],[11,"fmt","","",40,null],[11,"eq","","",40,null],[11,"fmt","","",39,null],[11,"cigar","","Calculate the cigar string.",39,null],[11,"pretty","","Return the pretty formatted alignment as a String.",39,null],[0,"io","bio","Readers and writers for common bioinformatics file formats.",null,null],[4,"Strand","bio::io","Strand information.",null,null],[13,"Forward","","",42,null],[13,"Reverse","","",42,null],[13,"Unknown","","",42,null],[0,"fastq","","FastQ reading and writing.",null,null],[3,"Reader","bio::io::fastq","A FastQ reader.",null,null],[3,"Record","","A FastQ record.",null,null],[3,"Records","","An iterator over the records of a FastQ file.",null,null],[3,"Writer","","A FastQ writer.",null,null],[11,"from_file","","Read from a given file.",43,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"new","","Read from a given `io::Read`.",43,{"inputs":[{"name":"r"}],"output":{"name":"self"}}],[11,"read","","Read into a given record.\nReturns an error if the record in incomplete or syntax is violated.\nThe content of the record can be checked via the record object.",43,null],[11,"records","","Return an iterator over the records of this FastQ file.",43,null],[11,"default","","",44,{"inputs":[],"output":{"name":"record"}}],[11,"clone","","",44,null],[11,"fmt","","",44,null],[11,"new","","Create a new, empty FastQ record.",44,{"inputs":[],"output":{"name":"self"}}],[11,"is_empty","","Check if record is empty.",44,null],[11,"check","","Check validity of FastQ record.",44,null],[11,"id","","Return the id of the record.",44,null],[11,"desc","","Return descriptions if present.",44,null],[11,"seq","","Return the sequence of the record.",44,null],[11,"qual","","Return the base qualities of the record.",44,null],[11,"fmt","","",44,null],[11,"next","","",45,null],[11,"to_file","","Write to a given file path.",46,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"new","","Write to a given `io::Write`.",46,{"inputs":[{"name":"w"}],"output":{"name":"self"}}],[11,"write_record","","Directly write a FastQ record.",46,null],[11,"write","","Write a FastQ record with given id, optional description, sequence and qualities.",46,null],[11,"flush","","Flush the writer, ensuring that everything is written.",46,null],[0,"fasta","bio::io","FASTA format reading and writing.",null,null],[3,"Reader","bio::io::fasta","A FASTA reader.",null,null],[3,"Index","","A FASTA index as created by SAMtools (.fai).",null,null],[3,"IndexedReader","","A FASTA reader with an index as created by SAMtools (.fai).",null,null],[12,"index","","",47,null],[3,"Sequence","","A sequence record returned by the FASTA index.",null,null],[12,"name","","",48,null],[12,"len","","",48,null],[3,"Writer","","A Fasta writer.",null,null],[3,"Record","","A FASTA record.",null,null],[3,"Records","","An iterator over the records of a Fasta file.",null,null],[11,"from_file","","Read FASTA from given file path.",49,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"new","","Create a new Fasta reader given an instance of `io::Read`.",49,{"inputs":[{"name":"r"}],"output":{"name":"self"}}],[11,"read","","Read next FASTA record into the given `Record`.",49,null],[11,"records","","Return an iterator over the records of this FastQ file.",49,null],[11,"new","","Open a FASTA index from a given `io::Read` instance.",50,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"from_file","","Open a FASTA index from a given file path.",50,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"with_fasta_file","","Open a FASTA index given the corresponding FASTA file path (e.g. for ref.fasta we expect ref.fasta.fai).",50,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"sequences","","Return a vector of sequences described in the index.",50,null],[11,"from_file","","Read from a given file path. This assumes the index ref.fasta.fai to be present for FASTA ref.fasta.",47,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"new","","Read from a FASTA and its index, both given as `io::Read`. FASTA has to be `io::Seek` in addition.",47,{"inputs":[{"name":"r"},{"name":"i"}],"output":{"name":"result"}}],[11,"with_index","","Read from a FASTA and its index, the first given as `io::Read`, the second given as index object.",47,{"inputs":[{"name":"r"},{"name":"index"}],"output":{"name":"self"}}],[11,"read_all","","For a given seqname, read the whole sequence into the given vector.",47,null],[11,"read","","Read the given interval of the given seqname into the given vector (stop position is exclusive).",47,null],[11,"to_file","","Write to the given file path.",51,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"new","","Create a new Fasta writer.",51,{"inputs":[{"name":"w"}],"output":{"name":"self"}}],[11,"write_record","","Directly write a Fasta record.",51,null],[11,"write","","Write a Fasta record with given id, optional description and sequence.",51,null],[11,"flush","","Flush the writer, ensuring that everything is written.",51,null],[11,"default","","",52,{"inputs":[],"output":{"name":"record"}}],[11,"new","","Create a new instance.",52,{"inputs":[],"output":{"name":"self"}}],[11,"is_empty","","Check if record is empty.",52,null],[11,"check","","Check validity of Fasta record.",52,null],[11,"id","","Return the id of the record.",52,null],[11,"desc","","Return descriptions if present.",52,null],[11,"seq","","Return the sequence of the record.",52,null],[11,"next","","",53,null],[0,"bed","bio::io","BED format reading and writing.",null,null],[3,"Reader","bio::io::bed","A BED reader.",null,null],[3,"Records","","A BED record.",null,null],[3,"Writer","","A BED writer.",null,null],[3,"Record","","A BED record as defined by BEDtools (http://bedtools.readthedocs.org/en/latest/content/general-usage.html)",null,null],[11,"from_file","","Read from a given file path.",54,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"new","","Read from a given reader.",54,{"inputs":[{"name":"r"}],"output":{"name":"self"}}],[11,"records","","Iterate over all records.",54,null],[11,"next","","",55,null],[11,"to_file","","Write to a given file path.",56,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"new","","Write to a given writer.",56,{"inputs":[{"name":"w"}],"output":{"name":"self"}}],[11,"write","","Write a given BED record.",56,null],[11,"default","","",57,{"inputs":[],"output":{"name":"record"}}],[11,"encode","","",57,null],[11,"new","","Create a new BED record.",57,{"inputs":[],"output":{"name":"self"}}],[11,"chrom","","Chromosome of the feature.",57,null],[11,"start","","Start position of feature (0-based).",57,null],[11,"end","","End position of feature (0-based, not included).",57,null],[11,"name","","Name of the feature.",57,null],[11,"score","","Score of the feature.",57,null],[11,"strand","","Strand of the feature.",57,null],[11,"aux","","Access auxilliary fields after the strand field by index (counting first field (chromosome) as 0).",57,null],[11,"set_chrom","","Set chromosome.",57,null],[11,"set_start","","Set start of feature.",57,null],[11,"set_end","","Set end of feature.",57,null],[11,"set_name","","Set name.",57,null],[11,"set_score","","Set score.",57,null],[11,"push_aux","","Add auxilliary field. This has to happen after name and score have been set.",57,null],[0,"gff","bio::io","GFF3 format reading and writing.",null,null],[3,"Reader","bio::io::gff","A GFF reader.",null,null],[3,"Records","","A GFF record.",null,null],[3,"Writer","","A GFF writer.",null,null],[3,"Record","","A GFF record",null,null],[4,"GffType","","`GffType`",null,null],[13,"GFF3","","Attribute format is key1=value, key2=value",58,null],[13,"GFF2","","Attribute format is key1 value; key2 value",58,null],[13,"GTF2","","Same as GFF2 just possible keyword and possible value change",58,null],[13,"Any","","Any, first field of tuple is key value separator, second is field separator",58,null],[11,"clone","","",58,null],[11,"from_file","","Read GFF from given file path in given format.",59,{"inputs":[{"name":"p"},{"name":"gfftype"}],"output":{"name":"result"}}],[11,"new","","Create a new GFF reader given an instance of `io::Read`, in given format.",59,{"inputs":[{"name":"r"},{"name":"gfftype"}],"output":{"name":"self"}}],[11,"records","","Iterate over all records.",59,null],[11,"next","","",60,null],[11,"to_file","","Write to a given file path in given format.",61,{"inputs":[{"name":"p"},{"name":"gfftype"}],"output":{"name":"result"}}],[11,"new","","Write to a given writer.",61,{"inputs":[{"name":"w"},{"name":"gfftype"}],"output":{"name":"self"}}],[11,"write","","Write a given GFF record.",61,null],[11,"default","","",62,{"inputs":[],"output":{"name":"record"}}],[11,"encode","","",62,null],[11,"new","","Create a new GFF record.",62,{"inputs":[],"output":{"name":"self"}}],[11,"seqname","","Sequence name of the feature.",62,null],[11,"source","","Source of the feature.",62,null],[11,"feature_type","","Type of the feature.",62,null],[11,"start","","Start position of feature (1-based).",62,null],[11,"end","","End position of feature (1-based, not included).",62,null],[11,"score","","Score of feature",62,null],[11,"strand","","Strand of the feature.",62,null],[11,"frame","","Frame of the feature.",62,null],[11,"attributes","","Attribute of feature",62,null],[11,"seqname_mut","","Get mutable reference on seqname of feature.",62,null],[11,"source_mut","","Get mutable reference on source of feature.",62,null],[11,"feature_type_mut","","Get mutable reference on type of feature.",62,null],[11,"start_mut","","Get mutable reference on start of feature.",62,null],[11,"end_mut","","Get mutable reference on end of feature.",62,null],[11,"score_mut","","Get mutable reference on score of feature.",62,null],[11,"strand_mut","","Get mutable reference on strand of feature.",62,null],[11,"attributes_mut","","Get mutable reference on attributes of feature.",62,null],[11,"eq","bio::io","",42,null],[11,"fmt","","",42,null],[0,"seq_analysis","bio","Sequence analysis algorithms.",null,null],[0,"orf","bio::seq_analysis","One-way orf finder algorithm.",null,null],[3,"Finder","bio::seq_analysis::orf","An implementation of a naive algorithm finder",null,null],[3,"Orf","","An orf representation with start and end position of said orf,\nas well as offset of the reading frame (1,2,3) and strand location ",null,null],[12,"start","","",63,null],[12,"end","","",63,null],[12,"offset","","",63,null],[3,"Matches","","Iterator over offset, start position, end position and sequence of matched orfs.",null,null],[11,"new","","Create a new instance of a finder for the given start and stop codons and a particular length",64,{"inputs":[{"name":"vec"},{"name":"vec"},{"name":"usize"}],"output":{"name":"self"}}],[11,"find_all","","Find all orfs in the given sequence",64,null],[11,"next","","",65,null],[0,"gc","bio::seq_analysis","GC counter over an `IntoTextIterator` object.\nComplexity: o(n)",null,null],[5,"gc_content","bio::seq_analysis::gc","gc content counter for every nucleotide",null,{"inputs":[{"name":"i"}],"output":{"name":"f32"}}],[5,"gc3_content","","gc content counter for the nucleotide in 3rd position",null,{"inputs":[{"name":"i"}],"output":{"name":"f32"}}],[0,"stats","bio","Mathematical and statistical tools.",null,null],[0,"combinatorics","bio::stats","Combinations with and without replacement.",null,null],[5,"scaled_combinations","bio::stats::combinatorics","Calculate the number of combinations when choosing\nk elements from n elements without replacement, multiplied by a scaling factor.",null,{"inputs":[{"name":"u64"},{"name":"u64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"combinations","","Calculate the number of combinations when choosing\nk elements from n elements without replacement.\nThis is also known as n over k, or the binomial coefficient.",null,{"inputs":[{"name":"u64"},{"name":"u64"}],"output":{"name":"f64"}}],[5,"combinations_with_repl","","Calculate the number of combinations when choosing\nk elements from n elements with replacement.",null,{"inputs":[{"name":"u64"},{"name":"u64"}],"output":{"name":"f64"}}],[0,"probs","bio::stats","Handling log-probabilities.",null,null],[3,"Prob","bio::stats::probs","A newtype for probabilities.",null,null],[12,"0","","",66,null],[3,"LogProb","","A newtype for log-scale probabilities.",null,null],[12,"0","","",67,null],[3,"PHREDProb","","A newtype for PHRED-scale probabilities.",null,null],[12,"0","","",68,null],[4,"ProbError","","",null,null],[13,"InvalidProb","","",69,null],[0,"cdf","","Support for discrete probability distributions in terms of cumulative distribution\nfunctions (CDF).",null,null],[3,"Entry","bio::stats::probs::cdf","",null,null],[12,"value","","",70,null],[12,"prob","","",70,null],[3,"CDF","","Implementation of a cumulative distribution function.",null,null],[6,"CDFPMFIter","","",null,null],[11,"clone","","",70,null],[11,"fmt","","",70,null],[11,"new","","",70,{"inputs":[{"name":"t"},{"name":"logprob"}],"output":{"name":"self"}}],[11,"clone","","",71,null],[11,"fmt","","",71,null],[11,"from_pmf","","Create CDF from given probability mass function (PMF). The PMF may contain duplicate values\nthe probabilities of which are summed during generation of the CDF.",71,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"from_cdf","","Create CDF from iterator. This can be used to replace the values of a CDF.",71,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"reduce","","Reduce CDF by omitting values with zero probability.",71,null],[11,"sample","","Downsample CDF to n entries. Panics if n &lt;= 1 and returns identity if n is greater\nthan the number of entries.",71,null],[11,"iter","","Provide iterator.",71,null],[11,"iter_pmf","","Iterator over corresponding PMF.",71,null],[11,"get","","Get cumulative probability for a given value. If the value is not present,\nreturn the probability of the previous value. Complexity O(log n).",71,null],[11,"get_pmf","","Get probability (i.e. probability mass) for a given value. Complexity O(log n).",71,null],[11,"total_prob","","Return total probability.",71,null],[11,"map","","Return maximum a posteriori probability estimate (MAP).",71,null],[11,"credible_interval","","Return w%-credible interval. The width w is a float between 0 and 1. Panics otherwise.\nE.g. provide `width=0.95` for the 95% credible interval.",71,null],[11,"len","","Number of entries in the CDF.",71,null],[11,"expected_value","","Calculate expected value.",71,null],[11,"variance","","Calculate variance.",71,null],[11,"standard_deviation","","Calculate standard deviation.",71,null],[6,"ScanIter","bio::stats::probs","Iterator returned by scans over logprobs.",null,null],[11,"encode","","",66,null],[11,"decode","","",66,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"default","","",66,{"inputs":[],"output":{"name":"prob"}}],[11,"fmt","","",66,null],[11,"clone","","",66,null],[11,"partial_cmp","","",66,null],[11,"lt","","",66,null],[11,"le","","",66,null],[11,"gt","","",66,null],[11,"ge","","",66,null],[11,"eq","","",66,null],[11,"ne","","",66,null],[11,"from","","",66,{"inputs":[{"name":"f64"}],"output":{"name":"self"}}],[11,"deref","","",66,null],[11,"add","","",66,null],[11,"add","","",66,null],[11,"sub","","",66,null],[11,"sub","","",66,null],[11,"mul","","",66,null],[11,"mul","","",66,null],[11,"div","","",66,null],[11,"div","","",66,null],[11,"checked","","",66,{"inputs":[{"name":"f64"}],"output":{"name":"result"}}],[11,"encode","","",67,null],[11,"decode","","",67,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"fmt","","",67,null],[11,"clone","","",67,null],[11,"partial_cmp","","",67,null],[11,"lt","","",67,null],[11,"le","","",67,null],[11,"gt","","",67,null],[11,"ge","","",67,null],[11,"eq","","",67,null],[11,"ne","","",67,null],[11,"from","","",67,{"inputs":[{"name":"f64"}],"output":{"name":"self"}}],[11,"deref","","",67,null],[11,"add","","",67,null],[11,"add","","",67,null],[11,"sub","","",67,null],[11,"sub","","",67,null],[11,"encode","","",68,null],[11,"decode","","",68,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"fmt","","",68,null],[11,"clone","","",68,null],[11,"partial_cmp","","",68,null],[11,"lt","","",68,null],[11,"le","","",68,null],[11,"gt","","",68,null],[11,"ge","","",68,null],[11,"eq","","",68,null],[11,"ne","","",68,null],[11,"from","","",68,{"inputs":[{"name":"f64"}],"output":{"name":"self"}}],[11,"deref","","",68,null],[11,"add","","",68,null],[11,"add","","",68,null],[11,"sub","","",68,null],[11,"sub","","",68,null],[11,"ln_zero","","Log-space representation of Pr=0",67,{"inputs":[],"output":{"name":"logprob"}}],[11,"ln_one","","Log-space representation of Pr=1",67,{"inputs":[],"output":{"name":"logprob"}}],[11,"ln_one_minus_exp","","Numerically stable calculation of 1 - p in log-space.",67,null],[11,"ln_sum_exp","","Numerically stable sum of probabilities in log-space.",67,null],[11,"ln_add_exp","","Numerically stable addition probabilities in log-space.",67,null],[11,"ln_sub_exp","","Numerically stable subtraction of probabilities in log-space.",67,null],[11,"ln_cumsum_exp","","Calculate the cumulative sum of the given probabilities in a numerically stable way (Durbin 1998).",67,{"inputs":[{"name":"i"}],"output":{"name":"scaniter"}}],[11,"ln_trapezoidal_integrate_exp","","Integrate numerically stable over given log-space density in the interval [a, b]. Uses the trapezoidal rule with n grid points.",67,{"inputs":[{"name":"d"},{"name":"t"},{"name":"t"},{"name":"usize"}],"output":{"name":"logprob"}}],[11,"ln_simpsons_integrate_exp","","Integrate numerically stable over given log-space density in the interval [a, b]. Uses Simpson&#39;s rule with n (odd) grid points.",67,{"inputs":[{"name":"d"},{"name":"t"},{"name":"t"},{"name":"usize"}],"output":{"name":"logprob"}}],[11,"from","","",66,{"inputs":[{"name":"logprob"}],"output":{"name":"prob"}}],[11,"from","","",66,{"inputs":[{"name":"phredprob"}],"output":{"name":"prob"}}],[11,"from","","",67,{"inputs":[{"name":"prob"}],"output":{"name":"logprob"}}],[11,"from","","",67,{"inputs":[{"name":"phredprob"}],"output":{"name":"logprob"}}],[11,"from","","",68,{"inputs":[{"name":"prob"}],"output":{"name":"phredprob"}}],[11,"from","","",68,{"inputs":[{"name":"logprob"}],"output":{"name":"phredprob"}}],[11,"default","","",67,{"inputs":[],"output":{"name":"logprob"}}],[11,"default","","",68,{"inputs":[],"output":{"name":"phredprob"}}],[11,"fmt","","",69,null],[11,"fmt","","",69,null],[11,"description","","",69,null],[11,"cause","","",69,null],[0,"bayesian","bio::stats","Utilities for Bayesian statistics.",null,null],[5,"expected_fdr","bio::stats::bayesian","For each of the hypothesis tests given as posterior error probabilities\n(PEPs, i.e. the posterior probability of the null hypothesis), estimate the FDR\nfor the case that all null hypotheses with at most this PEP are rejected.\nFDR is calculated as presented by Müller, Parmigiani, and Rice,\n&quot;FDR and Bayesian Multiple Comparisons Rules&quot; (July 2006).\nJohns Hopkin&#39;s University, Dept. of Biostatistics Working Papers. Working Paper 115.",null,null],[0,"scores","bio","",null,null],[0,"blosum62","bio::scores","",null,null],[5,"blosum62","bio::scores::blosum62","",null,{"inputs":[{"name":"u8"},{"name":"u8"}],"output":{"name":"i32"}}],[0,"pam40","bio::scores","",null,null],[5,"pam40","bio::scores::pam40","",null,{"inputs":[{"name":"u8"},{"name":"u8"}],"output":{"name":"i32"}}],[0,"pam120","bio::scores","",null,null],[5,"pam120","bio::scores::pam120","",null,{"inputs":[{"name":"u8"},{"name":"u8"}],"output":{"name":"i32"}}],[0,"pam200","bio::scores","",null,null],[5,"pam200","bio::scores::pam200","",null,{"inputs":[{"name":"u8"},{"name":"u8"}],"output":{"name":"i32"}}],[0,"pam250","bio::scores","",null,null],[5,"pam250","bio::scores::pam250","",null,{"inputs":[{"name":"u8"},{"name":"u8"}],"output":{"name":"i32"}}]],"paths":[[3,"NonNaNFloat"],[3,"Alphabet"],[3,"RankTransform"],[3,"QGrams"],[3,"ShiftAnd"],[3,"Matches"],[3,"KMP"],[3,"Matches"],[3,"BOM"],[3,"Matches"],[3,"Horspool"],[3,"Matches"],[3,"BNDM"],[3,"Matches"],[3,"Ukkonen"],[3,"Matches"],[3,"Myers"],[3,"Matches"],[3,"RankSelect"],[8,"SuffixArray"],[6,"RawSuffixArray"],[3,"Occ"],[3,"BitEnc"],[3,"BitEncIter"],[3,"SmallInts"],[3,"Iter"],[3,"Interval"],[8,"FMIndexable"],[3,"FMIndex"],[3,"BiInterval"],[3,"FMDIndex"],[3,"Interval"],[3,"Match"],[3,"ExactMatch"],[3,"QGramIndex"],[3,"IntervalTree"],[3,"Entry"],[3,"IntervalTreeIterator"],[3,"Node"],[3,"Alignment"],[4,"AlignmentOperation"],[3,"Aligner"],[4,"Strand"],[3,"Reader"],[3,"Record"],[3,"Records"],[3,"Writer"],[3,"IndexedReader"],[3,"Sequence"],[3,"Reader"],[3,"Index"],[3,"Writer"],[3,"Record"],[3,"Records"],[3,"Reader"],[3,"Records"],[3,"Writer"],[3,"Record"],[4,"GffType"],[3,"Reader"],[3,"Records"],[3,"Writer"],[3,"Record"],[3,"Orf"],[3,"Finder"],[3,"Matches"],[3,"Prob"],[3,"LogProb"],[3,"PHREDProb"],[4,"ProbError"],[3,"Entry"],[3,"CDF"]]};
searchIndex["nalgebra"] = {"doc":"# nalgebra","items":[[3,"Identity","nalgebra","Special identity matrix. All its operation are no-ops.",null,null],[3,"DMat","","Matrix with dimensions unknown at compile-time.",null,null],[3,"DVec","","Heap allocated, dynamically sized vector.",null,null],[12,"at","","Components of the vector. Contains as much elements as the vector dimension.",0,null],[3,"DVec1","","Stack-allocated, dynamically sized vector with a maximum size of 1.",null,null],[3,"DVec2","","Stack-allocated, dynamically sized vector with a maximum size of 2.",null,null],[3,"DVec3","","Stack-allocated, dynamically sized vector with a maximum size of 3.",null,null],[3,"DVec4","","Stack-allocated, dynamically sized vector with a maximum size of 4.",null,null],[3,"DVec5","","Stack-allocated, dynamically sized vector with a maximum size of 5.",null,null],[3,"DVec6","","Stack-allocated, dynamically sized vector with a maximum size of 6.",null,null],[3,"Iso2","","Two dimensional isometry.",null,null],[12,"rotation","","The rotation applicable by this isometry.",1,null],[12,"translation","","The translation applicable by this isometry.",1,null],[3,"Iso3","","Three dimensional isometry.",null,null],[12,"rotation","","The rotation applicable by this isometry.",2,null],[12,"translation","","The translation applicable by this isometry.",2,null],[3,"Iso4","","Four dimensional isometry.",null,null],[12,"rotation","","The rotation applicable by this isometry.",3,null],[12,"translation","","The translation applicable by this isometry.",3,null],[3,"Mat1","","Square matrix of dimension 1.",null,null],[12,"m11","","",4,null],[3,"Mat2","","Square matrix of dimension 2.",null,null],[12,"m11","","",5,null],[12,"m21","","",5,null],[12,"m12","","",5,null],[12,"m22","","",5,null],[3,"Mat3","","Square matrix of dimension 3.",null,null],[12,"m11","","",6,null],[12,"m21","","",6,null],[12,"m31","","",6,null],[12,"m12","","",6,null],[12,"m22","","",6,null],[12,"m32","","",6,null],[12,"m13","","",6,null],[12,"m23","","",6,null],[12,"m33","","",6,null],[3,"Mat4","","Square matrix of dimension 4.",null,null],[12,"m11","","",7,null],[12,"m21","","",7,null],[12,"m31","","",7,null],[12,"m41","","",7,null],[12,"m12","","",7,null],[12,"m22","","",7,null],[12,"m32","","",7,null],[12,"m42","","",7,null],[12,"m13","","",7,null],[12,"m23","","",7,null],[12,"m33","","",7,null],[12,"m43","","",7,null],[12,"m14","","",7,null],[12,"m24","","",7,null],[12,"m34","","",7,null],[12,"m44","","",7,null],[3,"Mat5","","Square matrix of dimension 5.",null,null],[12,"m11","","",8,null],[12,"m21","","",8,null],[12,"m31","","",8,null],[12,"m41","","",8,null],[12,"m51","","",8,null],[12,"m12","","",8,null],[12,"m22","","",8,null],[12,"m32","","",8,null],[12,"m42","","",8,null],[12,"m52","","",8,null],[12,"m13","","",8,null],[12,"m23","","",8,null],[12,"m33","","",8,null],[12,"m43","","",8,null],[12,"m53","","",8,null],[12,"m14","","",8,null],[12,"m24","","",8,null],[12,"m34","","",8,null],[12,"m44","","",8,null],[12,"m54","","",8,null],[12,"m15","","",8,null],[12,"m25","","",8,null],[12,"m35","","",8,null],[12,"m45","","",8,null],[12,"m55","","",8,null],[3,"Mat6","","Square matrix of dimension 6.",null,null],[12,"m11","","",9,null],[12,"m21","","",9,null],[12,"m31","","",9,null],[12,"m41","","",9,null],[12,"m51","","",9,null],[12,"m61","","",9,null],[12,"m12","","",9,null],[12,"m22","","",9,null],[12,"m32","","",9,null],[12,"m42","","",9,null],[12,"m52","","",9,null],[12,"m62","","",9,null],[12,"m13","","",9,null],[12,"m23","","",9,null],[12,"m33","","",9,null],[12,"m43","","",9,null],[12,"m53","","",9,null],[12,"m63","","",9,null],[12,"m14","","",9,null],[12,"m24","","",9,null],[12,"m34","","",9,null],[12,"m44","","",9,null],[12,"m54","","",9,null],[12,"m64","","",9,null],[12,"m15","","",9,null],[12,"m25","","",9,null],[12,"m35","","",9,null],[12,"m45","","",9,null],[12,"m55","","",9,null],[12,"m65","","",9,null],[12,"m16","","",9,null],[12,"m26","","",9,null],[12,"m36","","",9,null],[12,"m46","","",9,null],[12,"m56","","",9,null],[12,"m66","","",9,null],[3,"Rot2","","Two dimensional rotation matrix.",null,null],[3,"Rot3","","Three dimensional rotation matrix.",null,null],[3,"Rot4","","Four dimensional rotation matrix.",null,null],[3,"Vec0","","Vector of dimension 0.",null,null],[12,"0","","",10,null],[3,"Vec1","","Vector of dimension 1.",null,null],[12,"x","","First component of the vector.",11,null],[3,"Vec2","","Vector of dimension 2.",null,null],[12,"x","","First component of the vector.",12,null],[12,"y","","Second component of the vector.",12,null],[3,"Vec3","","Vector of dimension 3.",null,null],[12,"x","","First component of the vector.",13,null],[12,"y","","Second component of the vector.",13,null],[12,"z","","Third component of the vector.",13,null],[3,"Vec4","","Vector of dimension 4.",null,null],[12,"x","","First component of the vector.",14,null],[12,"y","","Second component of the vector.",14,null],[12,"z","","Third component of the vector.",14,null],[12,"w","","Fourth component of the vector.",14,null],[3,"Vec5","","Vector of dimension 5.",null,null],[12,"x","","First component of the vector.",15,null],[12,"y","","Second component of the vector.",15,null],[12,"z","","Third component of the vector.",15,null],[12,"w","","Fourth component of the vector.",15,null],[12,"a","","Fifth of the vector.",15,null],[3,"Vec6","","Vector of dimension 6.",null,null],[12,"x","","First component of the vector.",16,null],[12,"y","","Second component of the vector.",16,null],[12,"z","","Third component of the vector.",16,null],[12,"w","","Fourth component of the vector.",16,null],[12,"a","","Fifth of the vector.",16,null],[12,"b","","Sixth component of the vector.",16,null],[3,"Pnt0","","Point of dimension 0.",null,null],[12,"0","","",17,null],[3,"Pnt1","","Point of dimension 1.",null,null],[12,"x","","First component of the point.",18,null],[3,"Pnt2","","Point of dimension 2.",null,null],[12,"x","","First component of the point.",19,null],[12,"y","","Second component of the point.",19,null],[3,"Pnt3","","Point of dimension 3.",null,null],[12,"x","","First component of the point.",20,null],[12,"y","","Second component of the point.",20,null],[12,"z","","Third component of the point.",20,null],[3,"Pnt4","","Point of dimension 4.",null,null],[12,"x","","First component of the point.",21,null],[12,"y","","Second component of the point.",21,null],[12,"z","","Third component of the point.",21,null],[12,"w","","Fourth component of the point.",21,null],[3,"Pnt5","","Point of dimension 5.",null,null],[12,"x","","First component of the point.",22,null],[12,"y","","Second component of the point.",22,null],[12,"z","","Third component of the point.",22,null],[12,"w","","Fourth component of the point.",22,null],[12,"a","","Fifth of the point.",22,null],[3,"Pnt6","","Point of dimension 6.",null,null],[12,"x","","First component of the point.",23,null],[12,"y","","Second component of the point.",23,null],[12,"z","","Third component of the point.",23,null],[12,"w","","Fourth component of the point.",23,null],[12,"a","","Fifth of the point.",23,null],[12,"b","","Sixth component of the point.",23,null],[3,"Persp3","","A 3D perspective projection stored without any matrix.",null,null],[3,"PerspMat3","","A 3D perspective projection stored as a 4D matrix.",null,null],[3,"Ortho3","","A 3D orthographic projection stored without any matrix.",null,null],[3,"OrthoMat3","","A 3D orthographic projection stored as a 4D matrix.",null,null],[3,"Quat","","A quaternion.",null,null],[12,"w","","The scalar component of the quaternion.",24,null],[12,"i","","The first vector component of the quaternion.",24,null],[12,"j","","The second vector component of the quaternion.",24,null],[12,"k","","The third vector component of the quaternion.",24,null],[3,"UnitQuat","","A unit quaternion that can represent a 3D rotation.",null,null],[4,"POrdering","","Result of a partial ordering.",null,null],[13,"PartialLess","","Result of a strict comparison.",25,null],[13,"PartialEqual","","Equality relationship.",25,null],[13,"PartialGreater","","Result of a strict comparison.",25,null],[13,"NotComparable","","Result of a comparison between two objects that are not comparable.",25,null],[5,"qr","","QR decomposition using Householder reflections.",null,null],[5,"householder_matrix","","Get the householder matrix corresponding to a reflexion to the hyperplane\ndefined by `vec`. It can be a reflexion contained in a subspace.",null,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"v"}],"output":{"name":"m"}}],[5,"cholesky","","Cholesky decomposition G of a square symmetric positive definite matrix A, such that A = G * G^T",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"hessenberg","","Hessenberg\nReturns the matrix m in Hessenberg form and the corresponding similarity transformation",null,null],[5,"clamp","","Change the input value to ensure it is on the range `[min, max]`.",null,{"inputs":[{"name":"t"},{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"max","","Same as `cmp::max`.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"min","","Same as `cmp::min`.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"inf","","Returns the infimum of `a` and `b`.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"sup","","Returns the supremum of `a` and `b`.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"partial_cmp","","Compare `a` and `b` using a partial ordering relation.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"pordering"}}],[5,"partial_lt","","Returns `true` iff `a` and `b` are comparable and `a &lt; b`.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"partial_le","","Returns `true` iff `a` and `b` are comparable and `a &lt;= b`.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"partial_gt","","Returns `true` iff `a` and `b` are comparable and `a &gt; b`.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"partial_ge","","Returns `true` iff `a` and `b` are comparable and `a &gt;= b`.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"partial_min","","Return the minimum of `a` and `b` if they are comparable.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"option"}}],[5,"partial_max","","Return the maximum of `a` and `b` if they are comparable.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"option"}}],[5,"partial_clamp","","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to\n`min` or `max`.",null,{"inputs":[{"name":"t"},{"name":"t"},{"name":"t"}],"output":{"name":"option"}}],[5,"identity","","Create a special identity object.",null,{"inputs":[],"output":{"name":"identity"}}],[5,"zero","","Create a zero-valued value.",null,{"inputs":[],"output":{"name":"t"}}],[5,"is_zero","","Tests is a value is iqual to zero.",null,{"inputs":[{"name":"t"}],"output":{"name":"bool"}}],[5,"one","","Create a one-valued value.",null,{"inputs":[],"output":{"name":"t"}}],[5,"orig","","Returns the trivial origin of an affine space.",null,{"inputs":[],"output":{"name":"p"}}],[5,"center","","Returns the center of two points.",null,{"inputs":[{"name":"p"},{"name":"p"}],"output":{"name":"p"}}],[5,"dist","","Returns the distance between two points.",null,{"inputs":[{"name":"p"},{"name":"p"}],"output":{"name":"n"}}],[5,"sqdist","","Returns the squared distance between two points.",null,{"inputs":[{"name":"p"},{"name":"p"}],"output":{"name":"n"}}],[5,"translation","","Gets the translation applicable by `m`.",null,{"inputs":[{"name":"m"}],"output":{"name":"v"}}],[5,"inv_translation","","Gets the inverse translation applicable by `m`.",null,{"inputs":[{"name":"m"}],"output":{"name":"v"}}],[5,"append_translation","","Applies the translation `v` to a copy of `m`.",null,{"inputs":[{"name":"m"},{"name":"v"}],"output":{"name":"m"}}],[5,"translate","","Applies a translation to a point.",null,{"inputs":[{"name":"m"},{"name":"p"}],"output":{"name":"p"}}],[5,"inv_translate","","Applies an inverse translation to a point.",null,{"inputs":[{"name":"m"},{"name":"p"}],"output":{"name":"p"}}],[5,"rotation","","Gets the rotation applicable by `m`.",null,{"inputs":[{"name":"m"}],"output":{"name":"v"}}],[5,"inv_rotation","","Gets the inverse rotation applicable by `m`.",null,{"inputs":[{"name":"m"}],"output":{"name":"v"}}],[5,"append_rotation","","Applies the rotation `v` to a copy of `m`.",null,{"inputs":[{"name":"m"},{"name":"v"}],"output":{"name":"m"}}],[5,"prepend_rotation","","Pre-applies the rotation `v` to a copy of `m`.",null,{"inputs":[{"name":"m"},{"name":"v"}],"output":{"name":"m"}}],[5,"rotate","","Applies a rotation to a vector.",null,{"inputs":[{"name":"m"},{"name":"v"}],"output":{"name":"v"}}],[5,"inv_rotate","","Applies an inverse rotation to a vector.",null,{"inputs":[{"name":"m"},{"name":"v"}],"output":{"name":"v"}}],[5,"append_rotation_wrt_point","","Rotates a copy of `m` by `amount` using `center` as the pivot point.",null,{"inputs":[{"name":"m"},{"name":"av"},{"name":"lv"}],"output":{"name":"m"}}],[5,"append_rotation_wrt_center","","Rotates a copy of `m` by `amount` using `m.translation()` as the pivot point.",null,{"inputs":[{"name":"m"},{"name":"av"}],"output":{"name":"m"}}],[5,"angle_between","","Computes the angle of the rotation needed to transfom `a` to `b`.",null,{"inputs":[{"name":"v"},{"name":"v"}],"output":{"name":"angletype"}}],[5,"rotation_between","","Computes the rotation needed to transform `a` to `b`.",null,{"inputs":[{"name":"v"},{"name":"v"}],"output":{"name":"deltarotationtype"}}],[5,"to_rot_mat","","Builds a rotation matrix from `r`.",null,{"inputs":[{"name":"r"}],"output":{"name":"m"}}],[5,"absolute_rotate","","Applies a rotation using the absolute values of its components.",null,{"inputs":[{"name":"m"},{"name":"v"}],"output":{"name":"v"}}],[5,"transformation","","Gets the transformation applicable by `m`.",null,{"inputs":[{"name":"m"}],"output":{"name":"t"}}],[5,"inv_transformation","","Gets the inverse transformation applicable by `m`.",null,{"inputs":[{"name":"m"}],"output":{"name":"t"}}],[5,"append_transformation","","Gets a transformed copy of `m`.",null,{"inputs":[{"name":"m"},{"name":"t"}],"output":{"name":"m"}}],[5,"transform","","Applies a transformation to a vector.",null,{"inputs":[{"name":"m"},{"name":"v"}],"output":{"name":"v"}}],[5,"inv_transform","","Applies an inverse transformation to a vector.",null,{"inputs":[{"name":"m"},{"name":"v"}],"output":{"name":"v"}}],[5,"dot","","Computes the dot product of two vectors.",null,{"inputs":[{"name":"v"},{"name":"v"}],"output":{"name":"n"}}],[5,"norm","","Computes the L2 norm of a vector.",null,{"inputs":[{"name":"v"}],"output":{"name":"n"}}],[5,"sqnorm","","Computes the squared L2 norm of a vector.",null,{"inputs":[{"name":"v"}],"output":{"name":"n"}}],[5,"normalize","","Gets the normalized version of a vector.",null,{"inputs":[{"name":"v"}],"output":{"name":"v"}}],[5,"det","","Computes the determinant of a square matrix.",null,{"inputs":[{"name":"m"}],"output":{"name":"n"}}],[5,"cross","","Computes the cross product of two vectors.",null,{"inputs":[{"name":"lv"},{"name":"lv"}],"output":{"name":"crossproducttype"}}],[5,"cross_matrix","","Given a vector, computes the matrix which, when multiplied by another vector, computes a cross\nproduct.",null,{"inputs":[{"name":"v"}],"output":{"name":"m"}}],[5,"to_homogeneous","","Converts a matrix or vector to homogeneous coordinates.",null,{"inputs":[{"name":"m"}],"output":{"name":"res"}}],[5,"from_homogeneous","","Converts a matrix or vector from homogeneous coordinates.",null,{"inputs":[{"name":"m"}],"output":{"name":"res"}}],[5,"sample_sphere","","Samples the unit sphere living on the dimension as the samples types.",null,{"inputs":[{"name":"f"}],"output":null}],[5,"approx_eq","","Tests approximate equality.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"bool"}}],[5,"approx_eq_eps","","Tests approximate equality using a custom epsilon.",null,{"inputs":[{"name":"t"},{"name":"t"},{"name":"n"}],"output":{"name":"bool"}}],[5,"abs","","Computes a component-wise absolute value.",null,{"inputs":[{"name":"m"}],"output":{"name":"res"}}],[5,"inv","","Gets an inverted copy of a matrix.",null,{"inputs":[{"name":"m"}],"output":{"name":"option"}}],[5,"transpose","","Gets a transposed copy of a matrix.",null,{"inputs":[{"name":"m"}],"output":{"name":"m"}}],[5,"outer","","Computes the outer product of two vectors.",null,{"inputs":[{"name":"v"},{"name":"v"}],"output":{"name":"outerproducttype"}}],[5,"cov","","Computes the covariance of a set of observations.",null,{"inputs":[{"name":"m"}],"output":{"name":"res"}}],[5,"mean","","Computes the mean of a set of observations.",null,{"inputs":[{"name":"m"}],"output":{"name":"n"}}],[5,"eigen_qr","","Computes the eigenvalues and eigenvectors of a square matrix usin the QR algorithm.",null,null],[5,"new_identity","","Construct the identity matrix for a given dimension",null,{"inputs":[{"name":"usize"}],"output":{"name":"m"}}],[5,"repeat","","Create an object by repeating a value.",null,{"inputs":[{"name":"n"}],"output":{"name":"t"}}],[5,"canonical_basis","","Computes the canonical basis for a given dimension.",null,{"inputs":[{"name":"f"}],"output":null}],[5,"orthonormal_subspace_basis","","Computes the basis of the orthonormal subspace of a given vector.",null,{"inputs":[{"name":"v"},{"name":"f"}],"output":null}],[5,"canonical_basis_element","","Gets the (0-based) i-th element of the canonical basis of V.",null,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[5,"diag","","Gets the diagonal of a square matrix.",null,{"inputs":[{"name":"m"}],"output":{"name":"v"}}],[5,"dim","","Gets the dimension an object lives in.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"shape","","Gets the indexable range of an object.",null,{"inputs":[{"name":"v"}],"output":{"name":"i"}}],[5,"cast","","Converts an object from one type to another.",null,{"inputs":[{"name":"t"}],"output":{"name":"u"}}],[11,"clone","","",26,null],[11,"eq","","",26,null],[11,"ne","","",26,null],[11,"new_uninitialized","","Creates an uninitialized matrix.",26,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"dmat"}}],[11,"new_zeros","","Builds a matrix filled with zeros.",26,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"dmat"}}],[11,"is_zero","","Tests if all components of the matrix are zeroes.",26,null],[11,"reset","","",26,null],[11,"new_random","","Builds a matrix filled with random values.",26,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"dmat"}}],[11,"new_ones","","Builds a matrix filled with a given constant.",26,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"dmat"}}],[11,"from_elem","","Builds a matrix filled with a given constant.",26,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"n"}],"output":{"name":"dmat"}}],[11,"from_row_vec","","Builds a matrix filled with the components provided by a vector.\nThe vector contains the matrix data in row-major order.\nNote that `from_col_vec` is a lot faster than `from_row_vec` since a `DMat` stores its data\nin column-major order.",26,null],[11,"from_col_vec","","Builds a matrix filled with the components provided by a vector.\nThe vector contains the matrix data in column-major order.\nNote that `from_col_vec` is a lot faster than `from_row_vec` since a `DMat` stores its data\nin column-major order.",26,null],[11,"from_fn","","Builds a matrix filled with a given constant.",26,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"f"}],"output":{"name":"dmat"}}],[11,"nrows","","The number of row on the matrix.",26,null],[11,"ncols","","The number of columns on the matrix.",26,null],[11,"to_vec","","Transforms this matrix isizeo an array. This consumes the matrix and is O(1).\nThe returned vector contains the matrix data in column-major order.",26,null],[11,"as_vec","","Gets a reference to this matrix data.\nThe returned vector contains the matrix data in column-major order.",26,null],[11,"as_mut_vec","","Gets a mutable reference to this matrix data.\nThe returned vector contains the matrix data in column-major order.",26,null],[11,"new_identity","","Builds an identity matrix.",26,{"inputs":[{"name":"usize"}],"output":{"name":"dmat"}}],[11,"unsafe_set","","Just like `set` without bounds checking.",26,null],[11,"unsafe_at","","Just like `at` without bounds checking.",26,null],[11,"swap","","",26,null],[11,"shape","","",26,null],[11,"index","","",26,null],[11,"index_mut","","",26,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[11,"mul","","",26,null],[11,"mul","","",0,null],[11,"inv","","",26,null],[11,"inv_mut","","",26,null],[11,"transpose","","",26,null],[11,"transpose_mut","","",26,null],[11,"mean","","",26,null],[11,"cov","","",26,null],[11,"col_slice","","",26,null],[11,"row_slice","","",26,null],[11,"from_diag","","",26,{"inputs":[{"name":"dvec"}],"output":{"name":"dmat"}}],[11,"diag","","",26,null],[11,"approx_epsilon","","",26,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",26,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",26,null],[11,"approx_eq_ulps","","",26,null],[11,"fmt","","",26,null],[11,"mul","","",26,null],[11,"div","","",26,null],[11,"add","","",26,null],[11,"add","","",26,null],[11,"add","","",26,null],[11,"sub","","",26,null],[11,"sub","","",26,null],[11,"sub","","",26,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"new_uninitialized","","Creates an uninitialized vec.",0,{"inputs":[{"name":"usize"}],"output":{"name":"dvec"}}],[11,"from_elem","","Builds a vector filled with a constant.",0,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"dvec"}}],[11,"from_slice","","Builds a vector filled with the components provided by a vector.",0,null],[11,"from_fn","","Builds a vector filled with the result of a function.",0,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"dvec"}}],[11,"len","","",0,null],[11,"from_iter","","",0,{"inputs":[{"name":"i"}],"output":{"name":"dvec"}}],[11,"new_zeros","","Builds a vector filled with zeros.",0,{"inputs":[{"name":"usize"}],"output":{"name":"dvec"}}],[11,"is_zero","","Tests if all components of the vector are zeroes.",0,null],[11,"as_slice","","Slices this vector.",0,null],[11,"as_mut_slice","","Mutably slices this vector.",0,null],[11,"shape","","",0,null],[11,"swap","","",0,null],[11,"unsafe_at","","",0,null],[11,"unsafe_set","","",0,null],[11,"index","","",0,null],[11,"index_mut","","",0,null],[11,"new_ones","","Builds a vector filled with ones.",0,{"inputs":[{"name":"usize"}],"output":{"name":"dvec"}}],[11,"new_random","","Builds a vector filled with random values.",0,{"inputs":[{"name":"usize"}],"output":{"name":"dvec"}}],[11,"iter","","",0,null],[11,"iter_mut","","",0,null],[11,"axpy","","",0,null],[11,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",0,{"inputs":[{"name":"usize"}],"output":{"name":"vec"}}],[11,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",0,null],[11,"mul","","",0,null],[11,"div","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,null],[11,"neg","","",0,null],[11,"dot","","",0,null],[11,"sqnorm","","",0,null],[11,"normalize","","",0,null],[11,"normalize_mut","","",0,null],[11,"approx_epsilon","","",0,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",0,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",0,null],[11,"approx_eq_ulps","","",0,null],[11,"mul","","",0,null],[11,"div","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,null],[11,"len","","",27,null],[11,"eq","","",27,null],[11,"clone","","",27,null],[11,"new_zeros","","Builds a vector filled with zeros.",27,{"inputs":[{"name":"usize"}],"output":{"name":"dvec1"}}],[11,"is_zero","","Tests if all components of the vector are zeroes.",27,null],[11,"as_slice","","Slices this vector.",27,null],[11,"as_mut_slice","","Mutably slices this vector.",27,null],[11,"shape","","",27,null],[11,"swap","","",27,null],[11,"unsafe_at","","",27,null],[11,"unsafe_set","","",27,null],[11,"index","","",27,null],[11,"index_mut","","",27,null],[11,"new_ones","","Builds a vector filled with ones.",27,{"inputs":[{"name":"usize"}],"output":{"name":"dvec1"}}],[11,"new_random","","Builds a vector filled with random values.",27,{"inputs":[{"name":"usize"}],"output":{"name":"dvec1"}}],[11,"iter","","",27,null],[11,"iter_mut","","",27,null],[11,"axpy","","",27,null],[11,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",27,{"inputs":[{"name":"usize"}],"output":{"name":"vec"}}],[11,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",27,null],[11,"mul","","",27,null],[11,"div","","",27,null],[11,"add","","",27,null],[11,"sub","","",27,null],[11,"neg","","",27,null],[11,"dot","","",27,null],[11,"sqnorm","","",27,null],[11,"normalize","","",27,null],[11,"normalize_mut","","",27,null],[11,"approx_epsilon","","",27,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",27,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",27,null],[11,"approx_eq_ulps","","",27,null],[11,"mul","","",27,null],[11,"div","","",27,null],[11,"add","","",27,null],[11,"sub","","",27,null],[11,"from_elem","","Builds a vector filled with a constant.",27,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"dvec1"}}],[11,"from_slice","","Builds a vector filled with the components provided by a vector.",27,null],[11,"from_fn","","Builds a vector filled with the result of a function.",27,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"dvec1"}}],[11,"from_iter","","",27,{"inputs":[{"name":"i"}],"output":{"name":"dvec1"}}],[11,"len","","",28,null],[11,"eq","","",28,null],[11,"clone","","",28,null],[11,"new_zeros","","Builds a vector filled with zeros.",28,{"inputs":[{"name":"usize"}],"output":{"name":"dvec2"}}],[11,"is_zero","","Tests if all components of the vector are zeroes.",28,null],[11,"as_slice","","Slices this vector.",28,null],[11,"as_mut_slice","","Mutably slices this vector.",28,null],[11,"shape","","",28,null],[11,"swap","","",28,null],[11,"unsafe_at","","",28,null],[11,"unsafe_set","","",28,null],[11,"index","","",28,null],[11,"index_mut","","",28,null],[11,"new_ones","","Builds a vector filled with ones.",28,{"inputs":[{"name":"usize"}],"output":{"name":"dvec2"}}],[11,"new_random","","Builds a vector filled with random values.",28,{"inputs":[{"name":"usize"}],"output":{"name":"dvec2"}}],[11,"iter","","",28,null],[11,"iter_mut","","",28,null],[11,"axpy","","",28,null],[11,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",28,{"inputs":[{"name":"usize"}],"output":{"name":"vec"}}],[11,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",28,null],[11,"mul","","",28,null],[11,"div","","",28,null],[11,"add","","",28,null],[11,"sub","","",28,null],[11,"neg","","",28,null],[11,"dot","","",28,null],[11,"sqnorm","","",28,null],[11,"normalize","","",28,null],[11,"normalize_mut","","",28,null],[11,"approx_epsilon","","",28,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",28,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",28,null],[11,"approx_eq_ulps","","",28,null],[11,"mul","","",28,null],[11,"div","","",28,null],[11,"add","","",28,null],[11,"sub","","",28,null],[11,"from_elem","","Builds a vector filled with a constant.",28,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"dvec2"}}],[11,"from_slice","","Builds a vector filled with the components provided by a vector.",28,null],[11,"from_fn","","Builds a vector filled with the result of a function.",28,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"dvec2"}}],[11,"from_iter","","",28,{"inputs":[{"name":"i"}],"output":{"name":"dvec2"}}],[11,"len","","",29,null],[11,"eq","","",29,null],[11,"clone","","",29,null],[11,"new_zeros","","Builds a vector filled with zeros.",29,{"inputs":[{"name":"usize"}],"output":{"name":"dvec3"}}],[11,"is_zero","","Tests if all components of the vector are zeroes.",29,null],[11,"as_slice","","Slices this vector.",29,null],[11,"as_mut_slice","","Mutably slices this vector.",29,null],[11,"shape","","",29,null],[11,"swap","","",29,null],[11,"unsafe_at","","",29,null],[11,"unsafe_set","","",29,null],[11,"index","","",29,null],[11,"index_mut","","",29,null],[11,"new_ones","","Builds a vector filled with ones.",29,{"inputs":[{"name":"usize"}],"output":{"name":"dvec3"}}],[11,"new_random","","Builds a vector filled with random values.",29,{"inputs":[{"name":"usize"}],"output":{"name":"dvec3"}}],[11,"iter","","",29,null],[11,"iter_mut","","",29,null],[11,"axpy","","",29,null],[11,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",29,{"inputs":[{"name":"usize"}],"output":{"name":"vec"}}],[11,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",29,null],[11,"mul","","",29,null],[11,"div","","",29,null],[11,"add","","",29,null],[11,"sub","","",29,null],[11,"neg","","",29,null],[11,"dot","","",29,null],[11,"sqnorm","","",29,null],[11,"normalize","","",29,null],[11,"normalize_mut","","",29,null],[11,"approx_epsilon","","",29,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",29,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",29,null],[11,"approx_eq_ulps","","",29,null],[11,"mul","","",29,null],[11,"div","","",29,null],[11,"add","","",29,null],[11,"sub","","",29,null],[11,"from_elem","","Builds a vector filled with a constant.",29,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"dvec3"}}],[11,"from_slice","","Builds a vector filled with the components provided by a vector.",29,null],[11,"from_fn","","Builds a vector filled with the result of a function.",29,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"dvec3"}}],[11,"from_iter","","",29,{"inputs":[{"name":"i"}],"output":{"name":"dvec3"}}],[11,"len","","",30,null],[11,"eq","","",30,null],[11,"clone","","",30,null],[11,"new_zeros","","Builds a vector filled with zeros.",30,{"inputs":[{"name":"usize"}],"output":{"name":"dvec4"}}],[11,"is_zero","","Tests if all components of the vector are zeroes.",30,null],[11,"as_slice","","Slices this vector.",30,null],[11,"as_mut_slice","","Mutably slices this vector.",30,null],[11,"shape","","",30,null],[11,"swap","","",30,null],[11,"unsafe_at","","",30,null],[11,"unsafe_set","","",30,null],[11,"index","","",30,null],[11,"index_mut","","",30,null],[11,"new_ones","","Builds a vector filled with ones.",30,{"inputs":[{"name":"usize"}],"output":{"name":"dvec4"}}],[11,"new_random","","Builds a vector filled with random values.",30,{"inputs":[{"name":"usize"}],"output":{"name":"dvec4"}}],[11,"iter","","",30,null],[11,"iter_mut","","",30,null],[11,"axpy","","",30,null],[11,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",30,{"inputs":[{"name":"usize"}],"output":{"name":"vec"}}],[11,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",30,null],[11,"mul","","",30,null],[11,"div","","",30,null],[11,"add","","",30,null],[11,"sub","","",30,null],[11,"neg","","",30,null],[11,"dot","","",30,null],[11,"sqnorm","","",30,null],[11,"normalize","","",30,null],[11,"normalize_mut","","",30,null],[11,"approx_epsilon","","",30,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",30,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",30,null],[11,"approx_eq_ulps","","",30,null],[11,"mul","","",30,null],[11,"div","","",30,null],[11,"add","","",30,null],[11,"sub","","",30,null],[11,"from_elem","","Builds a vector filled with a constant.",30,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"dvec4"}}],[11,"from_slice","","Builds a vector filled with the components provided by a vector.",30,null],[11,"from_fn","","Builds a vector filled with the result of a function.",30,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"dvec4"}}],[11,"from_iter","","",30,{"inputs":[{"name":"i"}],"output":{"name":"dvec4"}}],[11,"len","","",31,null],[11,"eq","","",31,null],[11,"clone","","",31,null],[11,"new_zeros","","Builds a vector filled with zeros.",31,{"inputs":[{"name":"usize"}],"output":{"name":"dvec5"}}],[11,"is_zero","","Tests if all components of the vector are zeroes.",31,null],[11,"as_slice","","Slices this vector.",31,null],[11,"as_mut_slice","","Mutably slices this vector.",31,null],[11,"shape","","",31,null],[11,"swap","","",31,null],[11,"unsafe_at","","",31,null],[11,"unsafe_set","","",31,null],[11,"index","","",31,null],[11,"index_mut","","",31,null],[11,"new_ones","","Builds a vector filled with ones.",31,{"inputs":[{"name":"usize"}],"output":{"name":"dvec5"}}],[11,"new_random","","Builds a vector filled with random values.",31,{"inputs":[{"name":"usize"}],"output":{"name":"dvec5"}}],[11,"iter","","",31,null],[11,"iter_mut","","",31,null],[11,"axpy","","",31,null],[11,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",31,{"inputs":[{"name":"usize"}],"output":{"name":"vec"}}],[11,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",31,null],[11,"mul","","",31,null],[11,"div","","",31,null],[11,"add","","",31,null],[11,"sub","","",31,null],[11,"neg","","",31,null],[11,"dot","","",31,null],[11,"sqnorm","","",31,null],[11,"normalize","","",31,null],[11,"normalize_mut","","",31,null],[11,"approx_epsilon","","",31,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",31,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",31,null],[11,"approx_eq_ulps","","",31,null],[11,"mul","","",31,null],[11,"div","","",31,null],[11,"add","","",31,null],[11,"sub","","",31,null],[11,"from_elem","","Builds a vector filled with a constant.",31,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"dvec5"}}],[11,"from_slice","","Builds a vector filled with the components provided by a vector.",31,null],[11,"from_fn","","Builds a vector filled with the result of a function.",31,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"dvec5"}}],[11,"from_iter","","",31,{"inputs":[{"name":"i"}],"output":{"name":"dvec5"}}],[11,"len","","",32,null],[11,"eq","","",32,null],[11,"clone","","",32,null],[11,"new_zeros","","Builds a vector filled with zeros.",32,{"inputs":[{"name":"usize"}],"output":{"name":"dvec6"}}],[11,"is_zero","","Tests if all components of the vector are zeroes.",32,null],[11,"as_slice","","Slices this vector.",32,null],[11,"as_mut_slice","","Mutably slices this vector.",32,null],[11,"shape","","",32,null],[11,"swap","","",32,null],[11,"unsafe_at","","",32,null],[11,"unsafe_set","","",32,null],[11,"index","","",32,null],[11,"index_mut","","",32,null],[11,"new_ones","","Builds a vector filled with ones.",32,{"inputs":[{"name":"usize"}],"output":{"name":"dvec6"}}],[11,"new_random","","Builds a vector filled with random values.",32,{"inputs":[{"name":"usize"}],"output":{"name":"dvec6"}}],[11,"iter","","",32,null],[11,"iter_mut","","",32,null],[11,"axpy","","",32,null],[11,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",32,{"inputs":[{"name":"usize"}],"output":{"name":"vec"}}],[11,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",32,null],[11,"mul","","",32,null],[11,"div","","",32,null],[11,"add","","",32,null],[11,"sub","","",32,null],[11,"neg","","",32,null],[11,"dot","","",32,null],[11,"sqnorm","","",32,null],[11,"normalize","","",32,null],[11,"normalize_mut","","",32,null],[11,"approx_epsilon","","",32,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",32,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",32,null],[11,"approx_eq_ulps","","",32,null],[11,"mul","","",32,null],[11,"div","","",32,null],[11,"add","","",32,null],[11,"sub","","",32,null],[11,"from_elem","","Builds a vector filled with a constant.",32,{"inputs":[{"name":"usize"},{"name":"n"}],"output":{"name":"dvec6"}}],[11,"from_slice","","Builds a vector filled with the components provided by a vector.",32,null],[11,"from_fn","","Builds a vector filled with the result of a function.",32,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"dvec6"}}],[11,"from_iter","","",32,{"inputs":[{"name":"i"}],"output":{"name":"dvec6"}}],[11,"fmt","","",10,null],[11,"clone","","",10,null],[11,"eq","","",10,null],[11,"ne","","",10,null],[11,"new","","Creates a new vector.",10,{"inputs":[],"output":{"name":"vec0"}}],[11,"repeat","","",10,{"inputs":[{"name":"n"}],"output":{"name":"vec0"}}],[11,"fmt","","",11,null],[11,"hash","","",11,null],[11,"clone","","",11,null],[11,"decode","","",11,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",11,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[11,"new","","Creates a new vector.",11,{"inputs":[{"name":"n"}],"output":{"name":"vec1"}}],[11,"inf","","",11,null],[11,"sup","","",11,null],[11,"partial_cmp","","",11,null],[11,"partial_lt","","",11,null],[11,"partial_le","","",11,null],[11,"partial_gt","","",11,null],[11,"partial_ge","","",11,null],[11,"x","","Create a unit vector with its `$compN` component equal to 1.0.",11,{"inputs":[],"output":{"name":"vec1"}}],[11,"from","","",11,{"inputs":[{"name":"vec1"}],"output":{"name":"vec1"}}],[11,"as_ref","","",11,null],[11,"as_mut","","",11,null],[11,"index","","",11,null],[11,"index_mut","","",11,null],[11,"shape","","",11,null],[11,"swap","","",11,null],[11,"unsafe_at","","",11,null],[11,"unsafe_set","","",11,null],[11,"at_fast","","Unsafe read access to a vector element by index.",11,null],[11,"set_fast","","Unsafe write access to a vector element by index.",11,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",11,{"inputs":[{"name":"n"}],"output":{"name":"vec1"}}],[11,"dim","","",11,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",11,null],[11,"add","","",11,null],[11,"sub","","",11,null],[11,"mul","","",11,null],[11,"div","","",11,null],[11,"add","","",11,null],[11,"sub","","",11,null],[11,"mul","","",11,null],[11,"div","","",11,null],[11,"neg","","",11,null],[11,"dot","","",11,null],[11,"translation","","",11,null],[11,"inv_translation","","",11,null],[11,"append_translation_mut","","",11,null],[11,"append_translation","","",11,null],[11,"prepend_translation_mut","","",11,null],[11,"prepend_translation","","",11,null],[11,"set_translation","","",11,null],[11,"sqnorm","","",11,null],[11,"normalize","","",11,null],[11,"normalize_mut","","",11,null],[11,"approx_epsilon","","",11,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",11,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",11,null],[11,"approx_eq_eps","","",11,null],[11,"approx_eq_ulps","","",11,null],[11,"one","","",11,{"inputs":[],"output":{"name":"vec1"}}],[11,"zero","","",11,{"inputs":[],"output":{"name":"vec1"}}],[11,"is_zero","","",11,null],[11,"from_iter","","",11,{"inputs":[{"name":"i"}],"output":{"name":"vec1"}}],[11,"max_value","","",11,{"inputs":[],"output":{"name":"vec1"}}],[11,"min_value","","",11,{"inputs":[],"output":{"name":"vec1"}}],[11,"axpy","","",11,null],[11,"iter","","",11,null],[11,"iter_mut","","",11,null],[11,"to_homogeneous","","",11,null],[11,"from","","",11,{"inputs":[{"name":"vec2"}],"output":{"name":"vec1"}}],[11,"translate","","",11,null],[11,"inv_translate","","",11,null],[11,"rotate","","",11,null],[11,"inv_rotate","","",11,null],[11,"rotate","","",18,null],[11,"inv_rotate","","",18,null],[11,"transform","","",11,null],[11,"inv_transform","","",11,null],[11,"to_pnt","","",11,null],[11,"as_pnt","","",11,null],[11,"abs","","",11,{"inputs":[{"name":"vec1"}],"output":{"name":"vec1"}}],[11,"rand","","",11,{"inputs":[{"name":"r"}],"output":{"name":"vec1"}}],[11,"fmt","","",12,null],[11,"hash","","",12,null],[11,"clone","","",12,null],[11,"decode","","",12,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",12,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"new","","Creates a new vector.",12,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"vec2"}}],[11,"inf","","",12,null],[11,"sup","","",12,null],[11,"partial_cmp","","",12,null],[11,"partial_lt","","",12,null],[11,"partial_le","","",12,null],[11,"partial_gt","","",12,null],[11,"partial_ge","","",12,null],[11,"x","","Create a unit vector with its `$compN` component equal to 1.0.",12,{"inputs":[],"output":{"name":"vec2"}}],[11,"y","","Create a unit vector with its `$compN` component equal to 1.0.",12,{"inputs":[],"output":{"name":"vec2"}}],[11,"from","","",12,{"inputs":[{"name":"vec2"}],"output":{"name":"vec2"}}],[11,"as_ref","","",12,null],[11,"as_mut","","",12,null],[11,"index","","",12,null],[11,"index_mut","","",12,null],[11,"shape","","",12,null],[11,"swap","","",12,null],[11,"unsafe_at","","",12,null],[11,"unsafe_set","","",12,null],[11,"at_fast","","Unsafe read access to a vector element by index.",12,null],[11,"set_fast","","Unsafe write access to a vector element by index.",12,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",12,{"inputs":[{"name":"n"}],"output":{"name":"vec2"}}],[11,"dim","","",12,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",12,null],[11,"add","","",12,null],[11,"sub","","",12,null],[11,"mul","","",12,null],[11,"div","","",12,null],[11,"add","","",12,null],[11,"sub","","",12,null],[11,"mul","","",12,null],[11,"div","","",12,null],[11,"neg","","",12,null],[11,"dot","","",12,null],[11,"translation","","",12,null],[11,"inv_translation","","",12,null],[11,"append_translation_mut","","",12,null],[11,"append_translation","","",12,null],[11,"prepend_translation_mut","","",12,null],[11,"prepend_translation","","",12,null],[11,"set_translation","","",12,null],[11,"sqnorm","","",12,null],[11,"normalize","","",12,null],[11,"normalize_mut","","",12,null],[11,"approx_epsilon","","",12,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",12,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",12,null],[11,"approx_eq_eps","","",12,null],[11,"approx_eq_ulps","","",12,null],[11,"one","","",12,{"inputs":[],"output":{"name":"vec2"}}],[11,"zero","","",12,{"inputs":[],"output":{"name":"vec2"}}],[11,"is_zero","","",12,null],[11,"from_iter","","",12,{"inputs":[{"name":"i"}],"output":{"name":"vec2"}}],[11,"max_value","","",12,{"inputs":[],"output":{"name":"vec2"}}],[11,"min_value","","",12,{"inputs":[],"output":{"name":"vec2"}}],[11,"axpy","","",12,null],[11,"iter","","",12,null],[11,"iter_mut","","",12,null],[11,"to_homogeneous","","",12,null],[11,"from","","",12,{"inputs":[{"name":"vec3"}],"output":{"name":"vec2"}}],[11,"translate","","",12,null],[11,"inv_translate","","",12,null],[11,"rotate","","",12,null],[11,"inv_rotate","","",12,null],[11,"rotate","","",19,null],[11,"inv_rotate","","",19,null],[11,"transform","","",12,null],[11,"inv_transform","","",12,null],[11,"to_pnt","","",12,null],[11,"as_pnt","","",12,null],[11,"abs","","",12,{"inputs":[{"name":"vec2"}],"output":{"name":"vec2"}}],[11,"rand","","",12,{"inputs":[{"name":"r"}],"output":{"name":"vec2"}}],[11,"fmt","","",13,null],[11,"hash","","",13,null],[11,"clone","","",13,null],[11,"decode","","",13,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",13,null],[11,"eq","","",13,null],[11,"ne","","",13,null],[11,"new","","Creates a new vector.",13,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"vec3"}}],[11,"inf","","",13,null],[11,"sup","","",13,null],[11,"partial_cmp","","",13,null],[11,"partial_lt","","",13,null],[11,"partial_le","","",13,null],[11,"partial_gt","","",13,null],[11,"partial_ge","","",13,null],[11,"x","","Create a unit vector with its `$compN` component equal to 1.0.",13,{"inputs":[],"output":{"name":"vec3"}}],[11,"y","","Create a unit vector with its `$compN` component equal to 1.0.",13,{"inputs":[],"output":{"name":"vec3"}}],[11,"z","","Create a unit vector with its `$compN` component equal to 1.0.",13,{"inputs":[],"output":{"name":"vec3"}}],[11,"from","","",13,{"inputs":[{"name":"vec3"}],"output":{"name":"vec3"}}],[11,"as_ref","","",13,null],[11,"as_mut","","",13,null],[11,"index","","",13,null],[11,"index_mut","","",13,null],[11,"shape","","",13,null],[11,"swap","","",13,null],[11,"unsafe_at","","",13,null],[11,"unsafe_set","","",13,null],[11,"at_fast","","Unsafe read access to a vector element by index.",13,null],[11,"set_fast","","Unsafe write access to a vector element by index.",13,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",13,{"inputs":[{"name":"n"}],"output":{"name":"vec3"}}],[11,"dim","","",13,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",13,null],[11,"add","","",13,null],[11,"sub","","",13,null],[11,"mul","","",13,null],[11,"div","","",13,null],[11,"add","","",13,null],[11,"sub","","",13,null],[11,"mul","","",13,null],[11,"div","","",13,null],[11,"neg","","",13,null],[11,"dot","","",13,null],[11,"translation","","",13,null],[11,"inv_translation","","",13,null],[11,"append_translation_mut","","",13,null],[11,"append_translation","","",13,null],[11,"prepend_translation_mut","","",13,null],[11,"prepend_translation","","",13,null],[11,"set_translation","","",13,null],[11,"sqnorm","","",13,null],[11,"normalize","","",13,null],[11,"normalize_mut","","",13,null],[11,"approx_epsilon","","",13,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",13,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",13,null],[11,"approx_eq_eps","","",13,null],[11,"approx_eq_ulps","","",13,null],[11,"one","","",13,{"inputs":[],"output":{"name":"vec3"}}],[11,"zero","","",13,{"inputs":[],"output":{"name":"vec3"}}],[11,"is_zero","","",13,null],[11,"from_iter","","",13,{"inputs":[{"name":"i"}],"output":{"name":"vec3"}}],[11,"max_value","","",13,{"inputs":[],"output":{"name":"vec3"}}],[11,"min_value","","",13,{"inputs":[],"output":{"name":"vec3"}}],[11,"axpy","","",13,null],[11,"iter","","",13,null],[11,"iter_mut","","",13,null],[11,"to_homogeneous","","",13,null],[11,"from","","",13,{"inputs":[{"name":"vec4"}],"output":{"name":"vec3"}}],[11,"translate","","",13,null],[11,"inv_translate","","",13,null],[11,"rotate","","",13,null],[11,"inv_rotate","","",13,null],[11,"rotate","","",20,null],[11,"inv_rotate","","",20,null],[11,"transform","","",13,null],[11,"inv_transform","","",13,null],[11,"to_pnt","","",13,null],[11,"as_pnt","","",13,null],[11,"abs","","",13,{"inputs":[{"name":"vec3"}],"output":{"name":"vec3"}}],[11,"rand","","",13,{"inputs":[{"name":"r"}],"output":{"name":"vec3"}}],[11,"fmt","","",14,null],[11,"hash","","",14,null],[11,"clone","","",14,null],[11,"decode","","",14,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",14,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"new","","Creates a new vector.",14,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"vec4"}}],[11,"inf","","",14,null],[11,"sup","","",14,null],[11,"partial_cmp","","",14,null],[11,"partial_lt","","",14,null],[11,"partial_le","","",14,null],[11,"partial_gt","","",14,null],[11,"partial_ge","","",14,null],[11,"x","","Create a unit vector with its `$compN` component equal to 1.0.",14,{"inputs":[],"output":{"name":"vec4"}}],[11,"y","","Create a unit vector with its `$compN` component equal to 1.0.",14,{"inputs":[],"output":{"name":"vec4"}}],[11,"z","","Create a unit vector with its `$compN` component equal to 1.0.",14,{"inputs":[],"output":{"name":"vec4"}}],[11,"w","","Create a unit vector with its `$compN` component equal to 1.0.",14,{"inputs":[],"output":{"name":"vec4"}}],[11,"from","","",14,{"inputs":[{"name":"vec4"}],"output":{"name":"vec4"}}],[11,"as_ref","","",14,null],[11,"as_mut","","",14,null],[11,"index","","",14,null],[11,"index_mut","","",14,null],[11,"shape","","",14,null],[11,"swap","","",14,null],[11,"unsafe_at","","",14,null],[11,"unsafe_set","","",14,null],[11,"at_fast","","Unsafe read access to a vector element by index.",14,null],[11,"set_fast","","Unsafe write access to a vector element by index.",14,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",14,{"inputs":[{"name":"n"}],"output":{"name":"vec4"}}],[11,"dim","","",14,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",14,null],[11,"canonical_basis","","",14,{"inputs":[{"name":"f"}],"output":null}],[11,"orthonormal_subspace_basis","","",14,{"inputs":[{"name":"vec4"},{"name":"f"}],"output":null}],[11,"canonical_basis_element","","",14,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"add","","",14,null],[11,"sub","","",14,null],[11,"mul","","",14,null],[11,"div","","",14,null],[11,"add","","",14,null],[11,"sub","","",14,null],[11,"mul","","",14,null],[11,"div","","",14,null],[11,"neg","","",14,null],[11,"dot","","",14,null],[11,"translation","","",14,null],[11,"inv_translation","","",14,null],[11,"append_translation_mut","","",14,null],[11,"append_translation","","",14,null],[11,"prepend_translation_mut","","",14,null],[11,"prepend_translation","","",14,null],[11,"set_translation","","",14,null],[11,"sqnorm","","",14,null],[11,"normalize","","",14,null],[11,"normalize_mut","","",14,null],[11,"approx_epsilon","","",14,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",14,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",14,null],[11,"approx_eq_eps","","",14,null],[11,"approx_eq_ulps","","",14,null],[11,"one","","",14,{"inputs":[],"output":{"name":"vec4"}}],[11,"zero","","",14,{"inputs":[],"output":{"name":"vec4"}}],[11,"is_zero","","",14,null],[11,"from_iter","","",14,{"inputs":[{"name":"i"}],"output":{"name":"vec4"}}],[11,"max_value","","",14,{"inputs":[],"output":{"name":"vec4"}}],[11,"min_value","","",14,{"inputs":[],"output":{"name":"vec4"}}],[11,"axpy","","",14,null],[11,"iter","","",14,null],[11,"iter_mut","","",14,null],[11,"to_homogeneous","","",14,null],[11,"from","","",14,{"inputs":[{"name":"vec5"}],"output":{"name":"vec4"}}],[11,"translate","","",14,null],[11,"inv_translate","","",14,null],[11,"rotate","","",14,null],[11,"inv_rotate","","",14,null],[11,"rotate","","",21,null],[11,"inv_rotate","","",21,null],[11,"transform","","",14,null],[11,"inv_transform","","",14,null],[11,"to_pnt","","",14,null],[11,"as_pnt","","",14,null],[11,"abs","","",14,{"inputs":[{"name":"vec4"}],"output":{"name":"vec4"}}],[11,"rand","","",14,{"inputs":[{"name":"r"}],"output":{"name":"vec4"}}],[11,"fmt","","",15,null],[11,"hash","","",15,null],[11,"clone","","",15,null],[11,"decode","","",15,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",15,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"new","","Creates a new vector.",15,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"vec5"}}],[11,"inf","","",15,null],[11,"sup","","",15,null],[11,"partial_cmp","","",15,null],[11,"partial_lt","","",15,null],[11,"partial_le","","",15,null],[11,"partial_gt","","",15,null],[11,"partial_ge","","",15,null],[11,"x","","Create a unit vector with its `$compN` component equal to 1.0.",15,{"inputs":[],"output":{"name":"vec5"}}],[11,"y","","Create a unit vector with its `$compN` component equal to 1.0.",15,{"inputs":[],"output":{"name":"vec5"}}],[11,"z","","Create a unit vector with its `$compN` component equal to 1.0.",15,{"inputs":[],"output":{"name":"vec5"}}],[11,"w","","Create a unit vector with its `$compN` component equal to 1.0.",15,{"inputs":[],"output":{"name":"vec5"}}],[11,"a","","Create a unit vector with its `$compN` component equal to 1.0.",15,{"inputs":[],"output":{"name":"vec5"}}],[11,"from","","",15,{"inputs":[{"name":"vec5"}],"output":{"name":"vec5"}}],[11,"as_ref","","",15,null],[11,"as_mut","","",15,null],[11,"index","","",15,null],[11,"index_mut","","",15,null],[11,"shape","","",15,null],[11,"swap","","",15,null],[11,"unsafe_at","","",15,null],[11,"unsafe_set","","",15,null],[11,"at_fast","","Unsafe read access to a vector element by index.",15,null],[11,"set_fast","","Unsafe write access to a vector element by index.",15,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",15,{"inputs":[{"name":"n"}],"output":{"name":"vec5"}}],[11,"dim","","",15,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",15,null],[11,"canonical_basis","","",15,{"inputs":[{"name":"f"}],"output":null}],[11,"orthonormal_subspace_basis","","",15,{"inputs":[{"name":"vec5"},{"name":"f"}],"output":null}],[11,"canonical_basis_element","","",15,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"add","","",15,null],[11,"sub","","",15,null],[11,"mul","","",15,null],[11,"div","","",15,null],[11,"add","","",15,null],[11,"sub","","",15,null],[11,"mul","","",15,null],[11,"div","","",15,null],[11,"neg","","",15,null],[11,"dot","","",15,null],[11,"translation","","",15,null],[11,"inv_translation","","",15,null],[11,"append_translation_mut","","",15,null],[11,"append_translation","","",15,null],[11,"prepend_translation_mut","","",15,null],[11,"prepend_translation","","",15,null],[11,"set_translation","","",15,null],[11,"sqnorm","","",15,null],[11,"normalize","","",15,null],[11,"normalize_mut","","",15,null],[11,"approx_epsilon","","",15,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",15,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",15,null],[11,"approx_eq_eps","","",15,null],[11,"approx_eq_ulps","","",15,null],[11,"one","","",15,{"inputs":[],"output":{"name":"vec5"}}],[11,"zero","","",15,{"inputs":[],"output":{"name":"vec5"}}],[11,"is_zero","","",15,null],[11,"from_iter","","",15,{"inputs":[{"name":"i"}],"output":{"name":"vec5"}}],[11,"max_value","","",15,{"inputs":[],"output":{"name":"vec5"}}],[11,"min_value","","",15,{"inputs":[],"output":{"name":"vec5"}}],[11,"axpy","","",15,null],[11,"iter","","",15,null],[11,"iter_mut","","",15,null],[11,"to_homogeneous","","",15,null],[11,"from","","",15,{"inputs":[{"name":"vec6"}],"output":{"name":"vec5"}}],[11,"translate","","",15,null],[11,"inv_translate","","",15,null],[11,"rotate","","",15,null],[11,"inv_rotate","","",15,null],[11,"rotate","","",22,null],[11,"inv_rotate","","",22,null],[11,"transform","","",15,null],[11,"inv_transform","","",15,null],[11,"to_pnt","","",15,null],[11,"as_pnt","","",15,null],[11,"abs","","",15,{"inputs":[{"name":"vec5"}],"output":{"name":"vec5"}}],[11,"rand","","",15,{"inputs":[{"name":"r"}],"output":{"name":"vec5"}}],[11,"fmt","","",16,null],[11,"hash","","",16,null],[11,"clone","","",16,null],[11,"decode","","",16,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",16,null],[11,"eq","","",16,null],[11,"ne","","",16,null],[11,"new","","Creates a new vector.",16,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"vec6"}}],[11,"inf","","",16,null],[11,"sup","","",16,null],[11,"partial_cmp","","",16,null],[11,"partial_lt","","",16,null],[11,"partial_le","","",16,null],[11,"partial_gt","","",16,null],[11,"partial_ge","","",16,null],[11,"x","","Create a unit vector with its `$compN` component equal to 1.0.",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"y","","Create a unit vector with its `$compN` component equal to 1.0.",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"z","","Create a unit vector with its `$compN` component equal to 1.0.",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"w","","Create a unit vector with its `$compN` component equal to 1.0.",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"a","","Create a unit vector with its `$compN` component equal to 1.0.",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"b","","Create a unit vector with its `$compN` component equal to 1.0.",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"from","","",16,{"inputs":[{"name":"vec6"}],"output":{"name":"vec6"}}],[11,"as_ref","","",16,null],[11,"as_mut","","",16,null],[11,"index","","",16,null],[11,"index_mut","","",16,null],[11,"shape","","",16,null],[11,"swap","","",16,null],[11,"unsafe_at","","",16,null],[11,"unsafe_set","","",16,null],[11,"at_fast","","Unsafe read access to a vector element by index.",16,null],[11,"set_fast","","Unsafe write access to a vector element by index.",16,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",16,{"inputs":[{"name":"n"}],"output":{"name":"vec6"}}],[11,"dim","","",16,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",16,null],[11,"canonical_basis","","",16,{"inputs":[{"name":"f"}],"output":null}],[11,"orthonormal_subspace_basis","","",16,{"inputs":[{"name":"vec6"},{"name":"f"}],"output":null}],[11,"canonical_basis_element","","",16,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"add","","",16,null],[11,"sub","","",16,null],[11,"mul","","",16,null],[11,"div","","",16,null],[11,"add","","",16,null],[11,"sub","","",16,null],[11,"mul","","",16,null],[11,"div","","",16,null],[11,"neg","","",16,null],[11,"dot","","",16,null],[11,"translation","","",16,null],[11,"inv_translation","","",16,null],[11,"append_translation_mut","","",16,null],[11,"append_translation","","",16,null],[11,"prepend_translation_mut","","",16,null],[11,"prepend_translation","","",16,null],[11,"set_translation","","",16,null],[11,"sqnorm","","",16,null],[11,"normalize","","",16,null],[11,"normalize_mut","","",16,null],[11,"approx_epsilon","","",16,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",16,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",16,null],[11,"approx_eq_eps","","",16,null],[11,"approx_eq_ulps","","",16,null],[11,"one","","",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"zero","","",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"is_zero","","",16,null],[11,"from_iter","","",16,{"inputs":[{"name":"i"}],"output":{"name":"vec6"}}],[11,"max_value","","",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"min_value","","",16,{"inputs":[],"output":{"name":"vec6"}}],[11,"axpy","","",16,null],[11,"iter","","",16,null],[11,"iter_mut","","",16,null],[11,"translate","","",16,null],[11,"inv_translate","","",16,null],[11,"rotate","","",16,null],[11,"inv_rotate","","",16,null],[11,"rotate","","",23,null],[11,"inv_rotate","","",23,null],[11,"transform","","",16,null],[11,"inv_transform","","",16,null],[11,"to_pnt","","",16,null],[11,"as_pnt","","",16,null],[11,"abs","","",16,{"inputs":[{"name":"vec6"}],"output":{"name":"vec6"}}],[11,"rand","","",16,{"inputs":[{"name":"r"}],"output":{"name":"vec6"}}],[11,"fmt","","",17,null],[11,"clone","","",17,null],[11,"eq","","",17,null],[11,"ne","","",17,null],[11,"new","","Creates a new point.",17,{"inputs":[],"output":{"name":"pnt0"}}],[11,"repeat","","",17,{"inputs":[{"name":"n"}],"output":{"name":"pnt0"}}],[11,"fmt","","",18,null],[11,"hash","","",18,null],[11,"clone","","",18,null],[11,"decode","","",18,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",18,null],[11,"eq","","",18,null],[11,"ne","","",18,null],[11,"new","","Creates a new vector.",18,{"inputs":[{"name":"n"}],"output":{"name":"pnt1"}}],[11,"orig","","",18,{"inputs":[],"output":{"name":"pnt1"}}],[11,"is_orig","","",18,null],[11,"inf","","",18,null],[11,"sup","","",18,null],[11,"partial_cmp","","",18,null],[11,"partial_lt","","",18,null],[11,"partial_le","","",18,null],[11,"partial_gt","","",18,null],[11,"partial_ge","","",18,null],[11,"mul","","",18,null],[11,"div","","",18,null],[11,"add","","",18,null],[11,"sub","","",18,null],[11,"from","","",18,{"inputs":[{"name":"pnt1"}],"output":{"name":"pnt1"}}],[11,"as_ref","","",18,null],[11,"as_mut","","",18,null],[11,"index","","",18,null],[11,"index_mut","","",18,null],[11,"shape","","",18,null],[11,"swap","","",18,null],[11,"unsafe_at","","",18,null],[11,"unsafe_set","","",18,null],[11,"at_fast","","Unsafe read access to a vector element by index.",18,null],[11,"set_fast","","Unsafe write access to a vector element by index.",18,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",18,{"inputs":[{"name":"n"}],"output":{"name":"pnt1"}}],[11,"dim","","",18,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",18,null],[11,"to_vec","","Converts this point to its associated vector.",18,null],[11,"as_vec","","Converts a reference to this point to a reference to its associated vector.",18,null],[11,"to_vec","","",18,null],[11,"as_vec","","",18,null],[11,"set_coords","","",18,null],[11,"sub","","",18,null],[11,"neg","","",18,null],[11,"add","","",18,null],[11,"sub","","",18,null],[11,"approx_epsilon","","",18,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",18,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",18,null],[11,"approx_eq_eps","","",18,null],[11,"approx_eq_ulps","","",18,null],[11,"from_iter","","",18,{"inputs":[{"name":"i"}],"output":{"name":"pnt1"}}],[11,"max_value","","",18,{"inputs":[],"output":{"name":"pnt1"}}],[11,"min_value","","",18,{"inputs":[],"output":{"name":"pnt1"}}],[11,"axpy","","",18,null],[11,"iter","","",18,null],[11,"iter_mut","","",18,null],[11,"to_homogeneous","","",18,null],[11,"from","","",18,{"inputs":[{"name":"pnt2"}],"output":{"name":"pnt1"}}],[11,"rand","","",18,{"inputs":[{"name":"r"}],"output":{"name":"pnt1"}}],[11,"fmt","","",19,null],[11,"hash","","",19,null],[11,"clone","","",19,null],[11,"decode","","",19,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",19,null],[11,"eq","","",19,null],[11,"ne","","",19,null],[11,"new","","Creates a new vector.",19,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"pnt2"}}],[11,"orig","","",19,{"inputs":[],"output":{"name":"pnt2"}}],[11,"is_orig","","",19,null],[11,"inf","","",19,null],[11,"sup","","",19,null],[11,"partial_cmp","","",19,null],[11,"partial_lt","","",19,null],[11,"partial_le","","",19,null],[11,"partial_gt","","",19,null],[11,"partial_ge","","",19,null],[11,"mul","","",19,null],[11,"div","","",19,null],[11,"add","","",19,null],[11,"sub","","",19,null],[11,"from","","",19,{"inputs":[{"name":"pnt2"}],"output":{"name":"pnt2"}}],[11,"as_ref","","",19,null],[11,"as_mut","","",19,null],[11,"index","","",19,null],[11,"index_mut","","",19,null],[11,"shape","","",19,null],[11,"swap","","",19,null],[11,"unsafe_at","","",19,null],[11,"unsafe_set","","",19,null],[11,"at_fast","","Unsafe read access to a vector element by index.",19,null],[11,"set_fast","","Unsafe write access to a vector element by index.",19,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",19,{"inputs":[{"name":"n"}],"output":{"name":"pnt2"}}],[11,"dim","","",19,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",19,null],[11,"to_vec","","Converts this point to its associated vector.",19,null],[11,"as_vec","","Converts a reference to this point to a reference to its associated vector.",19,null],[11,"to_vec","","",19,null],[11,"as_vec","","",19,null],[11,"set_coords","","",19,null],[11,"sub","","",19,null],[11,"neg","","",19,null],[11,"add","","",19,null],[11,"sub","","",19,null],[11,"approx_epsilon","","",19,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",19,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",19,null],[11,"approx_eq_eps","","",19,null],[11,"approx_eq_ulps","","",19,null],[11,"from_iter","","",19,{"inputs":[{"name":"i"}],"output":{"name":"pnt2"}}],[11,"max_value","","",19,{"inputs":[],"output":{"name":"pnt2"}}],[11,"min_value","","",19,{"inputs":[],"output":{"name":"pnt2"}}],[11,"axpy","","",19,null],[11,"iter","","",19,null],[11,"iter_mut","","",19,null],[11,"to_homogeneous","","",19,null],[11,"from","","",19,{"inputs":[{"name":"pnt3"}],"output":{"name":"pnt2"}}],[11,"rand","","",19,{"inputs":[{"name":"r"}],"output":{"name":"pnt2"}}],[11,"fmt","","",20,null],[11,"hash","","",20,null],[11,"clone","","",20,null],[11,"decode","","",20,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",20,null],[11,"eq","","",20,null],[11,"ne","","",20,null],[11,"new","","Creates a new vector.",20,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"pnt3"}}],[11,"orig","","",20,{"inputs":[],"output":{"name":"pnt3"}}],[11,"is_orig","","",20,null],[11,"inf","","",20,null],[11,"sup","","",20,null],[11,"partial_cmp","","",20,null],[11,"partial_lt","","",20,null],[11,"partial_le","","",20,null],[11,"partial_gt","","",20,null],[11,"partial_ge","","",20,null],[11,"mul","","",20,null],[11,"div","","",20,null],[11,"add","","",20,null],[11,"sub","","",20,null],[11,"from","","",20,{"inputs":[{"name":"pnt3"}],"output":{"name":"pnt3"}}],[11,"as_ref","","",20,null],[11,"as_mut","","",20,null],[11,"index","","",20,null],[11,"index_mut","","",20,null],[11,"shape","","",20,null],[11,"swap","","",20,null],[11,"unsafe_at","","",20,null],[11,"unsafe_set","","",20,null],[11,"at_fast","","Unsafe read access to a vector element by index.",20,null],[11,"set_fast","","Unsafe write access to a vector element by index.",20,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",20,{"inputs":[{"name":"n"}],"output":{"name":"pnt3"}}],[11,"dim","","",20,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",20,null],[11,"to_vec","","Converts this point to its associated vector.",20,null],[11,"as_vec","","Converts a reference to this point to a reference to its associated vector.",20,null],[11,"to_vec","","",20,null],[11,"as_vec","","",20,null],[11,"set_coords","","",20,null],[11,"sub","","",20,null],[11,"neg","","",20,null],[11,"add","","",20,null],[11,"sub","","",20,null],[11,"approx_epsilon","","",20,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",20,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",20,null],[11,"approx_eq_eps","","",20,null],[11,"approx_eq_ulps","","",20,null],[11,"from_iter","","",20,{"inputs":[{"name":"i"}],"output":{"name":"pnt3"}}],[11,"max_value","","",20,{"inputs":[],"output":{"name":"pnt3"}}],[11,"min_value","","",20,{"inputs":[],"output":{"name":"pnt3"}}],[11,"axpy","","",20,null],[11,"iter","","",20,null],[11,"iter_mut","","",20,null],[11,"to_homogeneous","","",20,null],[11,"from","","",20,{"inputs":[{"name":"pnt4"}],"output":{"name":"pnt3"}}],[11,"rand","","",20,{"inputs":[{"name":"r"}],"output":{"name":"pnt3"}}],[11,"fmt","","",21,null],[11,"hash","","",21,null],[11,"clone","","",21,null],[11,"decode","","",21,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",21,null],[11,"eq","","",21,null],[11,"ne","","",21,null],[11,"new","","Creates a new vector.",21,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"pnt4"}}],[11,"orig","","",21,{"inputs":[],"output":{"name":"pnt4"}}],[11,"is_orig","","",21,null],[11,"inf","","",21,null],[11,"sup","","",21,null],[11,"partial_cmp","","",21,null],[11,"partial_lt","","",21,null],[11,"partial_le","","",21,null],[11,"partial_gt","","",21,null],[11,"partial_ge","","",21,null],[11,"mul","","",21,null],[11,"div","","",21,null],[11,"add","","",21,null],[11,"sub","","",21,null],[11,"from","","",21,{"inputs":[{"name":"pnt4"}],"output":{"name":"pnt4"}}],[11,"as_ref","","",21,null],[11,"as_mut","","",21,null],[11,"index","","",21,null],[11,"index_mut","","",21,null],[11,"shape","","",21,null],[11,"swap","","",21,null],[11,"unsafe_at","","",21,null],[11,"unsafe_set","","",21,null],[11,"at_fast","","Unsafe read access to a vector element by index.",21,null],[11,"set_fast","","Unsafe write access to a vector element by index.",21,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",21,{"inputs":[{"name":"n"}],"output":{"name":"pnt4"}}],[11,"dim","","",21,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",21,null],[11,"to_vec","","Converts this point to its associated vector.",21,null],[11,"as_vec","","Converts a reference to this point to a reference to its associated vector.",21,null],[11,"to_vec","","",21,null],[11,"as_vec","","",21,null],[11,"set_coords","","",21,null],[11,"sub","","",21,null],[11,"neg","","",21,null],[11,"add","","",21,null],[11,"sub","","",21,null],[11,"approx_epsilon","","",21,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",21,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",21,null],[11,"approx_eq_eps","","",21,null],[11,"approx_eq_ulps","","",21,null],[11,"from_iter","","",21,{"inputs":[{"name":"i"}],"output":{"name":"pnt4"}}],[11,"max_value","","",21,{"inputs":[],"output":{"name":"pnt4"}}],[11,"min_value","","",21,{"inputs":[],"output":{"name":"pnt4"}}],[11,"axpy","","",21,null],[11,"iter","","",21,null],[11,"iter_mut","","",21,null],[11,"to_homogeneous","","",21,null],[11,"from","","",21,{"inputs":[{"name":"pnt5"}],"output":{"name":"pnt4"}}],[11,"rand","","",21,{"inputs":[{"name":"r"}],"output":{"name":"pnt4"}}],[11,"fmt","","",22,null],[11,"hash","","",22,null],[11,"clone","","",22,null],[11,"decode","","",22,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",22,null],[11,"eq","","",22,null],[11,"ne","","",22,null],[11,"new","","Creates a new vector.",22,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"pnt5"}}],[11,"orig","","",22,{"inputs":[],"output":{"name":"pnt5"}}],[11,"is_orig","","",22,null],[11,"inf","","",22,null],[11,"sup","","",22,null],[11,"partial_cmp","","",22,null],[11,"partial_lt","","",22,null],[11,"partial_le","","",22,null],[11,"partial_gt","","",22,null],[11,"partial_ge","","",22,null],[11,"mul","","",22,null],[11,"div","","",22,null],[11,"add","","",22,null],[11,"sub","","",22,null],[11,"from","","",22,{"inputs":[{"name":"pnt5"}],"output":{"name":"pnt5"}}],[11,"as_ref","","",22,null],[11,"as_mut","","",22,null],[11,"index","","",22,null],[11,"index_mut","","",22,null],[11,"shape","","",22,null],[11,"swap","","",22,null],[11,"unsafe_at","","",22,null],[11,"unsafe_set","","",22,null],[11,"at_fast","","Unsafe read access to a vector element by index.",22,null],[11,"set_fast","","Unsafe write access to a vector element by index.",22,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",22,{"inputs":[{"name":"n"}],"output":{"name":"pnt5"}}],[11,"dim","","",22,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",22,null],[11,"to_vec","","Converts this point to its associated vector.",22,null],[11,"as_vec","","Converts a reference to this point to a reference to its associated vector.",22,null],[11,"to_vec","","",22,null],[11,"as_vec","","",22,null],[11,"set_coords","","",22,null],[11,"sub","","",22,null],[11,"neg","","",22,null],[11,"add","","",22,null],[11,"sub","","",22,null],[11,"approx_epsilon","","",22,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",22,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",22,null],[11,"approx_eq_eps","","",22,null],[11,"approx_eq_ulps","","",22,null],[11,"from_iter","","",22,{"inputs":[{"name":"i"}],"output":{"name":"pnt5"}}],[11,"max_value","","",22,{"inputs":[],"output":{"name":"pnt5"}}],[11,"min_value","","",22,{"inputs":[],"output":{"name":"pnt5"}}],[11,"axpy","","",22,null],[11,"iter","","",22,null],[11,"iter_mut","","",22,null],[11,"to_homogeneous","","",22,null],[11,"from","","",22,{"inputs":[{"name":"pnt6"}],"output":{"name":"pnt5"}}],[11,"rand","","",22,{"inputs":[{"name":"r"}],"output":{"name":"pnt5"}}],[11,"fmt","","",23,null],[11,"hash","","",23,null],[11,"clone","","",23,null],[11,"decode","","",23,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",23,null],[11,"eq","","",23,null],[11,"ne","","",23,null],[11,"new","","Creates a new vector.",23,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"pnt6"}}],[11,"orig","","",23,{"inputs":[],"output":{"name":"pnt6"}}],[11,"is_orig","","",23,null],[11,"inf","","",23,null],[11,"sup","","",23,null],[11,"partial_cmp","","",23,null],[11,"partial_lt","","",23,null],[11,"partial_le","","",23,null],[11,"partial_gt","","",23,null],[11,"partial_ge","","",23,null],[11,"mul","","",23,null],[11,"div","","",23,null],[11,"add","","",23,null],[11,"sub","","",23,null],[11,"from","","",23,{"inputs":[{"name":"pnt6"}],"output":{"name":"pnt6"}}],[11,"as_ref","","",23,null],[11,"as_mut","","",23,null],[11,"index","","",23,null],[11,"index_mut","","",23,null],[11,"shape","","",23,null],[11,"swap","","",23,null],[11,"unsafe_at","","",23,null],[11,"unsafe_set","","",23,null],[11,"at_fast","","Unsafe read access to a vector element by index.",23,null],[11,"set_fast","","Unsafe write access to a vector element by index.",23,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",23,{"inputs":[{"name":"n"}],"output":{"name":"pnt6"}}],[11,"dim","","",23,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",23,null],[11,"to_vec","","Converts this point to its associated vector.",23,null],[11,"as_vec","","Converts a reference to this point to a reference to its associated vector.",23,null],[11,"to_vec","","",23,null],[11,"as_vec","","",23,null],[11,"set_coords","","",23,null],[11,"sub","","",23,null],[11,"neg","","",23,null],[11,"add","","",23,null],[11,"sub","","",23,null],[11,"approx_epsilon","","",23,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",23,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",23,null],[11,"approx_eq_eps","","",23,null],[11,"approx_eq_ulps","","",23,null],[11,"from_iter","","",23,{"inputs":[{"name":"i"}],"output":{"name":"pnt6"}}],[11,"max_value","","",23,{"inputs":[],"output":{"name":"pnt6"}}],[11,"min_value","","",23,{"inputs":[],"output":{"name":"pnt6"}}],[11,"axpy","","",23,null],[11,"iter","","",23,null],[11,"iter_mut","","",23,null],[11,"rand","","",23,{"inputs":[{"name":"r"}],"output":{"name":"pnt6"}}],[11,"fmt","","",24,null],[11,"hash","","",24,null],[11,"clone","","",24,null],[11,"decode","","",24,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",24,null],[11,"eq","","",24,null],[11,"ne","","",24,null],[11,"new","","Creates a new quaternion from its components.",24,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"quat"}}],[11,"vector","","The vector part `(i, j, k)` of this quaternion.",24,null],[11,"scalar","","The scalar part `w` of this quaternion.",24,null],[11,"conjugate","","Compute the conjugate of this quaternion.",24,null],[11,"conjugate_mut","","Replaces this quaternion by its conjugate.",24,null],[11,"inv","","",24,null],[11,"inv_mut","","",24,null],[11,"sqnorm","","",24,null],[11,"normalize","","",24,null],[11,"normalize_mut","","",24,null],[11,"mul","","",24,null],[11,"div","","",24,null],[11,"rand","","",24,{"inputs":[{"name":"r"}],"output":{"name":"quat"}}],[11,"fmt","","",33,null],[11,"hash","","",33,null],[11,"clone","","",33,null],[11,"decode","","",33,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",33,null],[11,"eq","","",33,null],[11,"ne","","",33,null],[11,"new","","Creates a new unit quaternion from the axis-angle representation of a rotation.",33,{"inputs":[{"name":"vec3"}],"output":{"name":"unitquat"}}],[11,"new_with_quat","","Creates a new unit quaternion from a quaternion.",33,{"inputs":[{"name":"quat"}],"output":{"name":"unitquat"}}],[11,"new_with_euler_angles","","Creates a new unit quaternion from Euler angles.",33,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"unitquat"}}],[11,"to_rot","","Builds a rotation matrix from this quaternion.",33,null],[11,"new_with_unit_quat","","Creates a new unit quaternion from a quaternion.",33,{"inputs":[{"name":"quat"}],"output":{"name":"unitquat"}}],[11,"quat","","The `Quat` representation of this unit quaternion.",33,null],[11,"one","","",33,{"inputs":[],"output":{"name":"unitquat"}}],[11,"inv","","",33,null],[11,"inv_mut","","",33,null],[11,"rand","","",33,{"inputs":[{"name":"r"}],"output":{"name":"unitquat"}}],[11,"approx_epsilon","","",33,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",33,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",33,null],[11,"approx_eq_ulps","","",33,null],[11,"div","","",33,null],[11,"mul","","",33,null],[11,"mul","","",33,null],[11,"mul","","",33,null],[11,"mul","","",13,null],[11,"mul","","",20,null],[11,"rotation","","",33,null],[11,"inv_rotation","","",33,null],[11,"append_rotation_mut","","",33,null],[11,"append_rotation","","",33,null],[11,"prepend_rotation_mut","","",33,null],[11,"prepend_rotation","","",33,null],[11,"set_rotation","","",33,null],[11,"to_rot_mat","","",33,null],[11,"rotate","","",33,null],[11,"inv_rotate","","",33,null],[11,"rotate","","",33,null],[11,"inv_rotate","","",33,null],[11,"angle_to","","",33,null],[11,"rotation_to","","",33,null],[11,"transform","","",33,null],[11,"inv_transform","","",33,null],[11,"transform","","",33,null],[11,"inv_transform","","",33,null],[11,"inf","","",24,null],[11,"sup","","",24,null],[11,"partial_cmp","","",24,null],[11,"partial_lt","","",24,null],[11,"partial_le","","",24,null],[11,"partial_gt","","",24,null],[11,"partial_ge","","",24,null],[11,"w","","Create a unit vector with its `$compN` component equal to 1.0.",24,{"inputs":[],"output":{"name":"quat"}}],[11,"i","","Create a unit vector with its `$compN` component equal to 1.0.",24,{"inputs":[],"output":{"name":"quat"}}],[11,"j","","Create a unit vector with its `$compN` component equal to 1.0.",24,{"inputs":[],"output":{"name":"quat"}}],[11,"k","","Create a unit vector with its `$compN` component equal to 1.0.",24,{"inputs":[],"output":{"name":"quat"}}],[11,"from","","",24,{"inputs":[{"name":"quat"}],"output":{"name":"quat"}}],[11,"as_ref","","",24,null],[11,"as_mut","","",24,null],[11,"index","","",24,null],[11,"index_mut","","",24,null],[11,"shape","","",24,null],[11,"swap","","",24,null],[11,"unsafe_at","","",24,null],[11,"unsafe_set","","",24,null],[11,"at_fast","","Unsafe read access to a vector element by index.",24,null],[11,"set_fast","","Unsafe write access to a vector element by index.",24,null],[11,"repeat","","Creates a new vector with all its components equal to a given value.",24,{"inputs":[{"name":"n"}],"output":{"name":"quat"}}],[11,"dim","","",24,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"len","","",24,null],[11,"add","","",24,null],[11,"sub","","",24,null],[11,"add","","",24,null],[11,"sub","","",24,null],[11,"mul","","",24,null],[11,"div","","",24,null],[11,"neg","","",24,null],[11,"one","","",24,{"inputs":[],"output":{"name":"quat"}}],[11,"zero","","",24,{"inputs":[],"output":{"name":"quat"}}],[11,"is_zero","","",24,null],[11,"approx_epsilon","","",24,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",24,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",24,null],[11,"approx_eq_eps","","",24,null],[11,"approx_eq_ulps","","",24,null],[11,"from_iter","","",24,{"inputs":[{"name":"i"}],"output":{"name":"quat"}}],[11,"max_value","","",24,{"inputs":[],"output":{"name":"quat"}}],[11,"min_value","","",24,{"inputs":[],"output":{"name":"quat"}}],[11,"axpy","","",24,null],[11,"iter","","",24,null],[11,"iter_mut","","",24,null],[11,"dim","","",33,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"fmt","","",34,null],[11,"clone","","",34,null],[11,"decode","","",34,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",34,null],[11,"eq","","",34,null],[11,"new","","Creates a new identity matrix.",34,{"inputs":[],"output":{"name":"identity"}}],[11,"fmt","","",4,null],[11,"hash","","",4,null],[11,"clone","","",4,null],[11,"decode","","",4,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"new_identity","","",4,{"inputs":[{"name":"usize"}],"output":{"name":"mat1"}}],[11,"new","","",4,{"inputs":[{"name":"n"}],"output":{"name":"mat1"}}],[11,"repeat","","",4,{"inputs":[{"name":"n"}],"output":{"name":"mat1"}}],[11,"as_ref","","",4,null],[11,"as_mut","","",4,null],[11,"from","","",4,{"inputs":[{"name":"mat1"}],"output":{"name":"mat1"}}],[11,"add","","",4,null],[11,"sub","","",4,null],[11,"add","","",4,null],[11,"sub","","",4,null],[11,"mul","","",4,null],[11,"div","","",4,null],[11,"abs","","",4,{"inputs":[{"name":"mat1"}],"output":{"name":"mat1"}}],[11,"zero","","",4,{"inputs":[],"output":{"name":"mat1"}}],[11,"is_zero","","",4,null],[11,"one","","",4,{"inputs":[],"output":{"name":"mat1"}}],[11,"iter","","",4,null],[11,"iter_mut","","",4,null],[11,"at_fast","","",4,null],[11,"set_fast","","",4,null],[11,"dim","","",4,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"shape","","",4,null],[11,"swap","","",4,null],[11,"unsafe_at","","",4,null],[11,"unsafe_set","","",4,null],[11,"index","","",4,null],[11,"index_mut","","",4,null],[11,"mul","","",4,null],[11,"mul","","",4,null],[11,"mul","","",11,null],[11,"mul","","",4,null],[11,"mul","","",18,null],[11,"transpose","","",4,null],[11,"transpose_mut","","",4,null],[11,"approx_epsilon","","",4,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",4,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",4,null],[11,"approx_eq_ulps","","",4,null],[11,"nrows","","",4,null],[11,"set_row","","",4,null],[11,"row","","",4,null],[11,"ncols","","",4,null],[11,"set_col","","",4,null],[11,"col","","",4,null],[11,"col_slice","","",4,null],[11,"row_slice","","",4,null],[11,"from_diag","","",4,{"inputs":[{"name":"vec1"}],"output":{"name":"mat1"}}],[11,"diag","","",4,null],[11,"to_homogeneous","","",4,null],[11,"from","","",4,{"inputs":[{"name":"mat2"}],"output":{"name":"mat1"}}],[11,"outer","","",11,null],[11,"eigen_qr","","",4,null],[11,"rand","","",4,{"inputs":[{"name":"r"}],"output":{"name":"mat1"}}],[11,"fmt","","",5,null],[11,"hash","","",5,null],[11,"clone","","",5,null],[11,"decode","","",5,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",5,null],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"new_identity","","",5,{"inputs":[{"name":"usize"}],"output":{"name":"mat2"}}],[11,"new","","",5,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"mat2"}}],[11,"repeat","","",5,{"inputs":[{"name":"n"}],"output":{"name":"mat2"}}],[11,"as_ref","","",5,null],[11,"as_mut","","",5,null],[11,"from","","",5,{"inputs":[{"name":"mat2"}],"output":{"name":"mat2"}}],[11,"add","","",5,null],[11,"sub","","",5,null],[11,"add","","",5,null],[11,"sub","","",5,null],[11,"mul","","",5,null],[11,"div","","",5,null],[11,"abs","","",5,{"inputs":[{"name":"mat2"}],"output":{"name":"mat2"}}],[11,"zero","","",5,{"inputs":[],"output":{"name":"mat2"}}],[11,"is_zero","","",5,null],[11,"one","","",5,{"inputs":[],"output":{"name":"mat2"}}],[11,"iter","","",5,null],[11,"iter_mut","","",5,null],[11,"dim","","",5,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"shape","","",5,null],[11,"swap","","",5,null],[11,"unsafe_at","","",5,null],[11,"unsafe_set","","",5,null],[11,"index","","",5,null],[11,"index_mut","","",5,null],[11,"at_fast","","",5,null],[11,"set_fast","","",5,null],[11,"transpose","","",5,null],[11,"transpose_mut","","",5,null],[11,"approx_epsilon","","",5,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",5,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",5,null],[11,"approx_eq_ulps","","",5,null],[11,"nrows","","",5,null],[11,"set_row","","",5,null],[11,"row","","",5,null],[11,"ncols","","",5,null],[11,"set_col","","",5,null],[11,"col","","",5,null],[11,"col_slice","","",5,null],[11,"row_slice","","",5,null],[11,"from_diag","","",5,{"inputs":[{"name":"vec2"}],"output":{"name":"mat2"}}],[11,"diag","","",5,null],[11,"to_homogeneous","","",5,null],[11,"from","","",5,{"inputs":[{"name":"mat3"}],"output":{"name":"mat2"}}],[11,"outer","","",12,null],[11,"eigen_qr","","",5,null],[11,"rand","","",5,{"inputs":[{"name":"r"}],"output":{"name":"mat2"}}],[11,"fmt","","",6,null],[11,"hash","","",6,null],[11,"clone","","",6,null],[11,"decode","","",6,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"new_identity","","",6,{"inputs":[{"name":"usize"}],"output":{"name":"mat3"}}],[11,"new","","",6,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"mat3"}}],[11,"repeat","","",6,{"inputs":[{"name":"n"}],"output":{"name":"mat3"}}],[11,"as_ref","","",6,null],[11,"as_mut","","",6,null],[11,"from","","",6,{"inputs":[{"name":"mat3"}],"output":{"name":"mat3"}}],[11,"add","","",6,null],[11,"sub","","",6,null],[11,"add","","",6,null],[11,"sub","","",6,null],[11,"mul","","",6,null],[11,"div","","",6,null],[11,"abs","","",6,{"inputs":[{"name":"mat3"}],"output":{"name":"mat3"}}],[11,"zero","","",6,{"inputs":[],"output":{"name":"mat3"}}],[11,"is_zero","","",6,null],[11,"one","","",6,{"inputs":[],"output":{"name":"mat3"}}],[11,"iter","","",6,null],[11,"iter_mut","","",6,null],[11,"dim","","",6,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"shape","","",6,null],[11,"swap","","",6,null],[11,"unsafe_at","","",6,null],[11,"unsafe_set","","",6,null],[11,"index","","",6,null],[11,"index_mut","","",6,null],[11,"at_fast","","",6,null],[11,"set_fast","","",6,null],[11,"transpose","","",6,null],[11,"transpose_mut","","",6,null],[11,"approx_epsilon","","",6,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",6,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",6,null],[11,"approx_eq_ulps","","",6,null],[11,"col_slice","","",6,null],[11,"row_slice","","",6,null],[11,"from_diag","","",6,{"inputs":[{"name":"vec3"}],"output":{"name":"mat3"}}],[11,"diag","","",6,null],[11,"to_homogeneous","","",6,null],[11,"from","","",6,{"inputs":[{"name":"mat4"}],"output":{"name":"mat3"}}],[11,"outer","","",13,null],[11,"eigen_qr","","",6,null],[11,"rand","","",6,{"inputs":[{"name":"r"}],"output":{"name":"mat3"}}],[11,"fmt","","",7,null],[11,"hash","","",7,null],[11,"clone","","",7,null],[11,"decode","","",7,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"new_identity","","",7,{"inputs":[{"name":"usize"}],"output":{"name":"mat4"}}],[11,"new","","",7,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"mat4"}}],[11,"repeat","","",7,{"inputs":[{"name":"n"}],"output":{"name":"mat4"}}],[11,"as_ref","","",7,null],[11,"as_mut","","",7,null],[11,"from","","",7,{"inputs":[{"name":"mat4"}],"output":{"name":"mat4"}}],[11,"add","","",7,null],[11,"sub","","",7,null],[11,"add","","",7,null],[11,"sub","","",7,null],[11,"mul","","",7,null],[11,"div","","",7,null],[11,"abs","","",7,{"inputs":[{"name":"mat4"}],"output":{"name":"mat4"}}],[11,"zero","","",7,{"inputs":[],"output":{"name":"mat4"}}],[11,"is_zero","","",7,null],[11,"one","","",7,{"inputs":[],"output":{"name":"mat4"}}],[11,"iter","","",7,null],[11,"iter_mut","","",7,null],[11,"dim","","",7,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"shape","","",7,null],[11,"swap","","",7,null],[11,"unsafe_at","","",7,null],[11,"unsafe_set","","",7,null],[11,"index","","",7,null],[11,"index_mut","","",7,null],[11,"at_fast","","",7,null],[11,"set_fast","","",7,null],[11,"mul","","",7,null],[11,"mul","","",7,null],[11,"mul","","",14,null],[11,"mul","","",7,null],[11,"mul","","",21,null],[11,"inv","","",7,null],[11,"inv_mut","","",7,null],[11,"transpose","","",7,null],[11,"transpose_mut","","",7,null],[11,"approx_epsilon","","",7,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",7,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",7,null],[11,"approx_eq_ulps","","",7,null],[11,"nrows","","",7,null],[11,"set_row","","",7,null],[11,"row","","",7,null],[11,"ncols","","",7,null],[11,"set_col","","",7,null],[11,"col","","",7,null],[11,"col_slice","","",7,null],[11,"row_slice","","",7,null],[11,"from_diag","","",7,{"inputs":[{"name":"vec4"}],"output":{"name":"mat4"}}],[11,"diag","","",7,null],[11,"to_homogeneous","","",7,null],[11,"from","","",7,{"inputs":[{"name":"mat5"}],"output":{"name":"mat4"}}],[11,"outer","","",14,null],[11,"eigen_qr","","",7,null],[11,"rand","","",7,{"inputs":[{"name":"r"}],"output":{"name":"mat4"}}],[11,"fmt","","",8,null],[11,"hash","","",8,null],[11,"clone","","",8,null],[11,"decode","","",8,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"new_identity","","",8,{"inputs":[{"name":"usize"}],"output":{"name":"mat5"}}],[11,"new","","",8,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"mat5"}}],[11,"repeat","","",8,{"inputs":[{"name":"n"}],"output":{"name":"mat5"}}],[11,"as_ref","","",8,null],[11,"as_mut","","",8,null],[11,"from","","",8,{"inputs":[{"name":"mat5"}],"output":{"name":"mat5"}}],[11,"abs","","",8,{"inputs":[{"name":"mat5"}],"output":{"name":"mat5"}}],[11,"zero","","",8,{"inputs":[],"output":{"name":"mat5"}}],[11,"is_zero","","",8,null],[11,"one","","",8,{"inputs":[],"output":{"name":"mat5"}}],[11,"add","","",8,null],[11,"sub","","",8,null],[11,"add","","",8,null],[11,"sub","","",8,null],[11,"mul","","",8,null],[11,"div","","",8,null],[11,"iter","","",8,null],[11,"iter_mut","","",8,null],[11,"dim","","",8,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"shape","","",8,null],[11,"swap","","",8,null],[11,"unsafe_at","","",8,null],[11,"unsafe_set","","",8,null],[11,"index","","",8,null],[11,"index_mut","","",8,null],[11,"at_fast","","",8,null],[11,"set_fast","","",8,null],[11,"mul","","",8,null],[11,"mul","","",8,null],[11,"mul","","",15,null],[11,"mul","","",8,null],[11,"mul","","",22,null],[11,"inv","","",8,null],[11,"inv_mut","","",8,null],[11,"transpose","","",8,null],[11,"transpose_mut","","",8,null],[11,"approx_epsilon","","",8,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",8,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",8,null],[11,"approx_eq_ulps","","",8,null],[11,"nrows","","",8,null],[11,"set_row","","",8,null],[11,"row","","",8,null],[11,"ncols","","",8,null],[11,"set_col","","",8,null],[11,"col","","",8,null],[11,"col_slice","","",8,null],[11,"row_slice","","",8,null],[11,"from_diag","","",8,{"inputs":[{"name":"vec5"}],"output":{"name":"mat5"}}],[11,"diag","","",8,null],[11,"to_homogeneous","","",8,null],[11,"from","","",8,{"inputs":[{"name":"mat6"}],"output":{"name":"mat5"}}],[11,"outer","","",15,null],[11,"eigen_qr","","",8,null],[11,"rand","","",8,{"inputs":[{"name":"r"}],"output":{"name":"mat5"}}],[11,"fmt","","",9,null],[11,"hash","","",9,null],[11,"clone","","",9,null],[11,"decode","","",9,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"new_identity","","",9,{"inputs":[{"name":"usize"}],"output":{"name":"mat6"}}],[11,"new","","",9,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"mat6"}}],[11,"repeat","","",9,{"inputs":[{"name":"n"}],"output":{"name":"mat6"}}],[11,"as_ref","","",9,null],[11,"as_mut","","",9,null],[11,"from","","",9,{"inputs":[{"name":"mat6"}],"output":{"name":"mat6"}}],[11,"add","","",9,null],[11,"sub","","",9,null],[11,"add","","",9,null],[11,"sub","","",9,null],[11,"mul","","",9,null],[11,"div","","",9,null],[11,"abs","","",9,{"inputs":[{"name":"mat6"}],"output":{"name":"mat6"}}],[11,"zero","","",9,{"inputs":[],"output":{"name":"mat6"}}],[11,"is_zero","","",9,null],[11,"one","","",9,{"inputs":[],"output":{"name":"mat6"}}],[11,"iter","","",9,null],[11,"iter_mut","","",9,null],[11,"dim","","",9,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"shape","","",9,null],[11,"swap","","",9,null],[11,"unsafe_at","","",9,null],[11,"unsafe_set","","",9,null],[11,"index","","",9,null],[11,"index_mut","","",9,null],[11,"at_fast","","",9,null],[11,"set_fast","","",9,null],[11,"mul","","",9,null],[11,"mul","","",9,null],[11,"mul","","",16,null],[11,"mul","","",9,null],[11,"mul","","",23,null],[11,"inv","","",9,null],[11,"inv_mut","","",9,null],[11,"transpose","","",9,null],[11,"transpose_mut","","",9,null],[11,"approx_epsilon","","",9,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",9,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",9,null],[11,"approx_eq_ulps","","",9,null],[11,"nrows","","",9,null],[11,"set_row","","",9,null],[11,"row","","",9,null],[11,"ncols","","",9,null],[11,"set_col","","",9,null],[11,"col","","",9,null],[11,"col_slice","","",9,null],[11,"row_slice","","",9,null],[11,"from_diag","","",9,{"inputs":[{"name":"vec6"}],"output":{"name":"mat6"}}],[11,"diag","","",9,null],[11,"outer","","",16,null],[11,"eigen_qr","","",9,null],[11,"rand","","",9,{"inputs":[{"name":"r"}],"output":{"name":"mat6"}}],[11,"hash","","",35,null],[11,"fmt","","",35,null],[11,"clone","","",35,null],[11,"decode","","",35,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",35,null],[11,"eq","","",35,null],[11,"ne","","",35,null],[11,"new","","Builds a 2 dimensional rotation matrix from an angle in radian.",35,{"inputs":[{"name":"vec1"}],"output":{"name":"rot2"}}],[11,"rotation","","",35,null],[11,"inv_rotation","","",35,null],[11,"append_rotation_mut","","",35,null],[11,"append_rotation","","",35,null],[11,"prepend_rotation_mut","","",35,null],[11,"prepend_rotation","","",35,null],[11,"set_rotation","","",35,null],[11,"angle_to","","",35,null],[11,"rotation_to","","",35,null],[11,"rand","","",35,{"inputs":[{"name":"r"}],"output":{"name":"rot2"}}],[11,"absolute_rotate","","",35,null],[11,"hash","","",36,null],[11,"fmt","","",36,null],[11,"clone","","",36,null],[11,"decode","","",36,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",36,null],[11,"eq","","",36,null],[11,"ne","","",36,null],[11,"new","","Builds a 3 dimensional rotation matrix from an axis and an angle.",36,{"inputs":[{"name":"vec3"}],"output":{"name":"rot3"}}],[11,"new_with_mat","","Builds a rotation matrix from an orthogonal matrix.",36,{"inputs":[{"name":"mat3"}],"output":{"name":"rot3"}}],[11,"new_with_euler_angles","","Creates a new rotation from Euler angles.",36,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"rot3"}}],[11,"look_at","","Create a new matrix and orient it such that its local `x` axis points to a given point.\nNote that the usually known `look_at` function does the same thing but with the `z` axis.\nSee `look_at_z` for that.",36,{"inputs":[{"name":"vec3"},{"name":"vec3"}],"output":{"name":"rot3"}}],[11,"look_at_z","","Create a new matrix and orient it such that its local `z` axis points to a given point.",36,{"inputs":[{"name":"vec3"},{"name":"vec3"}],"output":{"name":"rot3"}}],[11,"rotation","","",36,null],[11,"inv_rotation","","",36,null],[11,"append_rotation_mut","","",36,null],[11,"append_rotation","","",36,null],[11,"prepend_rotation_mut","","",36,null],[11,"prepend_rotation","","",36,null],[11,"set_rotation","","",36,null],[11,"angle_to","","",36,null],[11,"rotation_to","","",36,null],[11,"rand","","",36,{"inputs":[{"name":"r"}],"output":{"name":"rot3"}}],[11,"absolute_rotate","","",36,null],[11,"hash","","",37,null],[11,"fmt","","",37,null],[11,"clone","","",37,null],[11,"decode","","",37,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",37,null],[11,"eq","","",37,null],[11,"ne","","",37,null],[11,"absolute_rotate","","",37,null],[11,"rotation","","",37,null],[11,"inv_rotation","","",37,null],[11,"append_rotation_mut","","",37,null],[11,"append_rotation","","",37,null],[11,"prepend_rotation_mut","","",37,null],[11,"prepend_rotation","","",37,null],[11,"set_rotation","","",37,null],[11,"submat","","",35,null],[11,"rotate","","",35,null],[11,"inv_rotate","","",35,null],[11,"rotate","","",35,null],[11,"inv_rotate","","",35,null],[11,"transform","","",35,null],[11,"inv_transform","","",35,null],[11,"transform","","",35,null],[11,"inv_transform","","",35,null],[11,"dim","","",35,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"mul","","",35,null],[11,"mul","","",35,null],[11,"mul","","",12,null],[11,"mul","","",35,null],[11,"mul","","",19,null],[11,"one","","",35,{"inputs":[],"output":{"name":"rot2"}}],[11,"new_identity","","",35,{"inputs":[{"name":"usize"}],"output":{"name":"rot2"}}],[11,"to_rot_mat","","",35,null],[11,"ncols","","",35,null],[11,"col","","",35,null],[11,"set_col","","",35,null],[11,"nrows","","",35,null],[11,"row","","",35,null],[11,"set_row","","",35,null],[11,"index","","",35,null],[11,"abs","","",35,{"inputs":[{"name":"rot2"}],"output":{"name":"mat2"}}],[11,"to_homogeneous","","",35,null],[11,"inv_mut","","",35,null],[11,"inv","","",35,null],[11,"transpose","","",35,null],[11,"transpose_mut","","",35,null],[11,"approx_epsilon","","",35,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",35,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",35,null],[11,"approx_eq_eps","","",35,null],[11,"approx_eq_ulps","","",35,null],[11,"from_diag","","",35,{"inputs":[{"name":"vec2"}],"output":{"name":"rot2"}}],[11,"diag","","",35,null],[11,"submat","","",36,null],[11,"rotate","","",36,null],[11,"inv_rotate","","",36,null],[11,"rotate","","",36,null],[11,"inv_rotate","","",36,null],[11,"transform","","",36,null],[11,"inv_transform","","",36,null],[11,"transform","","",36,null],[11,"inv_transform","","",36,null],[11,"dim","","",36,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"mul","","",36,null],[11,"mul","","",36,null],[11,"mul","","",13,null],[11,"mul","","",36,null],[11,"mul","","",20,null],[11,"one","","",36,{"inputs":[],"output":{"name":"rot3"}}],[11,"new_identity","","",36,{"inputs":[{"name":"usize"}],"output":{"name":"rot3"}}],[11,"to_rot_mat","","",36,null],[11,"ncols","","",36,null],[11,"col","","",36,null],[11,"set_col","","",36,null],[11,"nrows","","",36,null],[11,"row","","",36,null],[11,"set_row","","",36,null],[11,"index","","",36,null],[11,"abs","","",36,{"inputs":[{"name":"rot3"}],"output":{"name":"mat3"}}],[11,"to_homogeneous","","",36,null],[11,"inv_mut","","",36,null],[11,"inv","","",36,null],[11,"transpose","","",36,null],[11,"transpose_mut","","",36,null],[11,"approx_epsilon","","",36,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",36,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",36,null],[11,"approx_eq_eps","","",36,null],[11,"approx_eq_ulps","","",36,null],[11,"from_diag","","",36,{"inputs":[{"name":"vec3"}],"output":{"name":"rot3"}}],[11,"diag","","",36,null],[11,"submat","","",37,null],[11,"rotate","","",37,null],[11,"inv_rotate","","",37,null],[11,"rotate","","",37,null],[11,"inv_rotate","","",37,null],[11,"transform","","",37,null],[11,"inv_transform","","",37,null],[11,"transform","","",37,null],[11,"inv_transform","","",37,null],[11,"dim","","",37,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"mul","","",37,null],[11,"mul","","",37,null],[11,"mul","","",14,null],[11,"mul","","",37,null],[11,"mul","","",21,null],[11,"one","","",37,{"inputs":[],"output":{"name":"rot4"}}],[11,"new_identity","","",37,{"inputs":[{"name":"usize"}],"output":{"name":"rot4"}}],[11,"to_rot_mat","","",37,null],[11,"ncols","","",37,null],[11,"col","","",37,null],[11,"set_col","","",37,null],[11,"nrows","","",37,null],[11,"row","","",37,null],[11,"set_row","","",37,null],[11,"index","","",37,null],[11,"abs","","",37,{"inputs":[{"name":"rot4"}],"output":{"name":"mat4"}}],[11,"to_homogeneous","","",37,null],[11,"inv_mut","","",37,null],[11,"inv","","",37,null],[11,"transpose","","",37,null],[11,"transpose_mut","","",37,null],[11,"approx_epsilon","","",37,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",37,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq","","",37,null],[11,"approx_eq_eps","","",37,null],[11,"approx_eq_ulps","","",37,null],[11,"from_diag","","",37,{"inputs":[{"name":"vec4"}],"output":{"name":"rot4"}}],[11,"diag","","",37,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"decode","","",1,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"decode","","",2,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"decode","","",3,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"look_at","","Reorient and translate this transformation such that its local `x` axis points to a given\ndirection.  Note that the usually known `look_at` function does the same thing but with the\n`z` axis. See `look_at_z` for that.",2,{"inputs":[{"name":"pnt3"},{"name":"pnt3"},{"name":"vec3"}],"output":{"name":"iso3"}}],[11,"look_at_z","","Reorient and translate this transformation such that its local `z` axis points to a given\ndirection.",2,{"inputs":[{"name":"pnt3"},{"name":"pnt3"},{"name":"vec3"}],"output":{"name":"iso3"}}],[11,"new_with_rotmat","","Creates a new isometry from a rotation matrix and a vector.",3,{"inputs":[{"name":"vec4"},{"name":"rot4"}],"output":{"name":"iso4"}}],[11,"new","","Creates a new isometry from a rotation matrix and a vector.",1,{"inputs":[{"name":"vec2"},{"name":"vec1"}],"output":{"name":"iso2"}}],[11,"new_with_rotmat","","Creates a new isometry from a rotation matrix and a vector.",1,{"inputs":[{"name":"vec2"},{"name":"rot2"}],"output":{"name":"iso2"}}],[11,"to_rot_mat","","",1,null],[11,"rotation","","",1,null],[11,"inv_rotation","","",1,null],[11,"append_rotation_mut","","",1,null],[11,"append_rotation","","",1,null],[11,"prepend_rotation_mut","","",1,null],[11,"prepend_rotation","","",1,null],[11,"set_rotation","","",1,null],[11,"dim","","",1,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"one","","",1,{"inputs":[],"output":{"name":"iso2"}}],[11,"absolute_rotate","","",1,null],[11,"rand","","",1,{"inputs":[{"name":"r"}],"output":{"name":"iso2"}}],[11,"approx_epsilon","","",1,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",1,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",1,null],[11,"approx_eq_ulps","","",1,null],[11,"to_homogeneous","","",1,null],[11,"inv_mut","","",1,null],[11,"inv","","",1,null],[11,"transform","","",1,null],[11,"inv_transform","","",1,null],[11,"transformation","","",1,null],[11,"inv_transformation","","",1,null],[11,"append_transformation_mut","","",1,null],[11,"append_transformation","","",1,null],[11,"prepend_transformation_mut","","",1,null],[11,"prepend_transformation","","",1,null],[11,"set_transformation","","",1,null],[11,"rotate","","",1,null],[11,"inv_rotate","","",1,null],[11,"translation","","",1,null],[11,"inv_translation","","",1,null],[11,"append_translation_mut","","",1,null],[11,"append_translation","","",1,null],[11,"prepend_translation_mut","","",1,null],[11,"prepend_translation","","",1,null],[11,"set_translation","","",1,null],[11,"translate","","",1,null],[11,"inv_translate","","",1,null],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"mul","","",19,null],[11,"new","","Creates a new isometry from a rotation matrix and a vector.",2,{"inputs":[{"name":"vec3"},{"name":"vec3"}],"output":{"name":"iso3"}}],[11,"new_with_rotmat","","Creates a new isometry from a rotation matrix and a vector.",2,{"inputs":[{"name":"vec3"},{"name":"rot3"}],"output":{"name":"iso3"}}],[11,"to_rot_mat","","",2,null],[11,"rotation","","",2,null],[11,"inv_rotation","","",2,null],[11,"append_rotation_mut","","",2,null],[11,"append_rotation","","",2,null],[11,"prepend_rotation_mut","","",2,null],[11,"prepend_rotation","","",2,null],[11,"set_rotation","","",2,null],[11,"dim","","",2,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"one","","",2,{"inputs":[],"output":{"name":"iso3"}}],[11,"absolute_rotate","","",2,null],[11,"rand","","",2,{"inputs":[{"name":"r"}],"output":{"name":"iso3"}}],[11,"approx_epsilon","","",2,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",2,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",2,null],[11,"approx_eq_ulps","","",2,null],[11,"to_homogeneous","","",2,null],[11,"inv_mut","","",2,null],[11,"inv","","",2,null],[11,"transform","","",2,null],[11,"inv_transform","","",2,null],[11,"transformation","","",2,null],[11,"inv_transformation","","",2,null],[11,"append_transformation_mut","","",2,null],[11,"append_transformation","","",2,null],[11,"prepend_transformation_mut","","",2,null],[11,"prepend_transformation","","",2,null],[11,"set_transformation","","",2,null],[11,"rotate","","",2,null],[11,"inv_rotate","","",2,null],[11,"translation","","",2,null],[11,"inv_translation","","",2,null],[11,"append_translation_mut","","",2,null],[11,"append_translation","","",2,null],[11,"prepend_translation_mut","","",2,null],[11,"prepend_translation","","",2,null],[11,"set_translation","","",2,null],[11,"translate","","",2,null],[11,"inv_translate","","",2,null],[11,"mul","","",2,null],[11,"mul","","",2,null],[11,"mul","","",20,null],[11,"dim","","",3,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"one","","",3,{"inputs":[],"output":{"name":"iso4"}}],[11,"absolute_rotate","","",3,null],[11,"approx_epsilon","","",3,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",3,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",3,null],[11,"approx_eq_ulps","","",3,null],[11,"to_homogeneous","","",3,null],[11,"inv_mut","","",3,null],[11,"inv","","",3,null],[11,"transform","","",3,null],[11,"inv_transform","","",3,null],[11,"transformation","","",3,null],[11,"inv_transformation","","",3,null],[11,"append_transformation_mut","","",3,null],[11,"append_transformation","","",3,null],[11,"prepend_transformation_mut","","",3,null],[11,"prepend_transformation","","",3,null],[11,"set_transformation","","",3,null],[11,"rotate","","",3,null],[11,"inv_rotate","","",3,null],[11,"translation","","",3,null],[11,"inv_translation","","",3,null],[11,"append_translation_mut","","",3,null],[11,"append_translation","","",3,null],[11,"prepend_translation_mut","","",3,null],[11,"prepend_translation","","",3,null],[11,"set_translation","","",3,null],[11,"translate","","",3,null],[11,"inv_translate","","",3,null],[11,"mul","","",3,null],[11,"mul","","",3,null],[11,"mul","","",21,null],[11,"fmt","","",38,null],[11,"clone","","",38,null],[11,"decode","","",38,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",38,null],[11,"eq","","",38,null],[11,"ne","","",38,null],[11,"fmt","","",39,null],[11,"clone","","",39,null],[11,"decode","","",39,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",39,null],[11,"eq","","",39,null],[11,"ne","","",39,null],[11,"new","","Creates a new 3D perspective projection.",38,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"persp3"}}],[11,"to_mat","","Builds a 4D projection matrix (using homogeneous coordinates) for this projection.",38,null],[11,"to_persp_mat","","Build a `PerspMat3` representing this projection.",38,null],[11,"aspect","","Gets the `width / height` aspect ratio.",38,null],[11,"fov","","Gets the field of view of the view frustrum.",38,null],[11,"znear","","Gets the near plane offset of the view frustrum.",38,null],[11,"zfar","","Gets the far plane offset of the view frustrum.",38,null],[11,"set_aspect","","Sets the `width / height` aspect ratio of the view frustrum.",38,null],[11,"set_fov","","Sets the field of view of the view frustrum.",38,null],[11,"set_znear","","Sets the near plane offset of the view frustrum.",38,null],[11,"set_zfar","","Sets the far plane offset of the view frustrum.",38,null],[11,"project_pnt","","Projects a point.",38,null],[11,"project_vec","","Projects a vector.",38,null],[11,"new","","Creates a new persepctive matrix from the aspect ratio, field of view, and near/far planes.",39,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"perspmat3"}}],[11,"new_with_mat","","Creates a new perspective projection matrix from a 4D matrix.",39,{"inputs":[{"name":"mat4"}],"output":{"name":"perspmat3"}}],[11,"as_mat","","Returns a reference to the 4D matrix (using homogeneous coordinates) of this projection.",39,null],[11,"aspect","","Gets the `width / height` aspect ratio of the view frustrum.",39,null],[11,"fov","","Gets the field of view of the view frustrum.",39,null],[11,"znear","","Gets the near plane offset of the view frustrum.",39,null],[11,"zfar","","Gets the far plane offset of the view frustrum.",39,null],[11,"set_aspect","","Updates this projection matrix with a new `width / height` aspect ratio of the view\nfrustrum.",39,null],[11,"set_fov","","Updates this projection with a new field of view of the view frustrum.",39,null],[11,"set_znear","","Updates this projection matrix with a new near plane offset of the view frustrum.",39,null],[11,"set_zfar","","Updates this projection matrix with a new far plane offset of the view frustrum.",39,null],[11,"set_znear_and_zfar","","Updates this projection matrix with new near and far plane offsets of the view frustrum.",39,null],[11,"project_pnt","","Projects a point.",39,null],[11,"project_vec","","Projects a vector.",39,null],[11,"to_mat","","Returns the 4D matrix (using homogeneous coordinates) of this projection.",39,null],[11,"fmt","","",40,null],[11,"clone","","",40,null],[11,"decode","","",40,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",40,null],[11,"eq","","",40,null],[11,"ne","","",40,null],[11,"fmt","","",41,null],[11,"clone","","",41,null],[11,"decode","","",41,{"inputs":[{"name":"__dn"}],"output":{"name":"result"}}],[11,"encode","","",41,null],[11,"eq","","",41,null],[11,"ne","","",41,null],[11,"new","","Creates a new 3D orthographic projection.",40,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"ortho3"}}],[11,"to_mat","","Builds a 4D projection matrix (using homogeneous coordinates) for this projection.",40,null],[11,"to_persp_mat","","Build a `OrthoMat3` representing this projection.",40,null],[11,"width","","The width of the view cuboid.",40,null],[11,"height","","The height of the view cuboid.",40,null],[11,"znear","","The near plane offset of the view cuboid.",40,null],[11,"zfar","","The far plane offset of the view cuboid.",40,null],[11,"set_width","","Sets the width of the view cuboid.",40,null],[11,"set_height","","Sets the height of the view cuboid.",40,null],[11,"set_znear","","Sets the near plane offset of the view cuboid.",40,null],[11,"set_zfar","","Sets the far plane offset of the view cuboid.",40,null],[11,"project_pnt","","Projects a point.",40,null],[11,"project_vec","","Projects a vector.",40,null],[11,"new","","Creates a new orthographic projection matrix from the width, heihgt, znear and zfar planes of the view cuboid.",41,{"inputs":[{"name":"n"},{"name":"n"},{"name":"n"},{"name":"n"}],"output":{"name":"orthomat3"}}],[11,"new_with_mat","","Creates a new orthographic matrix from a 4D matrix.",41,{"inputs":[{"name":"mat4"}],"output":{"name":"orthomat3"}}],[11,"as_mat","","Returns a reference to the 4D matrix (using homogeneous coordinates) of this projection.",41,null],[11,"width","","The width of the view cuboid.",41,null],[11,"height","","The height of the view cuboid.",41,null],[11,"znear","","The near plane offset of the view cuboid.",41,null],[11,"zfar","","The far plane offset of the view cuboid.",41,null],[11,"set_width","","Sets the width of the view cuboid.",41,null],[11,"set_height","","Sets the height of the view cuboid.",41,null],[11,"set_znear","","Sets the near plane offset of the view cuboid.",41,null],[11,"set_zfar","","Sets the far plane offset of the view cuboid.",41,null],[11,"set_znear_and_zfar","","Sets the near and far plane offsets of the view cuboid.",41,null],[11,"project_pnt","","Projects a point.",41,null],[11,"project_vec","","Projects a vector.",41,null],[11,"to_mat","","Returns the 4D matrix (using homogeneous coordinates) of this projection.",41,null],[11,"one","","",34,{"inputs":[],"output":{"name":"identity"}}],[11,"inv","","",34,null],[11,"inv_mut","","",34,null],[11,"mul","","",34,null],[11,"transpose","","",34,null],[11,"transpose_mut","","",34,null],[11,"translate","","",34,null],[11,"inv_translate","","",34,null],[11,"rotate","","",34,null],[11,"inv_rotate","","",34,null],[11,"absolute_rotate","","",34,null],[11,"transform","","",34,null],[11,"inv_transform","","",34,null],[11,"inv","","",4,null],[11,"inv_mut","","",4,null],[11,"inv","","",5,null],[11,"inv_mut","","",5,null],[11,"inv","","",6,null],[11,"inv_mut","","",6,null],[11,"det","","",4,null],[11,"det","","",5,null],[11,"det","","",6,null],[11,"nrows","","",6,null],[11,"row","","",6,null],[11,"set_row","","",6,null],[11,"ncols","","",6,null],[11,"col","","",6,null],[11,"set_col","","",6,null],[11,"mul","","",6,null],[11,"mul","","",5,null],[11,"mul","","",6,null],[11,"mul","","",13,null],[11,"mul","","",12,null],[11,"mul","","",5,null],[11,"mul","","",6,null],[11,"mul","","",20,null],[11,"mul","","",19,null],[11,"mul","","",5,null],[11,"zero","","",10,{"inputs":[],"output":{"name":"vec0"}}],[11,"is_zero","","",10,null],[11,"index","","",10,null],[11,"index_mut","","",10,null],[11,"shape","","",10,null],[11,"swap","","",10,null],[11,"unsafe_at","","",10,null],[11,"unsafe_set","","",10,null],[11,"iter","","",10,null],[11,"iter_mut","","",10,null],[11,"dim","","",10,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[11,"canonical_basis","","",10,{"inputs":[{"name":"f"}],"output":null}],[11,"orthonormal_subspace_basis","","",10,{"inputs":[{"name":"vec0"},{"name":"f"}],"output":null}],[11,"canonical_basis_element","","",10,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"add","","",10,null],[11,"sub","","",10,null],[11,"neg","","",10,null],[11,"dot","","",10,null],[11,"mul","","",10,null],[11,"div","","",10,null],[11,"translation","","",10,null],[11,"inv_translation","","",10,null],[11,"append_translation_mut","","",10,null],[11,"append_translation","","",10,null],[11,"prepend_translation_mut","","",10,null],[11,"prepend_translation","","",10,null],[11,"set_translation","","",10,null],[11,"sqnorm","","",10,null],[11,"norm","","",10,null],[11,"normalize","","",10,null],[11,"normalize_mut","","",10,null],[11,"approx_epsilon","","",10,{"inputs":[{"name":"option"}],"output":{"name":"n"}}],[11,"approx_ulps","","",10,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[11,"approx_eq_eps","","",10,null],[11,"approx_eq_ulps","","",10,null],[11,"one","","",10,{"inputs":[],"output":{"name":"vec0"}}],[11,"from_iter","","",10,{"inputs":[{"name":"i"}],"output":{"name":"vec0"}}],[11,"max_value","","",10,{"inputs":[],"output":{"name":"vec0"}}],[11,"min_value","","",10,{"inputs":[],"output":{"name":"vec0"}}],[11,"rand","","",10,{"inputs":[{"name":"r"}],"output":{"name":"vec0"}}],[11,"angle_to","","",12,null],[11,"rotation_to","","",12,null],[11,"angle_to","","",13,null],[11,"rotation_to","","",13,null],[11,"cross","","",12,null],[11,"cross_matrix","","",12,null],[11,"cross","","",13,null],[11,"cross_matrix","","",13,null],[11,"nrows","","",12,null],[11,"row","","",12,null],[11,"set_row","","",12,null],[11,"canonical_basis","","",11,{"inputs":[{"name":"f"}],"output":null}],[11,"orthonormal_subspace_basis","","",11,{"inputs":[{"name":"vec1"},{"name":"f"}],"output":null}],[11,"canonical_basis_element","","",11,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"canonical_basis","","",12,{"inputs":[{"name":"f"}],"output":null}],[11,"orthonormal_subspace_basis","","",12,{"inputs":[{"name":"vec2"},{"name":"f"}],"output":null}],[11,"canonical_basis_element","","",12,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"canonical_basis","","",13,{"inputs":[{"name":"f"}],"output":null}],[11,"orthonormal_subspace_basis","","",13,{"inputs":[{"name":"vec3"},{"name":"f"}],"output":null}],[11,"canonical_basis_element","","",13,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"sample","","",11,{"inputs":[{"name":"f"}],"output":null}],[11,"sample","","",12,{"inputs":[{"name":"f"}],"output":null}],[11,"sample","","",13,{"inputs":[{"name":"f"}],"output":null}],[11,"sample","","",14,{"inputs":[{"name":"f"}],"output":null}],[11,"fmt","","",25,null],[11,"clone","","",25,null],[11,"decode","","",25,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",25,null],[11,"eq","","",25,null],[11,"is_eq","","Returns `true` if `self` is equal to `Equal`.",25,null],[11,"is_lt","","Returns `true` if `self` is equal to `Less`.",25,null],[11,"is_le","","Returns `true` if `self` is equal to `Less` or `Equal`.",25,null],[11,"is_gt","","Returns `true` if `self` is equal to `Greater`.",25,null],[11,"is_ge","","Returns `true` if `self` is equal to `Greater` or `Equal`.",25,null],[11,"is_not_comparable","","Returns `true` if `self` is equal to `NotComparable`.",25,null],[11,"from_ordering","","Creates a `POrdering` from an `Ordering`.",25,{"inputs":[{"name":"ordering"}],"output":{"name":"pordering"}}],[11,"to_ordering","","Converts this `POrdering` to an `Ordering`.",25,null],[8,"Absolute","","Trait of objects having an absolute value.\nThis is useful if the object does not have the same type as its absolute value.",null,null],[10,"abs","","Computes some absolute value of this object.\nTypically, this will make all component of a matrix or vector positive.",42,{"inputs":[{"name":"self"}],"output":{"name":"a"}}],[8,"AbsoluteRotate","","Composition of a rotation and an absolute value.",null,null],[10,"absolute_rotate","","This is the same as:",43,null],[8,"ApproxEq","","Trait for testing approximate equality",null,null],[10,"approx_epsilon","","Default epsilon for approximation.",44,{"inputs":[{"name":"option"}],"output":{"name":"eps"}}],[10,"approx_eq_eps","","Tests approximate equality using a custom epsilon.",44,null],[10,"approx_ulps","","Default ULPs for approximation.",44,{"inputs":[{"name":"option"}],"output":{"name":"u32"}}],[10,"approx_eq_ulps","","Tests approximate equality using units in the last place (ULPs)",44,null],[11,"approx_eq","","Tests approximate equality.",44,null],[8,"Axpy","","Trait of objects implementing the `y = ax + y` operation.",null,null],[10,"axpy","","Adds $$a * x$$ to `self`.",45,null],[8,"Basis","","Traits of objects which can form a basis (typically vectors).",null,null],[10,"canonical_basis","","Iterates through the canonical basis of the space in which this object lives.",46,{"inputs":[{"name":"f"}],"output":null}],[10,"orthonormal_subspace_basis","","Iterates through a basis of the subspace orthogonal to `self`.",46,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[10,"canonical_basis_element","","Gets the ith element of the canonical basis.",46,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[8,"BaseFloat","","Basic floating-point number numeric trait.",null,null],[10,"pi","","Archimedes&#39; constant.",47,{"inputs":[],"output":{"name":"self"}}],[10,"two_pi","","2.0 * pi.",47,{"inputs":[],"output":{"name":"self"}}],[10,"frac_pi_2","","pi / 2.0.",47,{"inputs":[],"output":{"name":"self"}}],[10,"frac_pi_3","","pi / 3.0.",47,{"inputs":[],"output":{"name":"self"}}],[10,"frac_pi_4","","pi / 4.0.",47,{"inputs":[],"output":{"name":"self"}}],[10,"frac_pi_6","","pi / 6.0.",47,{"inputs":[],"output":{"name":"self"}}],[10,"frac_pi_8","","pi / 8.0.",47,{"inputs":[],"output":{"name":"self"}}],[10,"frac_1_pi","","1.0 / pi.",47,{"inputs":[],"output":{"name":"self"}}],[10,"frac_2_pi","","2.0 / pi.",47,{"inputs":[],"output":{"name":"self"}}],[10,"frac_2_sqrt_pi","","2.0 / sqrt(pi).",47,{"inputs":[],"output":{"name":"self"}}],[10,"e","","Euler&#39;s number.",47,{"inputs":[],"output":{"name":"self"}}],[10,"log2_e","","log2(e).",47,{"inputs":[],"output":{"name":"self"}}],[10,"log10_e","","log10(e).",47,{"inputs":[],"output":{"name":"self"}}],[10,"ln_2","","ln(2.0).",47,{"inputs":[],"output":{"name":"self"}}],[10,"ln_10","","ln(10.0).",47,{"inputs":[],"output":{"name":"self"}}],[8,"BaseNum","","Basic integral numeric trait.",null,null],[8,"Bounded","","Types that have maximum and minimum value.",null,null],[10,"min_value","","The minimum value.",48,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","The maximum value.",48,{"inputs":[],"output":{"name":"self"}}],[8,"Cast","","Traits of objects which can be created from an object of type `T`.",null,null],[10,"from","","Converts an element of type `T` to an element of type `Self`.",49,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[8,"Col","","Trait to access columns of a matrix or vector.",null,null],[10,"ncols","","The number of column of this matrix or vector.",50,null],[10,"col","","Reads the `i`-th column of `self`.",50,null],[10,"set_col","","Writes the `i`-th column of `self`.",50,null],[8,"ColSlice","","Trait to access part of a column of a matrix",null,null],[10,"col_slice","","Returns a view to a slice of a column of a matrix.",51,null],[8,"RowSlice","","Trait to access part of a row of a matrix",null,null],[10,"row_slice","","Returns a view to a slice of a row of a matrix.",52,null],[8,"Cov","","Trait for computing the covariance of a set of data.",null,null],[10,"cov","","Computes the covariance of the obsevations stored by `m`:",53,null],[11,"cov_to","","Computes the covariance of the obsevations stored by `m`:",53,null],[8,"Cross","","Trait of elements having a cross product.",null,null],[16,"CrossProductType","","The cross product output.",54,null],[10,"cross","","Computes the cross product between two elements (usually vectors).",54,null],[8,"CrossMatrix","","Trait of elements having a cross product operation which can be expressed as a matrix.",null,null],[10,"cross_matrix","","The matrix associated to any cross product with this vector. I.e. `v.cross(anything)` =\n`v.cross_matrix().rmul(anything)`.",55,null],[8,"Det","","Trait of objects having a determinant. Typically used by square matrices.",null,null],[10,"det","","Returns the determinant of `m`.",56,null],[8,"Diag","","Trait to get the diagonal of square matrices.",null,null],[10,"from_diag","","Creates a new matrix with the given diagonal.",57,{"inputs":[{"name":"v"}],"output":{"name":"self"}}],[10,"diag","","The diagonal of this matrix.",57,null],[8,"Dim","","Trait of objects having a spacial dimension known at compile time.",null,null],[10,"dim","","The dimension of the object.",58,{"inputs":[{"name":"option"}],"output":{"name":"usize"}}],[8,"Dot","","Traits of objects having a dot product.",null,null],[10,"dot","","Computes the dot (inner) product of two vectors.",59,null],[8,"EigenQR","","Trait for computing the eigenvector and eigenvalues of a square matrix usin the QR algorithm.",null,null],[10,"eigen_qr","","Computes the eigenvectors and eigenvalues of this matrix.",60,null],[8,"Eye","","Trait for constructing the identity matrix",null,null],[10,"new_identity","","Return the identity matrix of specified dimension",61,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[8,"FloatPnt","","Trait of points with components implementing the `BaseFloat` trait.",null,null],[11,"sqdist","","Computes the square distance between two points.",62,null],[11,"dist","","Computes the distance between two points.",62,null],[8,"FloatVec","","Trait of vector with components implementing the `BaseFloat` trait.",null,null],[8,"FromHomogeneous","","Traits of objects which can be build from an homogeneous coordinate form.",null,null],[10,"from","","Builds an object from its homogeneous coordinate form.",63,{"inputs":[{"name":"u"}],"output":{"name":"self"}}],[8,"Indexable","","This is a workaround of current Rust limitations.",null,null],[10,"swap","","Swaps the `i`-th element of `self` with its `j`-th element.",64,null],[10,"unsafe_at","","Reads the `i`-th element of `self`.",64,null],[10,"unsafe_set","","Writes to the `i`-th element of `self`.",64,null],[8,"Inv","","Trait of objects having an inverse. Typically used to implement matrix inverse.",null,null],[10,"inv","","Returns the inverse of `m`.",65,null],[10,"inv_mut","","In-place version of `inverse`.",65,null],[8,"Iterable","","This is a workaround of current Rust limitations.",null,null],[10,"iter","","Gets a vector-like read-only iterator.",66,null],[8,"IterableMut","","This is a workaround of current Rust limitations.",null,null],[10,"iter_mut","","Gets a vector-like read-write iterator.",67,null],[8,"Mat","","Trait of matrices.",null,null],[8,"Mean","","Trait for computing the covariance of a set of data.",null,null],[10,"mean","","Computes the mean of the observations stored by `v`.",68,null],[8,"Norm","","Traits of objects having an euclidian norm.",null,null],[11,"norm","","Computes the norm of `self`.",69,null],[10,"sqnorm","","Computes the squared norm of `self`.",69,null],[10,"normalize","","Gets the normalized version of a copy of `v`.",69,null],[10,"normalize_mut","","Normalizes `self`.",69,null],[8,"NumPnt","","Trait grouping most common operations on points.",null,null],[8,"NumVec","","Trait grouping most common operations on vectors.",null,null],[8,"Orig","","The zero element of a vector space, seen as an element of its embeding affine space.",null,null],[10,"orig","","The trivial origin.",70,{"inputs":[],"output":{"name":"self"}}],[10,"is_orig","","Returns true if this points is exactly the trivial origin.",70,null],[8,"Outer","","Traits of objects having an outer product.",null,null],[16,"OuterProductType","","Result type of the outer product.",71,null],[10,"outer","","Computes the outer product: `a * b`",71,null],[8,"POrd","","Pointwise ordering operations.",null,null],[10,"inf","","Returns the infimum of this value and another",72,null],[10,"sup","","Returns the supremum of this value and another",72,null],[10,"partial_cmp","","Compare `self` and `other` using a partial ordering relation.",72,null],[11,"partial_le","","Returns `true` iff `self` and `other` are comparable and `self &lt;= other`.",72,null],[11,"partial_lt","","Returns `true` iff `self` and `other` are comparable and `self &lt; other`.",72,null],[11,"partial_ge","","Returns `true` iff `self` and `other` are comparable and `self &gt;= other`.",72,null],[11,"partial_gt","","Returns `true` iff `self` and `other` are comparable and `self &gt; other`.",72,null],[11,"partial_min","","Return the minimum of `self` and `other` if they are comparable.",72,null],[11,"partial_max","","Return the maximum of `self` and `other` if they are comparable.",72,null],[11,"partial_clamp","","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to\n`min` or `max`.",72,null],[8,"PntAsVec","","Trait that relates a point of an affine space to a vector of the associated vector space.",null,null],[10,"to_vec","","Converts this point to its associated vector.",73,null],[10,"as_vec","","Converts a reference to this point to a reference to its associated vector.",73,null],[10,"set_coords","","Sets the coordinates of this point to match those of a given vector.",73,null],[8,"Repeat","","Trait for constructiong an object repeating a value.",null,null],[10,"repeat","","Returns a value with filled by `val`.",74,{"inputs":[{"name":"n"}],"output":{"name":"self"}}],[8,"Rotate","","Trait of objects able to rotate other objects.",null,null],[10,"rotate","","Applies a rotation to `v`.",75,null],[10,"inv_rotate","","Applies an inverse rotation to `v`.",75,null],[8,"Rotation","","Trait of object which can represent a rotation, and to which new rotations can be appended. A\nrotation is assumed to be an isometry without translation and without reflexion.",null,null],[10,"rotation","","Gets the rotation associated with `self`.",76,null],[10,"inv_rotation","","Gets the inverse rotation associated with `self`.",76,null],[10,"append_rotation_mut","","Appends a rotation to this object.",76,null],[10,"append_rotation","","Appends the rotation `amount` to a copy of `t`.",76,null],[10,"prepend_rotation_mut","","Prepends a rotation to this object.",76,null],[10,"prepend_rotation","","Prepends the rotation `amount` to a copy of `t`.",76,null],[10,"set_rotation","","Sets the rotation of `self`.",76,null],[8,"RotationMatrix","","Trait of transformation having a rotation extractable as a rotation matrix. This can typically\nbe implemented by quaternions to convert them to a rotation matrix.",null,null],[16,"Output","","The output rotation matrix type.",77,null],[10,"to_rot_mat","","Gets the rotation matrix represented by `self`.",77,null],[8,"RotationWithTranslation","","Various composition of rotation and translation.",null,null],[11,"append_rotation_wrt_point","","Applies a rotation centered on a specific point.",78,null],[11,"append_rotation_wrt_point_mut","","Rotates `self` using a specific center of rotation.",78,null],[11,"append_rotation_wrt_center","","Applies a rotation centered on the translation of `m`.",78,null],[11,"append_rotation_wrt_center_mut","","Applies a rotation centered on the translation of `m`.",78,null],[8,"RotationTo","","Trait of object that can be rotated to be superimposed with another one of the same nature.",null,null],[16,"AngleType","","Type of the angle between two elements.",79,null],[16,"DeltaRotationType","","Type of the rotation between two elements.",79,null],[10,"angle_to","","Computes an angle nedded to transform the first element to the second one using a\nrotation.",79,null],[10,"rotation_to","","Computes the smallest rotation needed to transform the first element to the second one.",79,null],[8,"Row","","Trait to access rows of a matrix or a vector.",null,null],[10,"nrows","","The number of column of `self`.",80,null],[10,"row","","Reads the `i`-th row of `self`.",80,null],[10,"set_row","","Writes the `i`-th row of `self`.",80,null],[8,"Shape","","The shape of an indexable object.",null,null],[10,"shape","","Returns the shape of an indexable object.",81,null],[8,"SquareMat","","Trait implemented by square matrices.",null,null],[8,"ToHomogeneous","","Traits of objects which can be put in homogeneous coordinates form.",null,null],[10,"to_homogeneous","","Gets the homogeneous coordinates form of this object.",82,null],[8,"Transform","","Trait of objects able to transform other objects.",null,null],[10,"transform","","Applies a transformation to `v`.",83,null],[10,"inv_transform","","Applies an inverse transformation to `v`.",83,null],[8,"Transformation","","Trait of object which represent a transformation, and to which new transformations can\nbe appended.",null,null],[10,"transformation","","Gets the transformation of `self`.",84,null],[10,"inv_transformation","","Gets the inverse transformation of `self`.",84,null],[10,"append_transformation_mut","","Appends a transformation to this object.",84,null],[10,"append_transformation","","Appends the transformation `amount` to a copy of `t`.",84,null],[10,"prepend_transformation_mut","","Prepends a transformation to this object.",84,null],[10,"prepend_transformation","","Prepends the transformation `amount` to a copy of `t`.",84,null],[10,"set_transformation","","Sets the transformation of `self`.",84,null],[8,"Translate","","Trait of objects able to translate other objects. This is typically\nimplemented by vectors to translate points.",null,null],[10,"translate","","Apply a translation to an object.",85,null],[10,"inv_translate","","Apply an inverse translation to an object.",85,null],[8,"Translation","","Trait of object which represent a translation, and to wich new translation\ncan be appended.",null,null],[10,"translation","","Gets the translation associated with this object.",86,null],[10,"inv_translation","","Gets the inverse translation associated with this object.",86,null],[10,"append_translation_mut","","Appends a translation to this object.",86,null],[10,"append_translation","","Appends the translation `amount` to a copy of `t`.",86,null],[10,"prepend_translation_mut","","Prepends a translation to this object.",86,null],[10,"prepend_translation","","Prepends the translation `amount` to a copy of `t`.",86,null],[10,"set_translation","","Sets the translation.",86,null],[8,"Transpose","","Trait of objects which can be transposed.",null,null],[10,"transpose","","Computes the transpose of a matrix.",87,null],[10,"transpose_mut","","In-place version of `transposed`.",87,null],[8,"UniformSphereSample","","Trait of vectors able to sample a unit sphere.",null,null],[10,"sample","","Iterate through the samples.",88,{"inputs":[{"name":"f"}],"output":null}],[14,"assert_approx_eq_eps!","","Asserts approximate equality within a given tolerance of two values with the\n`ApproxEq` trait.",null,null],[14,"assert_approx_eq_ulps!","","Asserts approximate equality within a given tolerance of two values with the\n`ApproxEq` trait, with tolerance specified in ULPs.",null,null],[14,"assert_approx_eq!","","Asserts approximate equality of two values with the `ApproxEq` trait.",null,null],[11,"append_rotation_wrt_point","","Applies a rotation centered on a specific point.",78,null],[11,"append_rotation_wrt_point_mut","","Rotates `self` using a specific center of rotation.",78,null],[11,"append_rotation_wrt_center","","Applies a rotation centered on the translation of `m`.",78,null],[11,"append_rotation_wrt_center_mut","","Applies a rotation centered on the translation of `m`.",78,null],[11,"norm","","Computes the norm of `self`.",69,null],[11,"sqdist","","Computes the square distance between two points.",62,null],[11,"dist","","Computes the distance between two points.",62,null],[11,"partial_le","","Returns `true` iff `self` and `other` are comparable and `self &lt;= other`.",72,null],[11,"partial_lt","","Returns `true` iff `self` and `other` are comparable and `self &lt; other`.",72,null],[11,"partial_ge","","Returns `true` iff `self` and `other` are comparable and `self &gt;= other`.",72,null],[11,"partial_gt","","Returns `true` iff `self` and `other` are comparable and `self &gt; other`.",72,null],[11,"partial_min","","Return the minimum of `self` and `other` if they are comparable.",72,null],[11,"partial_max","","Return the maximum of `self` and `other` if they are comparable.",72,null],[11,"partial_clamp","","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to\n`min` or `max`.",72,null],[11,"approx_eq","","Tests approximate equality.",44,null],[11,"cov_to","","Computes the covariance of the obsevations stored by `m`:",53,null],[11,"norm","","Computes the norm of `self`.",69,null],[11,"append_rotation_wrt_point","","Applies a rotation centered on a specific point.",78,null],[11,"append_rotation_wrt_point_mut","","Rotates `self` using a specific center of rotation.",78,null],[11,"append_rotation_wrt_center","","Applies a rotation centered on the translation of `m`.",78,null],[11,"append_rotation_wrt_center_mut","","Applies a rotation centered on the translation of `m`.",78,null],[11,"sqdist","","Computes the square distance between two points.",62,null],[11,"dist","","Computes the distance between two points.",62,null],[11,"approx_eq","","Tests approximate equality.",44,null],[11,"cov_to","","Computes the covariance of the obsevations stored by `m`:",53,null],[11,"partial_le","","Returns `true` iff `self` and `other` are comparable and `self &lt;= other`.",72,null],[11,"partial_lt","","Returns `true` iff `self` and `other` are comparable and `self &lt; other`.",72,null],[11,"partial_ge","","Returns `true` iff `self` and `other` are comparable and `self &gt;= other`.",72,null],[11,"partial_gt","","Returns `true` iff `self` and `other` are comparable and `self &gt; other`.",72,null],[11,"partial_min","","Return the minimum of `self` and `other` if they are comparable.",72,null],[11,"partial_max","","Return the maximum of `self` and `other` if they are comparable.",72,null],[11,"partial_clamp","","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to\n`min` or `max`.",72,null]],"paths":[[3,"DVec"],[3,"Iso2"],[3,"Iso3"],[3,"Iso4"],[3,"Mat1"],[3,"Mat2"],[3,"Mat3"],[3,"Mat4"],[3,"Mat5"],[3,"Mat6"],[3,"Vec0"],[3,"Vec1"],[3,"Vec2"],[3,"Vec3"],[3,"Vec4"],[3,"Vec5"],[3,"Vec6"],[3,"Pnt0"],[3,"Pnt1"],[3,"Pnt2"],[3,"Pnt3"],[3,"Pnt4"],[3,"Pnt5"],[3,"Pnt6"],[3,"Quat"],[4,"POrdering"],[3,"DMat"],[3,"DVec1"],[3,"DVec2"],[3,"DVec3"],[3,"DVec4"],[3,"DVec5"],[3,"DVec6"],[3,"UnitQuat"],[3,"Identity"],[3,"Rot2"],[3,"Rot3"],[3,"Rot4"],[3,"Persp3"],[3,"PerspMat3"],[3,"Ortho3"],[3,"OrthoMat3"],[8,"Absolute"],[8,"AbsoluteRotate"],[8,"ApproxEq"],[8,"Axpy"],[8,"Basis"],[8,"BaseFloat"],[8,"Bounded"],[8,"Cast"],[8,"Col"],[8,"ColSlice"],[8,"RowSlice"],[8,"Cov"],[8,"Cross"],[8,"CrossMatrix"],[8,"Det"],[8,"Diag"],[8,"Dim"],[8,"Dot"],[8,"EigenQR"],[8,"Eye"],[8,"FloatPnt"],[8,"FromHomogeneous"],[8,"Indexable"],[8,"Inv"],[8,"Iterable"],[8,"IterableMut"],[8,"Mean"],[8,"Norm"],[8,"Orig"],[8,"Outer"],[8,"POrd"],[8,"PntAsVec"],[8,"Repeat"],[8,"Rotate"],[8,"Rotation"],[8,"RotationMatrix"],[8,"RotationWithTranslation"],[8,"RotationTo"],[8,"Row"],[8,"Shape"],[8,"ToHomogeneous"],[8,"Transform"],[8,"Transformation"],[8,"Translate"],[8,"Translation"],[8,"Transpose"],[8,"UniformSphereSample"]]};
searchIndex["rusty_machine"] = {"doc":"# The rusty-machine crate.","items":[[0,"prelude","rusty_machine","The rusty-machine prelude.",null,null],[3,"Matrix","rusty_machine::prelude","The `Matrix` struct.",null,null],[3,"MatrixSlice","","A `MatrixSlice`",null,null],[3,"MatrixSliceMut","","A mutable `MatrixSliceMut`",null,null],[3,"Vector","","The Vector struct.",null,null],[8,"BaseSlice","","Trait for Matrix Slices.",null,null],[10,"rows","","Rows in the slice.",0,null],[10,"cols","","Columns in the slice.",0,null],[10,"row_stride","","Row stride in the slice.",0,null],[10,"as_ptr","","Top left index of the slice.",0,null],[11,"get_unchecked","","Get a reference to a point in the slice without bounds checking.",0,null],[11,"get_row","","Returns the row of a `Matrix` at the given index.\n`None` if the index is out of bounds.",0,null],[11,"get_row_unchecked","","Returns the row of a `BaseSlice` at the given index without doing unbounds checking",0,null],[4,"Axes","","Matrix dimensions",null,null],[13,"Row","","The row axis.",1,null],[13,"Col","","The column axis.",1,null],[0,"linalg","rusty_machine","The linear algebra module",null,null],[4,"Axes","rusty_machine::linalg","Matrix dimensions",null,null],[13,"Row","","The row axis.",1,null],[13,"Col","","The column axis.",1,null],[3,"Matrix","","The `Matrix` struct.",null,null],[3,"MatrixSlice","","A `MatrixSlice`",null,null],[3,"MatrixSliceMut","","A mutable `MatrixSliceMut`",null,null],[8,"BaseSlice","","Trait for Matrix Slices.",null,null],[10,"rows","","Rows in the slice.",0,null],[10,"cols","","Columns in the slice.",0,null],[10,"row_stride","","Row stride in the slice.",0,null],[10,"as_ptr","","Top left index of the slice.",0,null],[11,"get_unchecked","","Get a reference to a point in the slice without bounds checking.",0,null],[11,"get_row","","Returns the row of a `Matrix` at the given index.\n`None` if the index is out of bounds.",0,null],[11,"get_row_unchecked","","Returns the row of a `BaseSlice` at the given index without doing unbounds checking",0,null],[3,"Vector","","The Vector struct.",null,null],[8,"Metric","","Trait for linear algebra metrics.",null,null],[10,"norm","","Computes the euclidean norm.",2,null],[0,"data","rusty_machine","Module for data handling",null,null],[0,"transforms","rusty_machine::data","The Transforms module",null,null],[0,"minmax","rusty_machine::data::transforms","The Min-Max transformer",null,null],[3,"MinMaxScaler","rusty_machine::data::transforms::minmax","The `MinMaxScaler`",null,null],[11,"fmt","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"minmaxscaler"}}],[11,"new","","Constructs a new MinMaxScaler with the specified scale.",3,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"minmaxscaler"}}],[11,"transform","","",3,null],[11,"inv_transform","","",3,null],[0,"standardize","rusty_machine::data::transforms","The Standardizing Transformer",null,null],[3,"Standardizer","rusty_machine::data::transforms::standardize","The Standardizer",null,null],[11,"fmt","","",4,null],[11,"default","","",4,{"inputs":[],"output":{"name":"standardizer"}}],[11,"new","","Constructs a new `Standardizer` with the given mean and variance",4,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"standardizer"}}],[11,"transform","","",4,null],[11,"inv_transform","","",4,null],[8,"Transformer","rusty_machine::data::transforms","Trait for data transformers",null,null],[10,"transform","","Transforms the inputs and stores the transformation in the Transformer",5,null],[10,"inv_transform","","Maps the inputs using the inverse of the fitted transform.",5,null],[0,"learning","rusty_machine","Module for machine learning.",null,null],[0,"dbscan","rusty_machine::learning","DBSCAN Clustering",null,null],[3,"DBSCAN","rusty_machine::learning::dbscan","DBSCAN Model",null,null],[11,"fmt","","",6,null],[11,"default","","",6,{"inputs":[],"output":{"name":"dbscan"}}],[11,"train","","Train the classifier using input data.",6,null],[11,"predict","","",6,null],[11,"new","","Create a new DBSCAN model with a given\ndistance episilon and minimum points per cluster.",6,{"inputs":[{"name":"f64"},{"name":"usize"}],"output":{"name":"dbscan"}}],[11,"set_predictive","","Set predictive to true if the model is to be used\nto classify future points.",6,null],[11,"clusters","","Return an Option pointing to the model clusters.",6,null],[0,"glm","rusty_machine::learning","Generalized Linear Model module",null,null],[3,"GenLinearModel","rusty_machine::learning::glm","The Generalized Linear Model",null,null],[3,"Logit","","The Logit link function.",null,null],[3,"Log","","The log link function.",null,null],[3,"Identity","","The Identity link function.",null,null],[3,"Bernoulli","","The Bernoulli regression family.",null,null],[3,"Binomial","","The Binomial regression family.",null,null],[3,"Normal","","The Normal regression family.",null,null],[3,"Poisson","","The Poisson regression family.",null,null],[8,"Criterion","","The criterion for the Generalized Linear Model.",null,null],[16,"Link","","The link function of the GLM Criterion.",7,null],[10,"model_variance","","The variance of the regression family.",7,null],[11,"initialize_mu","","Initializes the mean value.",7,null],[11,"compute_working_weight","","Computes the working weights that make up the diagonal\nof the `W` matrix used in the iterative reweighted least squares\nalgorithm.",7,null],[11,"compute_y_bar","","Computes the adjustment to the fitted values used during\nfitting.",7,null],[11,"apply_link_func","","Applies the link function to a vector.",7,null],[11,"apply_link_inv","","Applies the inverse of the link function to a vector.",7,null],[11,"link_grad","","Computes the gradient of the link function.",7,null],[8,"LinkFunc","","Link functions.",null,null],[10,"func","","The link function.",8,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[10,"func_grad","","The gradient of the link function.",8,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[10,"func_inv","","The inverse of the link function.\nOften called the &#39;mean&#39; function.",8,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"fmt","","",9,null],[11,"new","","Constructs a new Generalized Linear Model.",9,{"inputs":[{"name":"c"}],"output":{"name":"genlinearmodel"}}],[11,"predict","","Predict output from inputs.",9,null],[11,"train","","Train the model using inputs and targets.",9,null],[11,"fmt","","",10,null],[11,"clone","","",10,null],[11,"func","","",10,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_grad","","",10,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_inv","","",10,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"fmt","","",11,null],[11,"clone","","",11,null],[11,"func","","",11,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_grad","","",11,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_inv","","",11,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"fmt","","",12,null],[11,"clone","","",12,null],[11,"func","","",12,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_grad","","",12,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_inv","","",12,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"model_variance","","",13,null],[11,"initialize_mu","","",13,null],[11,"compute_working_weight","","",13,null],[11,"compute_y_bar","","",13,null],[11,"fmt","","",14,null],[11,"model_variance","","",14,null],[11,"initialize_mu","","",14,null],[11,"compute_working_weight","","",14,null],[11,"compute_y_bar","","",14,null],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"model_variance","","",15,null],[11,"fmt","","",16,null],[11,"clone","","",16,null],[11,"model_variance","","",16,null],[11,"initialize_mu","","",16,null],[11,"compute_working_weight","","",16,null],[0,"gmm","rusty_machine::learning","Gaussian Mixture Models",null,null],[3,"GaussianMixtureModel","rusty_machine::learning::gmm","A Gaussian Mixture Model",null,null],[12,"cov_option","","The covariance options for the GMM.",17,null],[4,"CovOption","","Covariance options for GMMs.",null,null],[13,"Full","","The full covariance structure.",18,null],[13,"Regularized","","Adds a regularization constant to the covariance diagonal.",18,null],[13,"Diagonal","","Only the diagonal covariance structure.",18,null],[11,"fmt","","",18,null],[11,"clone","","",18,null],[11,"fmt","","",17,null],[11,"train","","Train the model using inputs.",17,null],[11,"predict","","Predict output from inputs.",17,null],[11,"new","","Constructs a new Gaussian Mixture Model",17,{"inputs":[{"name":"usize"}],"output":{"name":"gaussianmixturemodel"}}],[11,"with_weights","","Constructs a new GMM with the specified prior mixture weights.",17,{"inputs":[{"name":"usize"},{"name":"vector"}],"output":{"name":"gaussianmixturemodel"}}],[11,"means","","The model means",17,null],[11,"covariances","","The model covariances",17,null],[11,"mixture_weights","","The model mixture weights",17,null],[11,"set_max_iters","","Sets the max number of iterations for the EM algorithm.",17,null],[0,"lin_reg","rusty_machine::learning","Linear Regression module",null,null],[3,"LinRegressor","rusty_machine::learning::lin_reg","Linear Regression Model.",null,null],[11,"fmt","","",19,null],[11,"default","","",19,{"inputs":[],"output":{"name":"linregressor"}}],[11,"parameters","","Get the parameters from the model.",19,null],[11,"train","","Train the linear regression model.",19,null],[11,"predict","","Predict output value from input data.",19,null],[11,"compute_grad","","",19,null],[11,"train_with_optimization","","Train the linear regressor using Gradient Descent.",19,null],[0,"logistic_reg","rusty_machine::learning","Logistic Regression module",null,null],[3,"LogisticRegressor","rusty_machine::learning::logistic_reg","Logistic Regression Model.",null,null],[3,"BaseLogisticRegressor","","The Base Logistic Regression model.",null,null],[11,"fmt","","",20,null],[11,"default","","",20,{"inputs":[],"output":{"name":"logisticregressor"}}],[11,"new","","Constructs untrained logistic regression model.",20,{"inputs":[{"name":"a"}],"output":{"name":"logisticregressor"}}],[11,"parameters","","Get the parameters from the model.",20,null],[11,"train","","Train the logistic regression model.",20,null],[11,"predict","","Predict output value from input data.",20,null],[11,"fmt","","",21,null],[11,"compute_grad","","",21,null],[0,"k_means","rusty_machine::learning","K-means Classification",null,null],[3,"KMeansClassifier","rusty_machine::learning::k_means","K-Means Classification model.",null,null],[3,"Forgy","","The Forgy initialization scheme.",null,null],[3,"RandomPartition","","The Random Partition initialization scheme.",null,null],[3,"KPlusPlus","","The K-means ++ initialization scheme.",null,null],[8,"Initializer","","Trait for algorithms initializing the K-means centroids.",null,null],[10,"init_centroids","","Initialize the centroids for the initial state of the K-Means model.",22,null],[11,"fmt","","",23,null],[11,"predict","","Predict classes from data.",23,null],[11,"train","","Train the classifier using input data.",23,null],[11,"new","","Constructs untrained k-means classifier model.",23,{"inputs":[{"name":"usize"}],"output":{"name":"kmeansclassifier"}}],[11,"new_specified","","Constructs untrained k-means classifier model.",23,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"initalg"}],"output":{"name":"kmeansclassifier"}}],[11,"k","","Get the number of classes.",23,null],[11,"iters","","Get the number of iterations.",23,null],[11,"init_algorithm","","Get the initialization algorithm.",23,null],[11,"centroids","","Get the centroids `Option&lt;Matrix&lt;f64&gt;&gt;`.",23,null],[11,"set_iters","","Set the number of iterations.",23,null],[11,"fmt","","",24,null],[11,"init_centroids","","",24,null],[11,"fmt","","",25,null],[11,"init_centroids","","",25,null],[11,"fmt","","",26,null],[11,"init_centroids","","",26,null],[0,"nnet","rusty_machine::learning","Neural Network module",null,null],[3,"NeuralNet","rusty_machine::learning::nnet","Neural Network Model",null,null],[3,"BaseNeuralNet","","Base Neural Network struct",null,null],[3,"BCECriterion","","The binary cross entropy criterion.",null,null],[3,"MSECriterion","","The mean squared error criterion.",null,null],[8,"Criterion","","Criterion for Neural Networks",null,null],[16,"ActFunc","","The activation function for the criterion.",27,null],[16,"Cost","","The cost function for the criterion.",27,null],[11,"activate","","The activation function applied to a matrix.",27,null],[11,"grad_activ","","The gradient of the activation function applied to a matrix.",27,null],[11,"cost","","The cost function.",27,null],[11,"cost_grad","","The gradient of the cost function.",27,null],[11,"regularization","","Returns the regularization for this criterion.",27,null],[11,"is_regularized","","Checks if the current criterion includes regularization.",27,null],[11,"reg_cost","","Returns the regularization cost for the criterion.",27,null],[11,"reg_cost_grad","","Returns the regularization gradient for the criterion.",27,null],[11,"fmt","","",28,null],[11,"predict","","Predict neural network output using forward propagation.",28,null],[11,"train","","Train the model using gradient optimization and back propagation.",28,null],[11,"default","","Creates a neural network with the specified layer sizes.",28,null],[11,"new","","Create a new neural network with the specified layer sizes.",28,null],[11,"get_net_weights","","Gets matrix of weights between specified layer and forward layer.",28,null],[11,"fmt","","",29,null],[11,"compute_grad","","Compute the gradient of the neural network.",29,null],[11,"fmt","","",30,null],[11,"clone","","",30,null],[11,"regularization","","",30,null],[11,"default","","",30,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Constructs a new BCECriterion with the given regularization.",30,{"inputs":[{"name":"regularization"}],"output":{"name":"self"}}],[11,"fmt","","",31,null],[11,"clone","","",31,null],[11,"regularization","","",31,null],[11,"default","","",31,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Constructs a new BCECriterion with the given regularization.",31,{"inputs":[{"name":"regularization"}],"output":{"name":"self"}}],[0,"gp","rusty_machine::learning","Gaussian Processes",null,null],[3,"ConstMean","rusty_machine::learning::gp","Constant mean function",null,null],[3,"GaussianProcess","","Gaussian Process struct",null,null],[12,"noise","","The observation noise of the GP.",32,null],[8,"MeanFunc","","Trait for GP mean functions.",null,null],[10,"func","","Compute the mean function applied elementwise to a matrix.",33,null],[11,"fmt","","",34,null],[11,"clone","","",34,null],[11,"default","","",34,{"inputs":[],"output":{"name":"constmean"}}],[11,"func","","",34,null],[11,"fmt","","",32,null],[11,"default","","",32,{"inputs":[],"output":{"name":"gaussianprocess"}}],[11,"new","","Construct a new Gaussian Process.",32,{"inputs":[{"name":"t"},{"name":"u"},{"name":"f64"}],"output":{"name":"gaussianprocess"}}],[11,"predict","","Predict output from inputs.",32,null],[11,"train","","Train the model using data and outputs.",32,null],[11,"get_posterior","","Compute the posterior distribution [UNSTABLE]",32,null],[0,"svm","rusty_machine::learning","Support Vector Machine Module",null,null],[3,"SVM","rusty_machine::learning::svm","Support Vector Machine",null,null],[12,"optim_iters","","Number of iterations for training.",35,null],[11,"fmt","","",35,null],[11,"default","","",35,{"inputs":[],"output":{"name":"svm"}}],[11,"new","","Constructs an untrained SVM with specified\nkernel and lambda which determins the hardness\nof the margin.",35,{"inputs":[{"name":"k"},{"name":"f64"}],"output":{"name":"svm"}}],[11,"predict","","",35,null],[11,"train","","",35,null],[0,"naive_bayes","rusty_machine::learning","Naive Bayes Classifiers",null,null],[3,"NaiveBayes","rusty_machine::learning::naive_bayes","The Naive Bayes model.",null,null],[3,"Gaussian","","The Gaussian Naive Bayes model distribution.",null,null],[3,"Bernoulli","","The Bernoulli Naive Bayes model distribution.",null,null],[3,"Multinomial","","The Multinomial Naive Bayes model distribution.",null,null],[8,"Distribution","","Naive Bayes Distribution.",null,null],[10,"from_model_params","","Initialize the distribution parameters.",36,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[10,"update_params","","Updates the distribution parameters.",36,null],[10,"joint_log_lik","","Compute the joint log likelihood of the data.",36,null],[11,"fmt","","",37,null],[11,"new","","Create a new NaiveBayes model from a given\ndistribution.",37,{"inputs":[],"output":{"name":"naivebayes"}}],[11,"cluster_count","","Get the cluster count for this model.",37,null],[11,"class_prior","","Get the class prior distribution for this model.",37,null],[11,"distr","","Get the distribution for this model.",37,null],[11,"train","","Train the model using inputs and targets.",37,null],[11,"predict","","Predict output from inputs.",37,null],[11,"get_log_probs","","Get the log-probabilities per class for each input.",37,null],[11,"fmt","","",38,null],[11,"theta","","Returns the distribution means.",38,null],[11,"sigma","","Returns the distribution variances.",38,null],[11,"from_model_params","","",38,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"gaussian"}}],[11,"update_params","","",38,null],[11,"joint_log_lik","","",38,null],[11,"fmt","","",39,null],[11,"log_probs","","The log probability matrix.",39,null],[11,"from_model_params","","",39,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"bernoulli"}}],[11,"update_params","","",39,null],[11,"joint_log_lik","","",39,null],[11,"fmt","","",40,null],[11,"log_probs","","The log probability matrix.",40,null],[11,"from_model_params","","",40,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"multinomial"}}],[11,"update_params","","",40,null],[11,"joint_log_lik","","",40,null],[0,"error","rusty_machine::learning","Error handling for the learning module.",null,null],[3,"Error","rusty_machine::learning::error","An error related to the learning module.",null,null],[4,"ErrorKind","","Types of errors produced in the learning module.",null,null],[13,"InvalidParameters","","The parameters used to define the model are not valid.",41,null],[13,"InvalidData","","The input data to the model is not valid.",41,null],[13,"InvalidState","","The action could not be carried out as the model was in an invalid state.",41,null],[11,"fmt","","",42,null],[11,"fmt","","",41,null],[11,"new","","Construct a new `Error` of a particular `ErrorKind`.",42,{"inputs":[{"name":"errorkind"},{"name":"e"}],"output":{"name":"error"}}],[11,"kind","","Get the kind of this `Error`.",42,null],[11,"description","","",42,null],[11,"fmt","","",42,null],[0,"optim","rusty_machine::learning","Module for optimization in machine learning setting.",null,null],[0,"grad_desc","rusty_machine::learning::optim","Gradient Descent",null,null],[3,"GradientDesc","rusty_machine::learning::optim::grad_desc","Batch Gradient Descent algorithm",null,null],[3,"StochasticGD","","Stochastic Gradient Descent algorithm.",null,null],[3,"AdaGrad","","Adaptive Gradient Descent",null,null],[11,"fmt","","",43,null],[11,"clone","","",43,null],[11,"default","","",43,{"inputs":[],"output":{"name":"gradientdesc"}}],[11,"new","","Construct a gradient descent algorithm.",43,{"inputs":[{"name":"f64"},{"name":"usize"}],"output":{"name":"gradientdesc"}}],[11,"optimize","","",43,null],[11,"fmt","","",44,null],[11,"clone","","",44,null],[11,"default","","",44,{"inputs":[],"output":{"name":"stochasticgd"}}],[11,"new","","Construct a stochastic gradient descent algorithm.",44,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"usize"}],"output":{"name":"stochasticgd"}}],[11,"optimize","","",44,null],[11,"fmt","","",45,null],[11,"new","","Constructs a new AdaGrad algorithm.",45,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"usize"}],"output":{"name":"adagrad"}}],[11,"default","","",45,{"inputs":[],"output":{"name":"adagrad"}}],[11,"optimize","","",45,null],[0,"fmincg","rusty_machine::learning::optim","Module for the fmincg optimization algorithm.",null,null],[3,"ConjugateGD","rusty_machine::learning::optim::fmincg","Conjugate Gradient Descent algorithm",null,null],[12,"rho","","Constant in the Wolfe-Powell conditions.",46,null],[12,"sig","","Constant in the Wolfe-Powell conditions.",46,null],[12,"int","","Don&#39;t reevaluate within `int` of the limit of the current bracket.",46,null],[12,"ext","","Extrapolate max of `ext` times the current bracket.",46,null],[12,"max","","Max of `max` function evaluations per line search",46,null],[12,"ratio","","The maximum allowed slope ratio",46,null],[12,"iters","","The default number of max iterations.",46,null],[11,"fmt","","",46,null],[11,"clone","","",46,null],[11,"default","","",46,{"inputs":[],"output":{"name":"conjugategd"}}],[11,"optimize","","",46,null],[8,"Optimizable","rusty_machine::learning::optim","Trait for models which can be gradient-optimized.",null,null],[16,"Inputs","","The input data type to the model.",47,null],[16,"Targets","","The target data type to the model.",47,null],[10,"compute_grad","","Compute the gradient for the model.",47,null],[8,"OptimAlgorithm","","Trait for optimization algorithms.",null,null],[10,"optimize","","Return the optimized parameter using gradient optimization.",48,null],[0,"toolkit","rusty_machine::learning","Module for learning tools.",null,null],[0,"activ_fn","rusty_machine::learning::toolkit","Activation Functions.",null,null],[3,"Sigmoid","rusty_machine::learning::toolkit::activ_fn","Sigmoid activation function.",null,null],[3,"Linear","","Linear activation function.",null,null],[3,"Exp","","Exponential activation function.",null,null],[8,"ActivationFunc","","Trait for activation functions in models.",null,null],[10,"func","","The activation function.",49,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[10,"func_grad","","The gradient of the activation function.",49,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[10,"func_inv","","The inverse of the activation function.",49,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"fmt","","",50,null],[11,"clone","","",50,null],[11,"func","","Sigmoid function.",50,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_grad","","Gradient of sigmoid function.",50,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_inv","","",50,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"fmt","","",51,null],[11,"clone","","",51,null],[11,"func","","",51,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_grad","","",51,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_inv","","",51,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"fmt","","",52,null],[11,"clone","","",52,null],[11,"func","","",52,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_grad","","",52,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[11,"func_inv","","",52,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[0,"kernel","rusty_machine::learning::toolkit","Module for kernels",null,null],[3,"KernelSum","rusty_machine::learning::toolkit::kernel","The sum of two kernels",null,null],[3,"KernelProd","","The pointwise product of two kernels",null,null],[3,"KernelArith","","A wrapper tuple struct used for kernel arithmetic",null,null],[12,"0","","",53,null],[3,"Linear","","The Linear Kernel",null,null],[12,"c","","Constant term added to inner product.",54,null],[3,"Polynomial","","The Polynomial Kernel",null,null],[12,"alpha","","Scaling of the inner product.",55,null],[12,"c","","Constant added to inner product.",55,null],[12,"d","","The power to raise the sum to.",55,null],[3,"SquaredExp","","Squared exponential kernel",null,null],[12,"ls","","The length scale of the kernel.",56,null],[12,"ampl","","The amplitude of the kernel.",56,null],[3,"Exponential","","The Exponential Kernel",null,null],[12,"ls","","The length scale of the kernel.",57,null],[12,"ampl","","The amplitude of the kernel.",57,null],[3,"HyperTan","","The Hyperbolic Tangent Kernel.",null,null],[12,"alpha","","The scaling of the inner product.",58,null],[12,"c","","The constant to add to the inner product.",58,null],[3,"Multiquadric","","The Multiquadric Kernel.",null,null],[12,"c","","Constant added to square of difference.",59,null],[3,"RationalQuadratic","","The Rational Quadratic Kernel.",null,null],[12,"alpha","","Controls inverse power and difference scale.",60,null],[12,"ls","","Length scale controls scale of difference.",60,null],[8,"Kernel","","The Kernel trait",null,null],[10,"kernel","","The kernel function.",61,null],[11,"fmt","","",62,null],[11,"kernel","","",62,null],[11,"fmt","","",63,null],[11,"kernel","","",63,null],[11,"fmt","","",53,null],[11,"add","","",53,null],[11,"mul","","",53,null],[11,"fmt","","",54,null],[11,"clone","","",54,null],[11,"new","","Constructs a new Linear Kernel.",54,{"inputs":[{"name":"f64"}],"output":{"name":"linear"}}],[11,"default","","",54,{"inputs":[],"output":{"name":"linear"}}],[11,"kernel","","",54,null],[11,"fmt","","",55,null],[11,"clone","","",55,null],[11,"new","","Constructs a new Polynomial Kernel.",55,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"polynomial"}}],[11,"default","","",55,{"inputs":[],"output":{"name":"polynomial"}}],[11,"kernel","","",55,null],[11,"fmt","","",56,null],[11,"clone","","",56,null],[11,"new","","Construct a new squared exponential kernel.",56,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"squaredexp"}}],[11,"default","","",56,{"inputs":[],"output":{"name":"squaredexp"}}],[11,"kernel","","The squared exponential kernel function.",56,null],[11,"fmt","","",57,null],[11,"clone","","",57,null],[11,"new","","Construct a new squared exponential kernel.",57,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"exponential"}}],[11,"default","","",57,{"inputs":[],"output":{"name":"exponential"}}],[11,"kernel","","The squared exponential kernel function.",57,null],[11,"fmt","","",58,null],[11,"clone","","",58,null],[11,"new","","Constructs a new Hyperbolic Tangent Kernel.",58,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"hypertan"}}],[11,"default","","",58,{"inputs":[],"output":{"name":"hypertan"}}],[11,"kernel","","",58,null],[11,"fmt","","",59,null],[11,"clone","","",59,null],[11,"new","","Constructs a new Multiquadric Kernel.",59,{"inputs":[{"name":"f64"}],"output":{"name":"multiquadric"}}],[11,"default","","",59,{"inputs":[],"output":{"name":"multiquadric"}}],[11,"kernel","","",59,null],[11,"fmt","","",60,null],[11,"clone","","",60,null],[11,"new","","Constructs a new Rational Quadratic Kernel.",60,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"rationalquadratic"}}],[11,"default","","",60,{"inputs":[],"output":{"name":"rationalquadratic"}}],[11,"kernel","","",60,null],[0,"cost_fn","rusty_machine::learning::toolkit","Cost Functions.",null,null],[3,"MeanSqError","rusty_machine::learning::toolkit::cost_fn","The mean squared error cost function.",null,null],[3,"CrossEntropyError","","The cross entropy error cost function.",null,null],[8,"CostFunc","","Trait for cost functions in models.",null,null],[10,"cost","","The cost function.",64,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"f64"}}],[10,"grad_cost","","The gradient of the cost function.",64,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[11,"fmt","","",65,null],[11,"clone","","",65,null],[11,"cost","","",65,{"inputs":[{"name":"matrix"},{"name":"matrix"}],"output":{"name":"f64"}}],[11,"grad_cost","","",65,{"inputs":[{"name":"matrix"},{"name":"matrix"}],"output":{"name":"matrix"}}],[11,"cost","","",65,{"inputs":[{"name":"vector"},{"name":"vector"}],"output":{"name":"f64"}}],[11,"grad_cost","","",65,{"inputs":[{"name":"vector"},{"name":"vector"}],"output":{"name":"vector"}}],[11,"fmt","","",66,null],[11,"clone","","",66,null],[11,"cost","","",66,{"inputs":[{"name":"matrix"},{"name":"matrix"}],"output":{"name":"f64"}}],[11,"grad_cost","","",66,{"inputs":[{"name":"matrix"},{"name":"matrix"}],"output":{"name":"matrix"}}],[11,"cost","","",66,{"inputs":[{"name":"vector"},{"name":"vector"}],"output":{"name":"f64"}}],[11,"grad_cost","","",66,{"inputs":[{"name":"vector"},{"name":"vector"}],"output":{"name":"vector"}}],[0,"rand_utils","rusty_machine::learning::toolkit","Utility functions for random functionality.",null,null],[5,"reservoir_sample","rusty_machine::learning::toolkit::rand_utils","```\nuse rusty_machine::learning::toolkit::rand_utils;",null,null],[5,"fisher_yates","","The inside out Fisher-Yates algorithm.",null,null],[5,"in_place_fisher_yates","","The in place Fisher-Yates shuffle.",null,null],[0,"regularization","rusty_machine::learning::toolkit","Regularization Module",null,null],[4,"Regularization","rusty_machine::learning::toolkit::regularization","Model Regularization",null,null],[13,"L1","","L1 Regularization",67,null],[13,"L2","","L2 Regularization",67,null],[13,"ElasticNet","","Elastic Net Regularization (L1 and L2)",67,null],[13,"None","","No Regularization",67,null],[11,"clone","","",67,null],[11,"fmt","","",67,null],[11,"reg_cost","","Compute the regularization addition to the cost.",67,null],[11,"reg_grad","","Compute the regularization addition to the gradient.",67,null],[8,"SupModel","rusty_machine::learning","Trait for supervised model.",null,null],[10,"predict","","Predict output from inputs.",68,null],[10,"train","","Train the model using inputs and targets.",68,null],[8,"UnSupModel","","Trait for unsupervised model.",null,null],[10,"predict","","Predict output from inputs.",69,null],[10,"train","","Train the model using inputs.",69,null],[11,"cholesky","rusty_machine::linalg","Cholesky decomposition",70,null],[11,"qr_decomp","","Compute the QR decomposition of the matrix.",70,null],[11,"bidiagonal_decomp","","Converts matrix to bidiagonal form",70,null],[11,"svd","","Singular Value Decomposition",70,null],[11,"upper_hessenberg","","Returns H, where H is the upper hessenberg form.",70,null],[11,"upper_hess_decomp","","Returns (U,H), where H is the upper hessenberg form\nand U is the unitary transform matrix.",70,null],[11,"eigenvalues","","Eigenvalues of a square matrix.",70,null],[11,"eigendecomp","","Eigendecomposition of a square matrix.",70,null],[11,"lup_decomp","","Computes L, U, and P for LUP decomposition.",70,null],[11,"iter_rows","","Iterate over the rows of the matrix.",70,null],[11,"iter_rows_mut","","Iterate over the mutable rows of the matrix.",70,null],[11,"new","","Constructor for Matrix struct.",70,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"u"}],"output":{"name":"matrix"}}],[11,"rows","","Returns the number of rows in the Matrix.",70,null],[11,"cols","","Returns the number of columns in the Matrix.",70,null],[11,"row_stride","","Returns the row-stride of the matrix. This is simply\nits column count.",70,null],[11,"data","","Returns a non-mutable reference to the underlying data.",70,null],[11,"mut_data","","Returns a mutable slice of the underlying data.",70,null],[11,"get_unchecked","","Get a reference to a point in the matrix without bounds checks.",70,null],[11,"get_unchecked_mut","","Get a mutable reference to a point in the matrix without bounds checks.",70,null],[11,"as_ptr","","Returns pointer to first element of underlying data.",70,null],[11,"into_vec","","Consumes the Matrix and returns the Vec of data.",70,null],[11,"split_at","","Split the matrix at the specified axis returning two `MatrixSlice`s.",70,null],[11,"split_at_mut","","Split the matrix at the specified axis returning two `MatrixSlice`s.",70,null],[11,"as_slice","","Returns a `MatrixSlice` over the whole matrix.",70,null],[11,"as_mut_slice","","Returns a mutable `MatrixSlice` over the whole matrix.",70,null],[11,"get_row","","Returns the row of a `Matrix` at the given index.\n`None` if the index is out of bounds.",70,null],[11,"get_row_unchecked","","Returns the row of a `Matrix` at the given index without doing unbounds checking",70,null],[11,"get_row_mut","","Returns a mutable reference to the row of a `Matrix` at the given index.\n`None` if the index is out of bounds.",70,null],[11,"get_row_unchecked_mut","","Returns a mutable reference to the row of a `Matrix` at the given index\nwithout doing unbounds checking",70,null],[11,"select_rows","","Select rows from matrix",70,null],[11,"select_cols","","Select columns from matrix",70,null],[11,"select","","Select block matrix from matrix",70,null],[11,"hcat","","Horizontally concatenates two matrices. With self on the left.",70,null],[11,"vcat","","Vertically concatenates two matrices. With self on top.",70,null],[11,"diag","","Extract the diagonal of the matrix",70,null],[11,"apply","","Applies a function to each element in the matrix.",70,null],[11,"transpose","","Tranposes the given matrix",70,null],[11,"zeros","","Constructs matrix of all zeros.",70,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"matrix"}}],[11,"from_diag","","Constructs matrix with given diagonal.",70,null],[11,"ones","","Constructs matrix of all ones.",70,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"matrix"}}],[11,"identity","","Constructs the identity matrix.",70,{"inputs":[{"name":"usize"}],"output":{"name":"matrix"}}],[11,"is_diag","","Checks if matrix is diagonal.",70,null],[11,"sum_rows","","The sum of the rows of the matrix.",70,null],[11,"sum_cols","","The sum of the columns of the matrix.",70,null],[11,"sum","","The sum of all elements in the matrix",70,null],[11,"elemul","","The elementwise product of two matrices.",70,null],[11,"elediv","","The elementwise division of two matrices.",70,null],[11,"mean","","The mean of the matrix along the specified axis.",70,null],[11,"variance","","The variance of the matrix along the specified axis.",70,null],[11,"solve_u_triangular","","Solves an upper triangular linear system.",70,null],[11,"solve_l_triangular","","Solves a lower triangular linear system.",70,null],[11,"solve","","Solves the equation `Ax = y`.",70,null],[11,"inverse","","Computes the inverse of the matrix.",70,null],[11,"det","","Computes the determinant of the matrix.",70,null],[11,"index","","",70,null],[11,"index","","",71,null],[11,"index","","",72,null],[11,"index_mut","","",72,null],[11,"index_mut","","",70,null],[11,"mul","","",71,null],[11,"mul","","",71,null],[11,"mul","","",72,null],[11,"mul","","",72,null],[11,"div","","",71,null],[11,"div","","",71,null],[11,"div","","",72,null],[11,"div","","",72,null],[11,"add","","",71,null],[11,"add","","",71,null],[11,"add","","",72,null],[11,"add","","",72,null],[11,"sub","","",71,null],[11,"sub","","",71,null],[11,"sub","","",72,null],[11,"sub","","",72,null],[11,"add","","",70,null],[11,"add","","",70,null],[11,"mul","","",70,null],[11,"mul","","",70,null],[11,"sub","","",70,null],[11,"sub","","",70,null],[11,"div","","",70,null],[11,"div","","",70,null],[11,"mul","","",70,null],[11,"mul","","",70,null],[11,"add","","",71,null],[11,"add","","",71,null],[11,"add","","",72,null],[11,"add","","",72,null],[11,"add","","",71,null],[11,"add","","",71,null],[11,"add","","",72,null],[11,"add","","",72,null],[11,"sub","","",71,null],[11,"sub","","",71,null],[11,"sub","","",72,null],[11,"sub","","",72,null],[11,"sub","","",71,null],[11,"sub","","",71,null],[11,"sub","","",72,null],[11,"sub","","",72,null],[11,"add","","",71,null],[11,"add","","",71,null],[11,"add","","",70,null],[11,"add","","",70,null],[11,"add","","",72,null],[11,"add","","",72,null],[11,"add","","",70,null],[11,"add","","",70,null],[11,"sub","","",71,null],[11,"sub","","",71,null],[11,"sub","","",70,null],[11,"sub","","",70,null],[11,"sub","","",72,null],[11,"sub","","",72,null],[11,"sub","","",70,null],[11,"sub","","",70,null],[11,"add","","",70,null],[11,"add","","",70,null],[11,"sub","","",70,null],[11,"sub","","",70,null],[11,"add_assign","","",70,null],[11,"add_assign","","",70,null],[11,"sub_assign","","",70,null],[11,"sub_assign","","",70,null],[11,"div_assign","","",70,null],[11,"div_assign","","",70,null],[11,"mul_assign","","",70,null],[11,"mul_assign","","",70,null],[11,"add_assign","","",72,null],[11,"add_assign","","",72,null],[11,"sub_assign","","",72,null],[11,"sub_assign","","",72,null],[11,"div_assign","","",72,null],[11,"div_assign","","",72,null],[11,"mul_assign","","",72,null],[11,"mul_assign","","",72,null],[11,"add_assign","","",70,null],[11,"add_assign","","",70,null],[11,"sub_assign","","",70,null],[11,"sub_assign","","",70,null],[11,"add_assign","","",72,null],[11,"add_assign","","",72,null],[11,"sub_assign","","",72,null],[11,"sub_assign","","",72,null],[11,"add_assign","","",72,null],[11,"add_assign","","",72,null],[11,"sub_assign","","",72,null],[11,"sub_assign","","",72,null],[11,"add_assign","","",72,null],[11,"add_assign","","",72,null],[11,"sub_assign","","",72,null],[11,"sub_assign","","",72,null],[11,"add_assign","","",70,null],[11,"add_assign","","",70,null],[11,"sub_assign","","",70,null],[11,"sub_assign","","",70,null],[11,"add_assign","","",70,null],[11,"add_assign","","",70,null],[11,"sub_assign","","",70,null],[11,"sub_assign","","",70,null],[11,"neg","","",71,null],[11,"neg","","",72,null],[11,"neg","","",70,null],[11,"mul","","",70,null],[11,"mul","","",70,null],[11,"mul","","",70,null],[11,"mul","","",70,null],[11,"mul","","",71,null],[11,"mul","","",71,null],[11,"mul","","",70,null],[11,"mul","","",70,null],[11,"mul","","",72,null],[11,"mul","","",72,null],[11,"mul","","",71,null],[11,"mul","","",71,null],[11,"mul","","",71,null],[11,"mul","","",71,null],[11,"mul","","",72,null],[11,"mul","","",72,null],[11,"mul","","",72,null],[11,"mul","","",72,null],[11,"iter_rows","","Iterate over the rows of the matrix slice.",71,null],[11,"iter_rows","","Iterate over the rows of the mutable matrix slice.",72,null],[11,"iter_rows_mut","","Iterate over the mutable rows of the matrix.",72,null],[11,"from_iter","","",70,{"inputs":[{"name":"i"}],"output":{"name":"matrix"}}],[11,"into_iter","","",71,null],[11,"into_iter","","",72,null],[11,"rows","","",71,null],[11,"cols","","",71,null],[11,"row_stride","","",71,null],[11,"as_ptr","","",71,null],[11,"rows","","",72,null],[11,"cols","","",72,null],[11,"row_stride","","",72,null],[11,"as_ptr","","",72,null],[11,"from_matrix","","Produce a matrix slice from a matrix",71,null],[11,"from_raw_parts","","Creates a matrix slice from raw parts.",71,null],[11,"reslice","","Produce a matrix slice from an existing matrix slice.",71,null],[11,"iter","","Returns an iterator over the matrix slice.",71,null],[11,"into_matrix","","Convert the matrix slice into a new Matrix.",71,null],[11,"from_matrix","","Produce a matrix slice from a matrix",72,null],[11,"from_raw_parts","","Creates a mutable matrix slice from raw parts.",72,null],[11,"reslice","","Produce a matrix slice from an existing matrix slice.",72,null],[11,"iter","","Returns an iterator over the matrix slice.",72,null],[11,"iter_mut","","Returns a mutable iterator over the matrix slice.",72,null],[11,"get_row_mut","","Returns a mutable reference to the row of a `MatrixSliceMut` at the given index.\n`None` if the index is out of bounds.",72,null],[11,"get_row_unchecked_mut","","Returns a mutable reference to the row of a `MatrixSliceMut` at the given index\nwithout doing unbounds checking",72,null],[11,"into_matrix","","Convert the matrix slice into a new Matrix.",72,null],[11,"set_to","","Sets the underlying matrix data to the target data.",72,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"hash","","",70,null],[11,"eq","","",70,null],[11,"ne","","",70,null],[11,"fmt","","",70,null],[11,"clone","","",71,null],[11,"fmt","","",71,null],[11,"fmt","","",72,null],[11,"clone","","Clones the Matrix.",70,null],[11,"norm","","Compute euclidean norm for matrix.",70,null],[11,"norm","","Compute euclidean norm for matrix.",71,null],[11,"norm","","Compute euclidean norm for matrix.",72,null],[11,"fmt","","Formats the Matrix for display.",70,null],[11,"from","","",70,{"inputs":[{"name":"vector"}],"output":{"name":"matrix"}}],[11,"from","","",70,{"inputs":[{"name":"matrixslice"}],"output":{"name":"matrix"}}],[11,"from","","",70,{"inputs":[{"name":"matrixslicemut"}],"output":{"name":"matrix"}}],[11,"hash","","",73,null],[11,"eq","","",73,null],[11,"ne","","",73,null],[11,"fmt","","",73,null],[11,"new","","Constructor for Vector struct.",73,{"inputs":[{"name":"u"}],"output":{"name":"vector"}}],[11,"size","","Returns the size of the Vector.",73,null],[11,"data","","Returns a non-mutable reference to the underlying data.",73,null],[11,"mut_data","","Returns a mutable slice of the underlying data.",73,null],[11,"into_vec","","Consumes the Vector and returns the Vec of data.",73,null],[11,"clone","","Clones the Vector.",73,null],[11,"apply","","Applies a function to each element in the vector.",73,null],[11,"argmax","","Find the argmax of the Vector.",73,null],[11,"argmin","","Find the argmin of the Vector.",73,null],[11,"select","","Select elements from the Vector and form a new Vector from them.",73,null],[11,"zeros","","Constructs Vector of all zeros.",73,{"inputs":[{"name":"usize"}],"output":{"name":"vector"}}],[11,"ones","","Constructs Vector of all ones.",73,{"inputs":[{"name":"usize"}],"output":{"name":"vector"}}],[11,"dot","","Compute dot product with specified Vector.",73,null],[11,"sum","","The sum of the vector.",73,null],[11,"elemul","","The elementwise product of two vectors.",73,null],[11,"elediv","","The elementwise division of two vectors.",73,null],[11,"mean","","The mean of the vector.",73,null],[11,"variance","","The variance of the vector.",73,null],[11,"mul","","",73,null],[11,"mul","","",73,null],[11,"div","","",73,null],[11,"div","","",73,null],[11,"add","","",73,null],[11,"add","","",73,null],[11,"add","","",73,null],[11,"add","","",73,null],[11,"sub","","",73,null],[11,"sub","","",73,null],[11,"sub","","",73,null],[11,"sub","","",73,null],[11,"neg","","",73,null],[11,"index","","",73,null],[11,"norm","","Compute euclidean norm for vector.",73,null],[11,"add_assign","","",73,null],[11,"add_assign","","",73,null],[11,"sub_assign","","",73,null],[11,"sub_assign","","",73,null],[11,"div_assign","","",73,null],[11,"div_assign","","",73,null],[11,"mul_assign","","",73,null],[11,"mul_assign","","",73,null],[11,"add_assign","","",73,null],[11,"add_assign","","",73,null],[11,"sub_assign","","",73,null],[11,"sub_assign","","",73,null]],"paths":[[8,"BaseSlice"],[4,"Axes"],[8,"Metric"],[3,"MinMaxScaler"],[3,"Standardizer"],[8,"Transformer"],[3,"DBSCAN"],[8,"Criterion"],[8,"LinkFunc"],[3,"GenLinearModel"],[3,"Logit"],[3,"Log"],[3,"Identity"],[3,"Bernoulli"],[3,"Binomial"],[3,"Normal"],[3,"Poisson"],[3,"GaussianMixtureModel"],[4,"CovOption"],[3,"LinRegressor"],[3,"LogisticRegressor"],[3,"BaseLogisticRegressor"],[8,"Initializer"],[3,"KMeansClassifier"],[3,"Forgy"],[3,"RandomPartition"],[3,"KPlusPlus"],[8,"Criterion"],[3,"NeuralNet"],[3,"BaseNeuralNet"],[3,"BCECriterion"],[3,"MSECriterion"],[3,"GaussianProcess"],[8,"MeanFunc"],[3,"ConstMean"],[3,"SVM"],[8,"Distribution"],[3,"NaiveBayes"],[3,"Gaussian"],[3,"Bernoulli"],[3,"Multinomial"],[4,"ErrorKind"],[3,"Error"],[3,"GradientDesc"],[3,"StochasticGD"],[3,"AdaGrad"],[3,"ConjugateGD"],[8,"Optimizable"],[8,"OptimAlgorithm"],[8,"ActivationFunc"],[3,"Sigmoid"],[3,"Linear"],[3,"Exp"],[3,"KernelArith"],[3,"Linear"],[3,"Polynomial"],[3,"SquaredExp"],[3,"Exponential"],[3,"HyperTan"],[3,"Multiquadric"],[3,"RationalQuadratic"],[8,"Kernel"],[3,"KernelSum"],[3,"KernelProd"],[8,"CostFunc"],[3,"MeanSqError"],[3,"CrossEntropyError"],[4,"Regularization"],[8,"SupModel"],[8,"UnSupModel"],[3,"Matrix"],[3,"MatrixSlice"],[3,"MatrixSliceMut"],[3,"Vector"]]};
searchIndex["rulinalg"] = {"doc":"# The rulinalg crate.","items":[[0,"matrix","rulinalg","The matrix module.",null,null],[3,"Matrix","rulinalg::matrix","The `Matrix` struct.",null,null],[3,"MatrixSlice","","A `MatrixSlice`",null,null],[3,"MatrixSliceMut","","A mutable `MatrixSliceMut`",null,null],[4,"Axes","","Matrix dimensions",null,null],[13,"Row","","The row axis.",0,null],[13,"Col","","The column axis.",0,null],[11,"cholesky","","Cholesky decomposition",1,null],[11,"qr_decomp","","Compute the QR decomposition of the matrix.",1,null],[11,"bidiagonal_decomp","","Converts matrix to bidiagonal form",1,null],[11,"svd","","Singular Value Decomposition",1,null],[11,"upper_hessenberg","","Returns H, where H is the upper hessenberg form.",1,null],[11,"upper_hess_decomp","","Returns (U,H), where H is the upper hessenberg form\nand U is the unitary transform matrix.",1,null],[11,"eigenvalues","","Eigenvalues of a square matrix.",1,null],[11,"eigendecomp","","Eigendecomposition of a square matrix.",1,null],[11,"lup_decomp","","Computes L, U, and P for LUP decomposition.",1,null],[11,"index","","",1,null],[11,"index","","",2,null],[11,"index","","",3,null],[11,"index_mut","","",3,null],[11,"index_mut","","",1,null],[11,"mul","","",2,null],[11,"mul","","",2,null],[11,"mul","","",3,null],[11,"mul","","",3,null],[11,"div","","",2,null],[11,"div","","",2,null],[11,"div","","",3,null],[11,"div","","",3,null],[11,"add","","",2,null],[11,"add","","",2,null],[11,"add","","",3,null],[11,"add","","",3,null],[11,"sub","","",2,null],[11,"sub","","",2,null],[11,"sub","","",3,null],[11,"sub","","",3,null],[11,"add","","",1,null],[11,"add","","",1,null],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"sub","","",1,null],[11,"sub","","",1,null],[11,"div","","",1,null],[11,"div","","",1,null],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"add","","",2,null],[11,"add","","",2,null],[11,"add","","",3,null],[11,"add","","",3,null],[11,"add","","",2,null],[11,"add","","",2,null],[11,"add","","",3,null],[11,"add","","",3,null],[11,"sub","","",2,null],[11,"sub","","",2,null],[11,"sub","","",3,null],[11,"sub","","",3,null],[11,"sub","","",2,null],[11,"sub","","",2,null],[11,"sub","","",3,null],[11,"sub","","",3,null],[11,"add","","",2,null],[11,"add","","",2,null],[11,"add","","",1,null],[11,"add","","",1,null],[11,"add","","",3,null],[11,"add","","",3,null],[11,"add","","",1,null],[11,"add","","",1,null],[11,"sub","","",2,null],[11,"sub","","",2,null],[11,"sub","","",1,null],[11,"sub","","",1,null],[11,"sub","","",3,null],[11,"sub","","",3,null],[11,"sub","","",1,null],[11,"sub","","",1,null],[11,"add","","",1,null],[11,"add","","",1,null],[11,"sub","","",1,null],[11,"sub","","",1,null],[11,"add_assign","","",1,null],[11,"add_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"div_assign","","",1,null],[11,"div_assign","","",1,null],[11,"mul_assign","","",1,null],[11,"mul_assign","","",1,null],[11,"add_assign","","",3,null],[11,"add_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"div_assign","","",3,null],[11,"div_assign","","",3,null],[11,"mul_assign","","",3,null],[11,"mul_assign","","",3,null],[11,"add_assign","","",1,null],[11,"add_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"add_assign","","",3,null],[11,"add_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"add_assign","","",3,null],[11,"add_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"add_assign","","",3,null],[11,"add_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"add_assign","","",1,null],[11,"add_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"add_assign","","",1,null],[11,"add_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"neg","","",2,null],[11,"neg","","",3,null],[11,"neg","","",1,null],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"mul","","",2,null],[11,"mul","","",2,null],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"mul","","",3,null],[11,"mul","","",3,null],[11,"mul","","",2,null],[11,"mul","","",2,null],[11,"mul","","",2,null],[11,"mul","","",2,null],[11,"mul","","",3,null],[11,"mul","","",3,null],[11,"mul","","",3,null],[11,"mul","","",3,null],[11,"iter_rows","","Iterate over the rows of the matrix.",1,null],[11,"iter_rows_mut","","Iterate over the mutable rows of the matrix.",1,null],[11,"iter_rows","","Iterate over the rows of the matrix slice.",2,null],[11,"iter_rows","","Iterate over the rows of the mutable matrix slice.",3,null],[11,"iter_rows_mut","","Iterate over the mutable rows of the matrix.",3,null],[11,"from_iter","","",1,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"into_iter","","",2,null],[11,"into_iter","","",3,null],[0,"slice","","Slices for the `Matrix` struct.",null,null],[3,"SliceIter","rulinalg::matrix::slice","Iterator for `MatrixSlice`",null,null],[3,"SliceIterMut","","Iterator for `MatrixSliceMut`.",null,null],[8,"BaseSlice","","Trait for Matrix Slices.",null,null],[10,"rows","","Rows in the slice.",4,null],[10,"cols","","Columns in the slice.",4,null],[10,"row_stride","","Row stride in the slice.",4,null],[10,"as_ptr","","Top left index of the slice.",4,null],[11,"get_unchecked","","Get a reference to a point in the slice without bounds checking.",4,null],[11,"get_row","","Returns the row of a `Matrix` at the given index.\n`None` if the index is out of bounds.",4,null],[11,"get_row_unchecked","","Returns the row of a `BaseSlice` at the given index without doing unbounds checking",4,null],[11,"rows","rulinalg::matrix","",2,null],[11,"cols","","",2,null],[11,"row_stride","","",2,null],[11,"as_ptr","","",2,null],[11,"rows","","",3,null],[11,"cols","","",3,null],[11,"row_stride","","",3,null],[11,"as_ptr","","",3,null],[11,"from_matrix","","Produce a matrix slice from a matrix",2,null],[11,"from_raw_parts","","Creates a matrix slice from raw parts.",2,null],[11,"reslice","","Produce a matrix slice from an existing matrix slice.",2,null],[11,"iter","","Returns an iterator over the matrix slice.",2,null],[11,"into_matrix","","Convert the matrix slice into a new Matrix.",2,null],[11,"from_matrix","","Produce a matrix slice from a matrix",3,null],[11,"from_raw_parts","","Creates a mutable matrix slice from raw parts.",3,null],[11,"reslice","","Produce a matrix slice from an existing matrix slice.",3,null],[11,"iter","","Returns an iterator over the matrix slice.",3,null],[11,"iter_mut","","Returns a mutable iterator over the matrix slice.",3,null],[11,"get_row_mut","","Returns a mutable reference to the row of a `MatrixSliceMut` at the given index.\n`None` if the index is out of bounds.",3,null],[11,"get_row_unchecked_mut","","Returns a mutable reference to the row of a `MatrixSliceMut` at the given index\nwithout doing unbounds checking",3,null],[11,"into_matrix","","Convert the matrix slice into a new Matrix.",3,null],[11,"set_to","","Sets the underlying matrix data to the target data.",3,null],[11,"fmt","rulinalg::matrix::slice","",5,null],[11,"fmt","","",6,null],[11,"next","","",5,null],[11,"next","","",6,null],[11,"clone","rulinalg::matrix","",0,null],[11,"fmt","","",0,null],[11,"hash","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"fmt","","",3,null],[11,"new","","Constructor for Matrix struct.",1,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"u"}],"output":{"name":"matrix"}}],[11,"rows","","Returns the number of rows in the Matrix.",1,null],[11,"cols","","Returns the number of columns in the Matrix.",1,null],[11,"row_stride","","Returns the row-stride of the matrix. This is simply\nits column count.",1,null],[11,"data","","Returns a non-mutable reference to the underlying data.",1,null],[11,"mut_data","","Returns a mutable slice of the underlying data.",1,null],[11,"get_unchecked","","Get a reference to a point in the matrix without bounds checks.",1,null],[11,"get_unchecked_mut","","Get a mutable reference to a point in the matrix without bounds checks.",1,null],[11,"as_ptr","","Returns pointer to first element of underlying data.",1,null],[11,"into_vec","","Consumes the Matrix and returns the Vec of data.",1,null],[11,"split_at","","Split the matrix at the specified axis returning two `MatrixSlice`s.",1,null],[11,"split_at_mut","","Split the matrix at the specified axis returning two `MatrixSlice`s.",1,null],[11,"as_slice","","Returns a `MatrixSlice` over the whole matrix.",1,null],[11,"as_mut_slice","","Returns a mutable `MatrixSlice` over the whole matrix.",1,null],[11,"get_row","","Returns the row of a `Matrix` at the given index.\n`None` if the index is out of bounds.",1,null],[11,"get_row_unchecked","","Returns the row of a `Matrix` at the given index without doing unbounds checking",1,null],[11,"get_row_mut","","Returns a mutable reference to the row of a `Matrix` at the given index.\n`None` if the index is out of bounds.",1,null],[11,"get_row_unchecked_mut","","Returns a mutable reference to the row of a `Matrix` at the given index\nwithout doing unbounds checking",1,null],[11,"clone","","Clones the Matrix.",1,null],[11,"select_rows","","Select rows from matrix",1,null],[11,"select_cols","","Select columns from matrix",1,null],[11,"select","","Select block matrix from matrix",1,null],[11,"hcat","","Horizontally concatenates two matrices. With self on the left.",1,null],[11,"vcat","","Vertically concatenates two matrices. With self on top.",1,null],[11,"diag","","Extract the diagonal of the matrix",1,null],[11,"apply","","Applies a function to each element in the matrix.",1,null],[11,"transpose","","Tranposes the given matrix",1,null],[11,"zeros","","Constructs matrix of all zeros.",1,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"matrix"}}],[11,"from_diag","","Constructs matrix with given diagonal.",1,null],[11,"ones","","Constructs matrix of all ones.",1,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"matrix"}}],[11,"identity","","Constructs the identity matrix.",1,{"inputs":[{"name":"usize"}],"output":{"name":"matrix"}}],[11,"is_diag","","Checks if matrix is diagonal.",1,null],[11,"sum_rows","","The sum of the rows of the matrix.",1,null],[11,"sum_cols","","The sum of the columns of the matrix.",1,null],[11,"sum","","The sum of all elements in the matrix",1,null],[11,"elemul","","The elementwise product of two matrices.",1,null],[11,"elediv","","The elementwise division of two matrices.",1,null],[11,"mean","","The mean of the matrix along the specified axis.",1,null],[11,"variance","","The variance of the matrix along the specified axis.",1,null],[11,"solve_u_triangular","","Solves an upper triangular linear system.",1,null],[11,"solve_l_triangular","","Solves a lower triangular linear system.",1,null],[11,"solve","","Solves the equation `Ax = y`.",1,null],[11,"inverse","","Computes the inverse of the matrix.",1,null],[11,"det","","Computes the determinant of the matrix.",1,null],[11,"norm","","Compute euclidean norm for matrix.",1,null],[11,"norm","","Compute euclidean norm for matrix.",2,null],[11,"norm","","Compute euclidean norm for matrix.",3,null],[11,"fmt","","Formats the Matrix for display.",1,null],[0,"convert","rulinalg","The convert module.",null,null],[11,"from","rulinalg::matrix","",1,{"inputs":[{"name":"vector"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"matrixslice"}],"output":{"name":"self"}}],[11,"from","","",1,{"inputs":[{"name":"matrixslicemut"}],"output":{"name":"self"}}],[0,"macros","rulinalg","Macros for the linear algebra modules.",null,null],[0,"error","","Error handling for the linalg module.",null,null],[3,"Error","rulinalg::error","An error related to the linalg module.",null,null],[4,"ErrorKind","","Types of errors produced in the linalg module.",null,null],[13,"InvalidArg","","An argument did not uphold a necessary criteria for the function.",7,null],[13,"DecompFailure","","A failure to decompose due to some property of the data.",7,null],[13,"AlgebraFailure","","A failure due to some algebraic constraints not being met.",7,null],[11,"fmt","","",8,null],[11,"fmt","","",7,null],[11,"new","","Construct a new `Error` of a particular `ErrorKind`.",8,{"inputs":[{"name":"errorkind"},{"name":"e"}],"output":{"name":"error"}}],[11,"kind","","Get the kind of this `Error`.",8,null],[11,"description","","",8,null],[11,"fmt","","",8,null],[0,"utils","rulinalg","Linear algebra utils module.",null,null],[5,"dot","rulinalg::utils","Compute dot product of two slices.",null,null],[5,"unrolled_sum","","Unrolled sum",null,null],[5,"in_place_vec_bin_op","","Vectorized binary operation applied to two slices.\nThe first argument should be a mutable slice which will\nbe modified in place to prevent new memory allocation.",null,null],[5,"vec_bin_op","","Vectorized binary operation applied to two slices.",null,null],[5,"vec_sum","","Compute vector sum of two slices.",null,null],[5,"vec_sub","","Compute vector difference two slices.",null,null],[5,"ele_mul","","Computes elementwise multiplication.",null,null],[5,"ele_div","","Computes elementwise division.",null,null],[5,"argmax","","Find argmax of slice.",null,null],[5,"argmin","","Find argmin of slice.",null,null],[5,"find","","Find index of value in slice.",null,null],[0,"vector","rulinalg","The vector module.",null,null],[3,"Vector","rulinalg::vector","The Vector struct.",null,null],[11,"hash","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"fmt","","",9,null],[11,"new","","Constructor for Vector struct.",9,{"inputs":[{"name":"u"}],"output":{"name":"vector"}}],[11,"size","","Returns the size of the Vector.",9,null],[11,"data","","Returns a non-mutable reference to the underlying data.",9,null],[11,"mut_data","","Returns a mutable slice of the underlying data.",9,null],[11,"into_vec","","Consumes the Vector and returns the Vec of data.",9,null],[11,"clone","","Clones the Vector.",9,null],[11,"apply","","Applies a function to each element in the vector.",9,null],[11,"argmax","","Find the argmax of the Vector.",9,null],[11,"argmin","","Find the argmin of the Vector.",9,null],[11,"select","","Select elements from the Vector and form a new Vector from them.",9,null],[11,"zeros","","Constructs Vector of all zeros.",9,{"inputs":[{"name":"usize"}],"output":{"name":"vector"}}],[11,"ones","","Constructs Vector of all ones.",9,{"inputs":[{"name":"usize"}],"output":{"name":"vector"}}],[11,"dot","","Compute dot product with specified Vector.",9,null],[11,"sum","","The sum of the vector.",9,null],[11,"elemul","","The elementwise product of two vectors.",9,null],[11,"elediv","","The elementwise division of two vectors.",9,null],[11,"mean","","The mean of the vector.",9,null],[11,"variance","","The variance of the vector.",9,null],[11,"mul","","",9,null],[11,"mul","","",9,null],[11,"div","","",9,null],[11,"div","","",9,null],[11,"add","","",9,null],[11,"add","","",9,null],[11,"add","","",9,null],[11,"add","","",9,null],[11,"sub","","",9,null],[11,"sub","","",9,null],[11,"sub","","",9,null],[11,"sub","","",9,null],[11,"neg","","",9,null],[11,"index","","",9,null],[11,"norm","","Compute euclidean norm for vector.",9,null],[11,"add_assign","","",9,null],[11,"add_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"div_assign","","",9,null],[11,"div_assign","","",9,null],[11,"mul_assign","","",9,null],[11,"mul_assign","","",9,null],[11,"add_assign","","",9,null],[11,"add_assign","","",9,null],[11,"sub_assign","","",9,null],[11,"sub_assign","","",9,null],[8,"Metric","rulinalg","Trait for linear algebra metrics.",null,null],[10,"norm","","Computes the euclidean norm.",10,null]],"paths":[[4,"Axes"],[3,"Matrix"],[3,"MatrixSlice"],[3,"MatrixSliceMut"],[8,"BaseSlice"],[3,"SliceIter"],[3,"SliceIterMut"],[4,"ErrorKind"],[3,"Error"],[3,"Vector"],[8,"Metric"]]};
searchIndex["num"] = {"doc":"A collection of numeric types and traits for Rust.","items":[[3,"BigInt","num","A big signed integer type.",null,null],[3,"BigUint","","A big unsigned integer type.",null,null],[6,"Rational","","",null,null],[6,"BigRational","","",null,null],[3,"Complex","","A complex number in Cartesian form.",null,null],[12,"re","","Real portion of the complex number",0,null],[12,"im","","Imaginary portion of the complex number",0,null],[8,"Integer","","",null,null],[10,"div_floor","","Floored integer division.",1,null],[10,"mod_floor","","Floored integer modulo, satisfying:",1,null],[10,"gcd","","Greatest Common Divisor (GCD).",1,null],[10,"lcm","","Lowest Common Multiple (LCM).",1,null],[10,"divides","","Deprecated, use `is_multiple_of` instead.",1,null],[10,"is_multiple_of","","Returns `true` if `other` is a multiple of `self`.",1,null],[10,"is_even","","Returns `true` if the number is even.",1,null],[10,"is_odd","","Returns `true` if the number is odd.",1,null],[10,"div_rem","","Simultaneous truncated integer division and modulus.\nReturns `(quotient, remainder)`.",1,null],[11,"div_mod_floor","","Simultaneous floored integer division and modulus.\nReturns `(quotient, remainder)`.",1,null],[5,"range","","Returns an iterator over the given range [start, stop) (that is, starting\nat start (inclusive), and ending at stop (exclusive)).",null,{"inputs":[{"name":"a"},{"name":"a"}],"output":{"name":"range"}}],[5,"range_inclusive","","Return an iterator over the range [start, stop]",null,{"inputs":[{"name":"a"},{"name":"a"}],"output":{"name":"rangeinclusive"}}],[5,"range_step","","Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.",null,{"inputs":[{"name":"a"},{"name":"a"},{"name":"a"}],"output":{"name":"rangestep"}}],[5,"range_step_inclusive","","Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.",null,{"inputs":[{"name":"a"},{"name":"a"},{"name":"a"}],"output":{"name":"rangestepinclusive"}}],[8,"Num","","The base trait for numeric types",null,null],[16,"FromStrRadixErr","","",2,null],[10,"from_str_radix","","Convert from a string and radix &lt;= 36.",2,{"inputs":[{"name":"str"},{"name":"u32"}],"output":{"name":"result"}}],[8,"Zero","","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`.",3,{"inputs":[],"output":{"name":"self"}}],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",3,null],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",4,{"inputs":[],"output":{"name":"self"}}],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative).",null,null],[10,"abs","","Computes the absolute value.",5,null],[10,"abs_sub","","The positive difference of two numbers.",5,null],[10,"signum","","Returns the sign of the number.",5,null],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",5,null],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",5,null],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[8,"Bounded","","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",6,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","returns the largest finite number this type can represent",6,{"inputs":[],"output":{"name":"self"}}],[5,"one","","Returns the multiplicative identity, `1`.",null,{"inputs":[],"output":{"name":"t"}}],[5,"zero","","Returns the additive identity, `0`.",null,{"inputs":[],"output":{"name":"t"}}],[5,"abs","","Computes the absolute value.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"abs_sub","","The positive difference of two numbers.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"signum","","Returns the sign of the number.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[8,"Saturating","","Saturating math operations",null,null],[10,"saturating_add","","Saturating addition operator.\nReturns a+b, saturating at the numeric bounds instead of overflowing.",7,null],[10,"saturating_sub","","Saturating subtraction operator.\nReturns a-b, saturating at the numeric bounds instead of overflowing.",7,null],[8,"CheckedAdd","","Performs addition that returns `None` instead of wrapping around on\noverflow.",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is\nreturned.",8,null],[8,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow.",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens,\n`None` is returned.",9,null],[8,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or\noverflow.",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow\nor overflow happens, `None` is returned.",10,null],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of\nwrapping around on underflow and overflow.",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and division by\nzero. If any of that happens, `None` is returned.",11,null],[8,"PrimInt","","",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",12,null],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",12,null],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation\nof `self`.",12,null],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation\nof `self`.",12,null],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping\nthe truncated bits to the end of the resulting integer.",12,null],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping\nthe truncated bits to the beginning of the resulting integer.",12,null],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling\nzeros in the least significant bits.",12,null],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount, `n`, copying\nthe &quot;sign bit&quot; in the most significant bits even for unsigned types.",12,null],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling\nzeros in the least significant bits.",12,null],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount, `n`, filling\nzeros in the most significant bits.",12,null],[10,"swap_bytes","","Reverses the byte order of the integer.",12,null],[10,"from_be","","Convert an integer from big endian to the target&#39;s endianness.",12,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"from_le","","Convert an integer from little endian to the target&#39;s endianness.",12,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"to_be","","Convert `self` to big endian from the target&#39;s endianness.",12,null],[10,"to_le","","Convert `self` to little endian from the target&#39;s endianness.",12,null],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",12,null],[8,"Float","","",null,null],[10,"nan","","Returns the `NaN` value.",13,{"inputs":[],"output":{"name":"self"}}],[10,"infinity","","Returns the infinite value.",13,{"inputs":[],"output":{"name":"self"}}],[10,"neg_infinity","","Returns the negative infinite value.",13,{"inputs":[],"output":{"name":"self"}}],[10,"neg_zero","","Returns `-0.0`.",13,{"inputs":[],"output":{"name":"self"}}],[10,"min_value","","Returns the smallest finite value that this type can represent.",13,{"inputs":[],"output":{"name":"self"}}],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",13,{"inputs":[],"output":{"name":"self"}}],[11,"epsilon","","Returns epsilon, a small positive value.",13,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","Returns the largest finite value that this type can represent.",13,{"inputs":[],"output":{"name":"self"}}],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",13,null],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and\nfalse otherwise.",13,null],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",13,null],[10,"is_normal","","Returns `true` if the number is neither zero, infinite,\n[subnormal][subnormal], or `NaN`.",13,null],[10,"classify","","Returns the floating point category of the number. If only one property\nis going to be tested, it is generally faster to use the specific\npredicate instead.",13,null],[10,"floor","","Returns the largest integer less than or equal to a number.",13,null],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",13,null],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from\n`0.0`.",13,null],[10,"trunc","","Return the integer part of a number.",13,null],[10,"fract","","Returns the fractional part of a number.",13,null],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the\nnumber is `Float::nan()`.",13,null],[10,"signum","","Returns a number that represents the sign of `self`.",13,null],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and\n`Float::infinity()`.",13,null],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and\n`Float::neg_infinity()`.",13,null],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding\nerror. This produces a more accurate result with better performance than\na separate multiplication operation followed by an add.",13,null],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",13,null],[10,"powi","","Raise a number to an integer power.",13,null],[10,"powf","","Raise a number to a floating point power.",13,null],[10,"sqrt","","Take the square root of a number.",13,null],[10,"exp","","Returns `e^(self)`, (the exponential function).",13,null],[10,"exp2","","Returns `2^(self)`.",13,null],[10,"ln","","Returns the natural logarithm of the number.",13,null],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",13,null],[10,"log2","","Returns the base 2 logarithm of the number.",13,null],[10,"log10","","Returns the base 10 logarithm of the number.",13,null],[11,"to_degrees","","Converts radians to degrees.",13,null],[11,"to_radians","","Converts degrees to radians.",13,null],[10,"max","","Returns the maximum of the two numbers.",13,null],[10,"min","","Returns the minimum of the two numbers.",13,null],[10,"abs_sub","","The positive difference of two numbers.",13,null],[10,"cbrt","","Take the cubic root of a number.",13,null],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given\nlegs of length `x` and `y`.",13,null],[10,"sin","","Computes the sine of a number (in radians).",13,null],[10,"cos","","Computes the cosine of a number (in radians).",13,null],[10,"tan","","Computes the tangent of a number (in radians).",13,null],[10,"asin","","Computes the arcsine of a number. Return value is in radians in\nthe range [-pi/2, pi/2] or NaN if the number is outside the range\n[-1, 1].",13,null],[10,"acos","","Computes the arccosine of a number. Return value is in radians in\nthe range [0, pi] or NaN if the number is outside the range\n[-1, 1].",13,null],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the\nrange [-pi/2, pi/2];",13,null],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",13,null],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns\n`(sin(x), cos(x))`.",13,null],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the\nnumber is close to zero.",13,null],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if\nthe operations were performed separately.",13,null],[10,"sinh","","Hyperbolic sine function.",13,null],[10,"cosh","","Hyperbolic cosine function.",13,null],[10,"tanh","","Hyperbolic tangent function.",13,null],[10,"asinh","","Inverse hyperbolic sine function.",13,null],[10,"acosh","","Inverse hyperbolic cosine function.",13,null],[10,"atanh","","Inverse hyperbolic tangent function.",13,null],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively.\nThe original number can be recovered by `sign * mantissa * 2 ^ exponent`.\nThe floating point encoding is documented in the [Reference][floating-point].",13,null],[8,"ToPrimitive","","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`.",14,null],[11,"to_i8","","Converts the value of `self` to an `i8`.",14,null],[11,"to_i16","","Converts the value of `self` to an `i16`.",14,null],[11,"to_i32","","Converts the value of `self` to an `i32`.",14,null],[10,"to_i64","","Converts the value of `self` to an `i64`.",14,null],[11,"to_usize","","Converts the value of `self` to a `usize`.",14,null],[11,"to_u8","","Converts the value of `self` to an `u8`.",14,null],[11,"to_u16","","Converts the value of `self` to an `u16`.",14,null],[11,"to_u32","","Converts the value of `self` to an `u32`.",14,null],[10,"to_u64","","Converts the value of `self` to an `u64`.",14,null],[11,"to_f32","","Converts the value of `self` to an `f32`.",14,null],[11,"to_f64","","Converts the value of `self` to an `f64`.",14,null],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the\nvalue cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"isize"}],"output":{"name":"option"}}],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"i8"}],"output":{"name":"option"}}],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"i16"}],"output":{"name":"option"}}],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"i32"}],"output":{"name":"option"}}],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"i64"}],"output":{"name":"option"}}],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"f32"}],"output":{"name":"option"}}],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"f64"}],"output":{"name":"option"}}],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted into\na primitive via the `ToPrimitive` trait.",16,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[0,"cast","","",null,null],[8,"ToPrimitive","num::cast","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`.",14,null],[11,"to_i8","","Converts the value of `self` to an `i8`.",14,null],[11,"to_i16","","Converts the value of `self` to an `i16`.",14,null],[11,"to_i32","","Converts the value of `self` to an `i32`.",14,null],[10,"to_i64","","Converts the value of `self` to an `i64`.",14,null],[11,"to_usize","","Converts the value of `self` to a `usize`.",14,null],[11,"to_u8","","Converts the value of `self` to an `u8`.",14,null],[11,"to_u16","","Converts the value of `self` to an `u16`.",14,null],[11,"to_u32","","Converts the value of `self` to an `u32`.",14,null],[10,"to_u64","","Converts the value of `self` to an `u64`.",14,null],[11,"to_f32","","Converts the value of `self` to an `f32`.",14,null],[11,"to_f64","","Converts the value of `self` to an `f64`.",14,null],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the\nvalue cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"isize"}],"output":{"name":"option"}}],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"i8"}],"output":{"name":"option"}}],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"i16"}],"output":{"name":"option"}}],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"i32"}],"output":{"name":"option"}}],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"i64"}],"output":{"name":"option"}}],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"f32"}],"output":{"name":"option"}}],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",15,{"inputs":[{"name":"f64"}],"output":{"name":"option"}}],[5,"cast","","Cast from one machine scalar to another.",null,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted into\na primitive via the `ToPrimitive` trait.",16,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[0,"pow","num","",null,null],[5,"pow","num::pow","Raises a value to the power of exp, using exponentiation by squaring.",null,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"t"}}],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",null,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"option"}}],[5,"checked_pow","num","Raises a value to the power of exp, returning `None` if an overflow occurred.",null,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"option"}}],[0,"bigint","","",null,null],[0,"complex","","",null,null],[0,"integer","","",null,null],[0,"iter","","",null,null],[0,"traits","","",null,null],[0,"rational","","",null,null],[11,"new","","Creates and initializes a BigInt.",17,{"inputs":[{"name":"sign"},{"name":"vec"}],"output":{"name":"bigint"}}],[11,"from_biguint","","Creates and initializes a `BigInt`.",17,{"inputs":[{"name":"sign"},{"name":"biguint"}],"output":{"name":"bigint"}}],[11,"from_slice","","Creates and initializes a `BigInt`.",17,null],[11,"from_bytes_be","","Creates and initializes a `BigInt`.",17,null],[11,"from_bytes_le","","Creates and initializes a `BigInt`.",17,null],[11,"to_bytes_le","","Returns the sign and the byte representation of the `BigInt` in little-endian byte order.",17,null],[11,"to_bytes_be","","Returns the sign and the byte representation of the `BigInt` in big-endian byte order.",17,null],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix.\n`radix` must be in the range `[2, 36]`.",17,null],[11,"sign","","Returns the sign of the `BigInt` as a `Sign`.",17,null],[11,"parse_bytes","","Creates and initializes a `BigInt`.",17,null],[11,"bits","","Determines the fewest bits necessary to express the `BigInt`,\nnot including the sign.",17,null],[11,"to_biguint","","Converts this `BigInt` into a `BigUint`, if it&#39;s not negative.",17,null],[11,"checked_add","","",17,null],[11,"checked_sub","","",17,null],[11,"checked_mul","","",17,null],[11,"checked_div","","",17,null],[11,"hash","","",18,null],[11,"fmt","","",18,null],[11,"clone","","",18,null],[11,"decode","","",18,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",18,null],[11,"eq","","",18,null],[11,"partial_cmp","","",18,null],[11,"cmp","","",18,null],[11,"default","","",18,{"inputs":[],"output":{"name":"biguint"}}],[11,"fmt","","",18,null],[11,"fmt","","",18,null],[11,"fmt","","",18,null],[11,"fmt","","",18,null],[11,"fmt","","",18,null],[11,"from_str","","",18,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from_str_radix","","Creates and initializes a `BigUint`.",18,{"inputs":[{"name":"str"},{"name":"u32"}],"output":{"name":"result"}}],[11,"bitand","","",18,null],[11,"bitand","","",18,null],[11,"bitor","","",18,null],[11,"bitor","","",18,null],[11,"bitxor","","",18,null],[11,"bitxor","","",18,null],[11,"shl","","",18,null],[11,"shr","","",18,null],[11,"zero","","",18,{"inputs":[],"output":{"name":"biguint"}}],[11,"is_zero","","",18,null],[11,"one","","",18,{"inputs":[],"output":{"name":"biguint"}}],[11,"add","","",18,null],[11,"add","","",18,null],[11,"sub","","",18,null],[11,"sub","","",18,null],[11,"mul","","",18,null],[11,"mul","","",18,null],[11,"div","","",18,null],[11,"div","","",18,null],[11,"rem","","",18,null],[11,"rem","","",18,null],[11,"neg","","",18,null],[11,"checked_add","","",18,null],[11,"checked_sub","","",18,null],[11,"checked_mul","","",18,null],[11,"checked_div","","",18,null],[11,"div_rem","","",18,null],[11,"div_floor","","",18,null],[11,"mod_floor","","",18,null],[11,"div_mod_floor","","",18,null],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",18,null],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",18,null],[11,"divides","","Deprecated, use `is_multiple_of` instead.",18,null],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",18,null],[11,"is_even","","Returns `true` if the number is divisible by `2`.",18,null],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",18,null],[11,"to_i64","","",18,null],[11,"to_u64","","",18,null],[11,"to_f32","","",18,null],[11,"to_f64","","",18,null],[11,"from_i64","","",18,{"inputs":[{"name":"i64"}],"output":{"name":"option"}}],[11,"from_u64","","",18,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_f64","","",18,{"inputs":[{"name":"f64"}],"output":{"name":"option"}}],[11,"from","","",18,{"inputs":[{"name":"u64"}],"output":{"name":"biguint"}}],[11,"from","","",18,{"inputs":[{"name":"u8"}],"output":{"name":"biguint"}}],[11,"from","","",18,{"inputs":[{"name":"u16"}],"output":{"name":"biguint"}}],[11,"from","","",18,{"inputs":[{"name":"u32"}],"output":{"name":"biguint"}}],[11,"from","","",18,{"inputs":[{"name":"usize"}],"output":{"name":"biguint"}}],[11,"to_biguint","","",18,null],[11,"new","","Creates and initializes a `BigUint`.",18,{"inputs":[{"name":"vec"}],"output":{"name":"biguint"}}],[11,"from_slice","","Creates and initializes a `BigUint`.",18,null],[11,"from_bytes_be","","Creates and initializes a `BigUint`.",18,null],[11,"from_bytes_le","","Creates and initializes a `BigUint`.",18,null],[11,"to_bytes_le","","Returns the byte representation of the `BigUint` in little-endian byte order.",18,null],[11,"to_bytes_be","","Returns the byte representation of the `BigUint` in big-endian byte order.",18,null],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix.\n`radix` must be in the range `[2, 36]`.",18,null],[11,"parse_bytes","","Creates and initializes a `BigUint`.",18,null],[11,"bits","","Determines the fewest bits necessary to express the `BigUint`.",18,null],[11,"hash","","",17,null],[11,"fmt","","",17,null],[11,"clone","","",17,null],[11,"decode","","",17,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",17,null],[11,"eq","","",17,null],[11,"partial_cmp","","",17,null],[11,"cmp","","",17,null],[11,"default","","",17,{"inputs":[],"output":{"name":"bigint"}}],[11,"fmt","","",17,null],[11,"fmt","","",17,null],[11,"fmt","","",17,null],[11,"fmt","","",17,null],[11,"fmt","","",17,null],[11,"from_str","","",17,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from_str_radix","","Creates and initializes a BigInt.",17,{"inputs":[{"name":"str"},{"name":"u32"}],"output":{"name":"result"}}],[11,"shl","","",17,null],[11,"shr","","",17,null],[11,"zero","","",17,{"inputs":[],"output":{"name":"bigint"}}],[11,"is_zero","","",17,null],[11,"one","","",17,{"inputs":[],"output":{"name":"bigint"}}],[11,"abs","","",17,null],[11,"abs_sub","","",17,null],[11,"signum","","",17,null],[11,"is_positive","","",17,null],[11,"is_negative","","",17,null],[11,"add","","",17,null],[11,"add","","",17,null],[11,"sub","","",17,null],[11,"sub","","",17,null],[11,"mul","","",17,null],[11,"mul","","",17,null],[11,"div","","",17,null],[11,"div","","",17,null],[11,"rem","","",17,null],[11,"rem","","",17,null],[11,"neg","","",17,null],[11,"checked_add","","",17,null],[11,"checked_sub","","",17,null],[11,"checked_mul","","",17,null],[11,"checked_div","","",17,null],[11,"div_rem","","",17,null],[11,"div_floor","","",17,null],[11,"mod_floor","","",17,null],[11,"div_mod_floor","","",17,null],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",17,null],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",17,null],[11,"divides","","Deprecated, use `is_multiple_of` instead.",17,null],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",17,null],[11,"is_even","","Returns `true` if the number is divisible by `2`.",17,null],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",17,null],[11,"to_i64","","",17,null],[11,"to_u64","","",17,null],[11,"to_f32","","",17,null],[11,"to_f64","","",17,null],[11,"from_i64","","",17,{"inputs":[{"name":"i64"}],"output":{"name":"option"}}],[11,"from_u64","","",17,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_f64","","",17,{"inputs":[{"name":"f64"}],"output":{"name":"option"}}],[11,"from","","",17,{"inputs":[{"name":"i64"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"i8"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"i16"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"i32"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"isize"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"u64"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"u8"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"u16"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"u32"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"usize"}],"output":{"name":"bigint"}}],[11,"from","","",17,{"inputs":[{"name":"biguint"}],"output":{"name":"bigint"}}],[11,"to_bigint","","",17,null],[11,"to_bigint","","",18,null],[11,"to_biguint","","",17,null],[11,"new","","Create a new Complex",0,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"complex"}}],[11,"i","","Returns imaginary unit",0,{"inputs":[],"output":{"name":"complex"}}],[11,"norm_sqr","","Returns the square of the norm (since `T` doesn&#39;t necessarily\nhave a sqrt function), i.e. `re^2 + im^2`.",0,null],[11,"scale","","Multiplies `self` by the scalar `t`.",0,null],[11,"unscale","","Divides `self` by the scalar `t`.",0,null],[11,"conj","","Returns the complex conjugate. i.e. `re - i im`",0,null],[11,"inv","","Returns `1/self`",0,null],[11,"norm","","Calculate |self|",0,null],[11,"arg","","Calculate the principal Arg of self.",0,null],[11,"to_polar","","Convert to polar form (r, theta), such that `self = r * exp(i\n* theta)`",0,null],[11,"from_polar","","Convert a polar representation into a complex number.",0,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"complex"}}],[11,"exp","","Computes `e^(self)`, where `e` is the base of the natural logarithm.",0,null],[11,"ln","","Computes the principal value of natural logarithm of `self`.",0,null],[11,"sqrt","","Computes the principal value of the square root of `self`.",0,null],[11,"powf","","Raises `self` to a floating point power.",0,null],[11,"log","","Returns the logarithm of `self` with respect to an arbitrary base.",0,null],[11,"powc","","Raises `self` to a complex power.",0,null],[11,"expf","","Raises a floating point number to the complex power `self`.",0,null],[11,"sin","","Computes the sine of `self`.",0,null],[11,"cos","","Computes the cosine of `self`.",0,null],[11,"tan","","Computes the tangent of `self`.",0,null],[11,"asin","","Computes the principal value of the inverse sine of `self`.",0,null],[11,"acos","","Computes the principal value of the inverse cosine of `self`.",0,null],[11,"atan","","Computes the principal value of the inverse tangent of `self`.",0,null],[11,"sinh","","Computes the hyperbolic sine of `self`.",0,null],[11,"cosh","","Computes the hyperbolic cosine of `self`.",0,null],[11,"tanh","","Computes the hyperbolic tangent of `self`.",0,null],[11,"asinh","","Computes the principal value of inverse hyperbolic sine of `self`.",0,null],[11,"acosh","","Computes the principal value of inverse hyperbolic cosine of `self`.",0,null],[11,"atanh","","Computes the principal value of inverse hyperbolic tangent of `self`.",0,null],[11,"is_nan","","Checks if the given complex number is NaN",0,null],[11,"is_infinite","","Checks if the given complex number is infinite",0,null],[11,"is_finite","","Checks if the given complex number is finite",0,null],[11,"is_normal","","Checks if the given complex number is normal",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"complex"}}],[11,"fmt","","",0,null],[11,"hash","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"decode","","",0,{"inputs":[{"name":"__dt"}],"output":{"name":"result"}}],[11,"encode","","",0,null],[11,"from","","",0,{"inputs":[{"name":"t"}],"output":{"name":"complex"}}],[11,"from","","",0,{"inputs":[{"name":"t"}],"output":{"name":"complex"}}],[11,"add","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,null],[11,"sub","","",0,null],[11,"mul","","",0,null],[11,"mul","","",0,null],[11,"div","","",0,null],[11,"div","","",0,null],[11,"neg","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,null],[11,"mul","","",0,null],[11,"div","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,null],[11,"mul","","",0,null],[11,"div","","",0,null],[11,"zero","","",0,{"inputs":[],"output":{"name":"complex"}}],[11,"is_zero","","",0,null],[11,"one","","",0,{"inputs":[],"output":{"name":"complex"}}],[11,"fmt","","",0,null]],"paths":[[3,"Complex"],[8,"Integer"],[8,"Num"],[8,"Zero"],[8,"One"],[8,"Signed"],[8,"Bounded"],[8,"Saturating"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"PrimInt"],[8,"Float"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[3,"BigInt"],[3,"BigUint"]]};
searchIndex["num_rational"] = {"doc":"Rational numbers","items":[[3,"Ratio","num_rational","Represents the ratio between 2 numbers.",null,null],[3,"ParseRatioError","","",null,null],[6,"Rational","","Alias for a `Ratio` of machine-sized integers.",null,null],[6,"Rational32","","",null,null],[6,"Rational64","","",null,null],[6,"BigRational","","Alias for arbitrary precision rationals.",null,null],[11,"fmt","","",0,null],[11,"hash","","",0,null],[11,"clone","","",0,null],[11,"decode","","",0,{"inputs":[{"name":"__dt"}],"output":{"name":"result"}}],[11,"encode","","",0,null],[11,"new","","Creates a new `Ratio`. Fails if `denom` is zero.",0,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"ratio"}}],[11,"from_integer","","Creates a `Ratio` representing the integer `t`.",0,{"inputs":[{"name":"t"}],"output":{"name":"ratio"}}],[11,"new_raw","","Creates a `Ratio` without checking for `denom == 0` or reducing.",0,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"ratio"}}],[11,"to_integer","","Converts to an integer, rounding towards zero.",0,null],[11,"numer","","Gets an immutable reference to the numerator.",0,null],[11,"denom","","Gets an immutable reference to the denominator.",0,null],[11,"is_integer","","Returns true if the rational number is an integer (denominator is 1).",0,null],[11,"reduced","","Returns a reduced copy of self.",0,null],[11,"recip","","Returns the reciprocal.",0,null],[11,"floor","","Rounds towards minus infinity.",0,null],[11,"ceil","","Rounds towards plus infinity.",0,null],[11,"round","","Rounds to the nearest integer. Rounds half-way cases away from zero.",0,null],[11,"trunc","","Rounds towards zero.",0,null],[11,"fract","","Returns the fractional part of a number, with division rounded towards zero.",0,null],[11,"pow","","Raises the `Ratio` to the power of an exponent.",0,null],[11,"from_float","","Converts a float into a rational number.",0,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"eq","","",0,null],[11,"mul","","",0,null],[11,"mul","","",0,null],[11,"div","","",0,null],[11,"div","","",0,null],[11,"add","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,null],[11,"sub","","",0,null],[11,"rem","","",0,null],[11,"rem","","",0,null],[11,"neg","","",0,null],[11,"zero","","",0,{"inputs":[],"output":{"name":"ratio"}}],[11,"is_zero","","",0,null],[11,"one","","",0,{"inputs":[],"output":{"name":"ratio"}}],[11,"from_str_radix","","Parses `numer/denom` where the numbers are in base `radix`.",0,{"inputs":[{"name":"str"},{"name":"u32"}],"output":{"name":"result"}}],[11,"abs","","",0,null],[11,"abs_sub","","",0,null],[11,"signum","","",0,null],[11,"is_positive","","",0,null],[11,"is_negative","","",0,null],[11,"fmt","","Renders as `numer/denom`. If denom=1, renders as numer.",0,null],[11,"from_str","","Parses `numer/denom` or just `numer`.",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"description","","",1,null]],"paths":[[3,"Ratio"],[3,"ParseRatioError"]]};
searchIndex["rgsl"] = {"doc":"A __Rust__ binding for the [GSL library][] (the GNU Scientific Library).","items":[[4,"Mode","rgsl","",null,null],[13,"PrecDouble","","",0,null],[13,"PrecSingle","","",0,null],[13,"PrecApprox","","",0,null],[4,"Value","","",null,null],[13,"Success","","",1,null],[13,"Failure","","",1,null],[13,"Continue","","iteration has not converged",1,null],[13,"Domain","","input domain error, e.g sqrt(-1)",1,null],[13,"Range","","output range error, e.g. exp(1e100)",1,null],[13,"Fault","","invalid pointer",1,null],[13,"Invalid","","invalid argument supplied by user",1,null],[13,"Failed","","generic failure",1,null],[13,"Factorization","","factorization failed",1,null],[13,"Sanity","","sanity check failed - shouldn&#39;t happen",1,null],[13,"NoMemory","","malloc failed",1,null],[13,"BadFunction","","problem with user-supplied function",1,null],[13,"RunAway","","iterative process is out of control",1,null],[13,"MaxIteration","","exceeded max number of iterations",1,null],[13,"ZeroDiv","","tried to divide by zero",1,null],[13,"BadTolerance","","user specified an invalid tolerance",1,null],[13,"Tolerance","","failed to reach the specified tolerance",1,null],[13,"UnderFlow","","underflow",1,null],[13,"OverFlow","","overflow",1,null],[13,"Loss","","loss of accuracy",1,null],[13,"Round","","failed because of roundoff error",1,null],[13,"BadLength","","matrix, vector lengths are not conformant",1,null],[13,"NotSquare","","matrix not square",1,null],[13,"Singularity","","apparent singularity detected",1,null],[13,"Diverge","","integral or series is divergent",1,null],[13,"Unsupported","","requested feature is not supported by the hardware",1,null],[13,"Unimplemented","","requested feature not (yet) implemented",1,null],[13,"Cache","","cache limit exceeded",1,null],[13,"Table","","table limit exceeded",1,null],[13,"NoProgress","","iteration is not making progress towards solution",1,null],[13,"NoProgressJacobian","","jacobian evaluations are not improving the solution",1,null],[13,"ToleranceF","","cannot reach the specified tolerance in F",1,null],[13,"ToleranceX","","cannot reach the specified tolerance in X",1,null],[13,"ToleranceG","","cannot reach the specified tolerance in gradient",1,null],[13,"EOF","","cannot reach the specified tolerance in gradient",1,null],[4,"EigenSort","","",null,null],[13,"ValAsc","","ascending order in numerical value",2,null],[13,"ValDesc","","descending order in numerical value",2,null],[13,"AbsAsc","","ascending order in magnitude",2,null],[13,"AbsDesc","","descending order in magnitude",2,null],[4,"FftDirection","","this gives the sign in the formula",null,null],[13,"Forward","","",3,null],[13,"Backward","","",3,null],[4,"GaussKonrodRule","","The low-level integration rules in QUADPACK are identified by small integers (1-6). We&#39;ll use symbolic constants to refer to them.",null,null],[13,"Gauss15","","15 point Gauss-Kronrod rule",4,null],[13,"Gauss21","","21 point Gauss-Kronrod rule",4,null],[13,"Gauss31","","31 point Gauss-Kronrod rule",4,null],[13,"Gauss41","","41 point Gauss-Kronrod rule",4,null],[13,"Gauss51","","51 point Gauss-Kronrod rule",4,null],[13,"Gauss61","","61 point Gauss-Kronrod rule",4,null],[4,"IntegrationQawo","","Used by workspace for QAWO integrator",null,null],[13,"Cosine","","",5,null],[13,"Sine","","",5,null],[4,"VegasMode","","Used by VegasMonteCarlo struct",null,null],[13,"Importance","","",6,null],[13,"ImportanceOnly","","",6,null],[13,"Stratified","","",6,null],[4,"ODEiv","","Possible return values for an hadjust() evolution method for ordinary differential equations",null,null],[13,"Inc","","step was increased",7,null],[13,"Nil","","step unchanged",7,null],[13,"Dec","","step decreased",7,null],[4,"WaveletDirection","","",null,null],[13,"Forward","","",8,null],[13,"Backward","","",8,null],[11,"fmt","","",0,null],[11,"partial_cmp","","",0,null],[11,"eq","","",0,null],[11,"clone","","",0,null],[11,"fmt","","",1,null],[11,"partial_cmp","","",1,null],[11,"eq","","",1,null],[11,"clone","","",1,null],[11,"wrap","","",1,{"inputs":[{"name":"i32"}],"output":{"name":"value"}}],[11,"fmt","","",2,null],[11,"partial_cmp","","",2,null],[11,"eq","","",2,null],[11,"clone","","",2,null],[11,"fmt","","",3,null],[11,"partial_cmp","","",3,null],[11,"eq","","",3,null],[11,"clone","","",3,null],[11,"fmt","","",4,null],[11,"partial_cmp","","",4,null],[11,"eq","","",4,null],[11,"clone","","",4,null],[11,"fmt","","",5,null],[11,"partial_cmp","","",5,null],[11,"eq","","",5,null],[11,"clone","","",5,null],[11,"fmt","","",6,null],[11,"partial_cmp","","",6,null],[11,"eq","","",6,null],[11,"clone","","",6,null],[11,"fmt","","",7,null],[11,"partial_cmp","","",7,null],[11,"eq","","",7,null],[11,"clone","","",7,null],[11,"fmt","","",8,null],[11,"partial_cmp","","",8,null],[11,"eq","","",8,null],[11,"clone","","",8,null],[0,"randist","","#Random Number Distributions",null,null],[0,"bernoulli","rgsl::randist","",null,null],[5,"bernoulli","rgsl::randist::bernoulli","This function returns either 0 or 1, the result of a Bernoulli trial with probability p. The probability distribution for a Bernoulli trial is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"u32"}}],[5,"bernoulli_pdf","","This function computes the probability p(k) of obtaining k from a Bernoulli distribution with probability parameter p, using the formula given above.",null,{"inputs":[{"name":"u32"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"beta","rgsl::randist","",null,null],[5,"beta","rgsl::randist::beta","This function returns a random variate from the beta distribution. The distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"beta_pdf","","This function computes the probability density p(x) at x for a beta distribution with parameters a and b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"beta_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"beta_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"beta_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"beta_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"binomial","rgsl::randist","",null,null],[5,"binomial","rgsl::randist::binomial","This function returns a random integer from the binomial distribution, the number of successes in n independent trials with probability p. The probability distribution for binomial variates is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"u32"}],"output":{"name":"u32"}}],[5,"binomial_pdf","","This function computes the probability p(k) of obtaining k from a binomial distribution with parameters p and n, using the formula given above.",null,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"u32"}],"output":{"name":"f64"}}],[5,"binomial_P","","This function computes the cumulative distribution functions P(k), Q(k) for the binomial distribution with parameters p and n.",null,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"u32"}],"output":{"name":"f64"}}],[5,"binomial_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the binomial distribution with parameters p and n.",null,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"u32"}],"output":{"name":"f64"}}],[0,"bivariate_gaussian","rgsl::randist","",null,null],[5,"gaussian_tail","rgsl::randist::bivariate_gaussian","This function generates a pair of correlated Gaussian variates, with mean zero, correlation coefficient rho and standard deviations sigma_x and sigma_y in the x and y directions.\nThe probability distribution for bivariate Gaussian random variates is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"gaussian_tail_pdf","","This function computes the probability density p(x,y) at (x,y) for a bivariate Gaussian distribution with standard deviations sigma_x, sigma_y and correlation coefficient rho, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"cauchy","rgsl::randist","",null,null],[5,"cauchy","rgsl::randist::cauchy","This function returns a random variate from the Cauchy distribution with scale parameter a. The probability distribution for Cauchy random variates is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"cauchy_pdf","","This function computes the probability density p(x) at x for a Cauchy distribution with scale parameter a, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"cauchy_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"cauchy_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"cauchy_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"cauchy_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"chi_squared","rgsl::randist","The chi-squared distribution arises in statistics. If Y_i are n independent Gaussian random variates with unit variance then the sum-of-squares,",null,null],[5,"chisq","rgsl::randist::chi_squared","This function returns a random variate from the chi-squared distribution with nu degrees of freedom. The distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"chisq_pdf","","This function computes the probability density p(x) at x for a chi-squared distribution with nu degrees of freedom, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"chisq_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"chisq_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"chisq_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"chisq_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"dirichlet","rgsl::randist","",null,null],[5,"dirichlet","rgsl::randist::dirichlet","This function returns an array of K random variates from a Dirichlet distribution of order K-1. The distribution function is",null,null],[5,"dirichlet_pdf","","This function computes the probability density p(\\theta_1, ... , \\theta_K) at theta[K] for a Dirichlet distribution with parameters alpha[K], using the formula given above.",null,null],[5,"dirichlet_lnpdf","","This function computes the logarithm of the probability density p(\\theta_1, ... , \\theta_K) for a Dirichlet distribution with parameters alpha[K].",null,null],[0,"exponential","rgsl::randist","",null,null],[5,"exponential","rgsl::randist::exponential","This function returns a random variate from the exponential distribution with mean mu. The distribution is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exponential_pdf","","This function computes the probability density p(x) at x for an exponential distribution with mean mu, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exponential_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the exponential distribution with mean mu.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exponential_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the exponential distribution with mean mu.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exponential_Pinv","","",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exponential_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the exponential distribution with mean mu.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"exponential_power","rgsl::randist","",null,null],[5,"exppow","rgsl::randist::exponential_power","This function returns a random variate from the exponential power distribution with scale parameter a and exponent b. The distribution is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exppow_pdf","","This function computes the probability density p(x) at x for an exponential power distribution with scale parameter a and exponent b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exppow_P","","This function computes tthe cumulative distribution functions P(x), Q(x) for the exponential power distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exppow_Q","","This function computes tthe cumulative distribution functions P(x), Q(x) for the exponential power distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"f_distribution","rgsl::randist","The F-distribution arises in statistics. If Y_1 and Y_2 are chi-squared deviates with \\nu_1 and \\nu_2 degrees of freedom then the ratio,",null,null],[5,"fdist","rgsl::randist::f_distribution","This function returns a random variate from the F-distribution with degrees of freedom nu1 and nu2. The distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"fdist_pdf","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"fdist_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"fdist_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"fdist_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"fdist_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"flat","rgsl::randist","",null,null],[5,"flat","rgsl::randist::flat","This function returns a random variate from the flat (uniform) distribution from a to b. The distribution is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"flat_pdf","","This function computes the probability density p(x) at x for a uniform distribution from a to b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"flat_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"flat_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"flat_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"flat_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"gamma","rgsl::randist","",null,null],[5,"gamma","rgsl::randist::gamma","This function returns a random variate from the gamma distribution. The distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_knuth","","This function returns a gamma variate using the algorithms from Knuth (vol 2).",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_pdf","","This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_P","","This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_Q","","This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_Pinv","","This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_Qinv","","This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"gaussian","rgsl::randist","",null,null],[5,"gaussian","rgsl::randist::gaussian","This function returns a Gaussian random variate, with mean zero and standard deviation sigma.\nThe probability distribution for Gaussian random variates is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gaussian_pdf","","This function computes the probability density p(x) at x for a Gaussian distribution with standard deviation sigma, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gaussian_ziggurat","","",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gaussian_ratio_method","","This function computes a Gaussian random variate using the alternative Marsaglia-Tsang ziggurat and Kinderman-Monahan-Leva ratio methods.\nThe Ziggurat algorithm is the fastest available algorithm in most cases.",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"ugaussian","","This function computes results for the unit Gaussian distribution.\nThey are equivalent to the functions above with a standard deviation of one, sigma = 1.",null,{"inputs":[{"name":"rng"}],"output":{"name":"f64"}}],[5,"ugaussian_pdf","","This function computes results for the unit Gaussian distribution.\nThey are equivalent to the functions above with a standard deviation of one, sigma = 1.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"ugaussian_ratio_method","","This function computes results for the unit Gaussian distribution.\nThey are equivalent to the functions above with a standard deviation of one, sigma = 1.",null,{"inputs":[{"name":"rng"}],"output":{"name":"f64"}}],[5,"gaussian_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gaussian_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gaussian_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gaussian_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"ugaussian_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"ugaussian_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"ugaussian_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"ugaussian_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[0,"gaussian_tail","rgsl::randist","",null,null],[5,"gaussian_tail","rgsl::randist::gaussian_tail","This function provides random variates from the upper tail of a Gaussian distribution with standard deviation sigma.\nThe values returned are larger than the lower limit a, which must be positive. The method is based on Marsaglia’s famous rectangle-wedge-tail algorithm (Ann. Math. Stat. 32, 894–899 (1961)), with this aspect explained in Knuth, v2, 3rd ed, p139,586 (exercise 11).",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gaussian_tail_pdf","","This function computes the probability density p(x) at x for a Gaussian tail distribution with standard deviation sigma and lower limit a, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"ugaussian_tail","","This function computes results for the tail of a unit Gaussian distribution. They are equivalent to the functions above with a standard deviation of one, sigma = 1.",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"ugaussian_tail_pdf","","This function computes results for the tail of a unit Gaussian distribution. They are equivalent to the functions above with a standard deviation of one, sigma = 1.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"geometric","rgsl::randist","",null,null],[5,"geometric","rgsl::randist::geometric","This function returns a random integer from the geometric distribution, the number of independent trials with probability p until the first success.\nThe probability distribution for geometric variates is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"u32"}}],[5,"geometric_pdf","","This function computes the probability p(k) of obtaining k from a geometric distribution with probability parameter p, using the formula given above.",null,{"inputs":[{"name":"u32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"geometric_P","","This function computes the cumulative distribution functions P(k), Q(k) for the geometric distribution with parameter p.",null,{"inputs":[{"name":"u32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"geometric_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the geometric distribution with parameter p.",null,{"inputs":[{"name":"u32"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"gumbel","rgsl::randist","",null,null],[0,"type_1","rgsl::randist::gumbel","",null,null],[5,"gumbel1","rgsl::randist::gumbel::type_1","This function returns a random variate from the Type-1 Gumbel distribution. The Type-1 Gumbel distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel1_pdf","","This function computes the probability density p(x) at x for a Type-1 Gumbel distribution with parameters a and b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel1_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel1_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel1_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel1_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"type_2","rgsl::randist::gumbel","",null,null],[5,"gumbel2","rgsl::randist::gumbel::type_2","This function returns a random variate from the Type-2 Gumbel distribution. The Type-2 Gumbel distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel2_pdf","","This function computes the probability density p(x) at x for a Type-2 Gumbel distribution with parameters a and b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel2_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel2_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel2_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gumbel2_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"hypergeometric","rgsl::randist","",null,null],[5,"hypergeometric","rgsl::randist::hypergeometric","This function returns a random integer from the hypergeometric distribution. The probability distribution for hypergeometric random variates is,",null,{"inputs":[{"name":"rng"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"u32"}}],[5,"hypergeometric_pdf","","This function computes the probability p(k) of obtaining k from a hypergeometric distribution with parameters n1, n2, t, using the formula given above.",null,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"f64"}}],[5,"hypergeometric_P","","This function computes the cumulative distribution functions P(k), Q(k) for the hypergeometric distribution with parameters n1, n2 and t.",null,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"f64"}}],[5,"hypergeometric_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the hypergeometric distribution with parameters n1, n2 and t.",null,{"inputs":[{"name":"u32"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"f64"}}],[0,"landau","rgsl::randist","",null,null],[5,"landau","rgsl::randist::landau","This function returns a random variate from the Landau distribution. The probability distribution for Landau random variates is defined analytically by the complex integral,",null,{"inputs":[{"name":"rng"}],"output":{"name":"f64"}}],[5,"landau_pdf","","This function computes the probability density p(x) at x for the Landau distribution using an approximation to the formula given above.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[0,"laplace","rgsl::randist","",null,null],[5,"laplace","rgsl::randist::laplace","This function returns a random variate from the Laplace distribution with width a. The distribution is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"laplace_pdf","","This function computes the probability density p(x) at x for a Laplace distribution with width a, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"laplace_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"laplace_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"laplace_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"laplace_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"levy_alpha","rgsl::randist","",null,null],[5,"levy","rgsl::randist::levy_alpha","This function returns a random variate from the Levy symmetric stable distribution with scale c and exponent alpha. The symmetric stable probability distribution is defined by a Fourier transform,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"levy_skew","rgsl::randist","",null,null],[5,"levy_skew","rgsl::randist::levy_skew","This function returns a random variate from the Levy skew stable distribution with scale c, exponent alpha and skewness parameter beta.\nThe skewness parameter must lie in the range [-1,1]. The Levy skew stable probability distribution is defined by a Fourier transform,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"logarithmic","rgsl::randist","",null,null],[5,"logarithmic","rgsl::randist::logarithmic","This function returns a random integer from the logarithmic distribution. The probability distribution for logarithmic random variates is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"u32"}}],[5,"logarithmic_pdf","","This function computes the probability p(k) of obtaining k from a logarithmic distribution with probability parameter p, using the formula given above.",null,{"inputs":[{"name":"u32"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"logistic","rgsl::randist","",null,null],[5,"logistic","rgsl::randist::logistic","This function returns a random variate from the logistic distribution. The distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"logistic_pdf","","This function computes the probability density p(x) at x for a logistic distribution with scale parameter a, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"logistic_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"logistic_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"logistic_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"logistic_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"lognormal","rgsl::randist","",null,null],[5,"lognormal","rgsl::randist::lognormal","This function returns a random variate from the lognormal distribution. The distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"lognormal_pdf","","This function computes the probability density p(x) at x for a lognormal distribution with parameters zeta and sigma, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"lognormal_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"lognormal_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"lognormal_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"lognormal_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"multinomial","rgsl::randist","",null,null],[5,"multinomial","rgsl::randist::multinomial","This function computes a random sample n[] from the multinomial distribution formed by N trials from an underlying distribution p[K]. The distribution function for n[] is,",null,null],[5,"multinomial_pdf","","This function computes the probability P(n_1, n_2, ..., n_K) of sampling n[K] from a multinomial distribution with parameters p[K], using the formula given above.",null,null],[5,"multinomial_lnpdf","","This function returns the logarithm of the probability for the multinomial distribution P(n_1, n_2, ..., n_K) with parameters p[K].",null,null],[0,"negative_binomial","rgsl::randist","",null,null],[5,"negative_binomial","rgsl::randist::negative_binomial","This function returns a random integer from the negative binomial distribution, the number of failures occurring before n successes in independent trials with\nprobability p of success. The probability distribution for negative binomial variates is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"u32"}}],[5,"negative_binomial_pdf","","This function computes the probability p(k) of obtaining k from a negative binomial distribution with parameters p and n, using the formula given above.",null,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"negative_binomial_P","","This function computes the cumulative distribution functions P(k), Q(k) for the negative binomial distribution with parameters p and n.",null,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"negative_binomial_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the negative binomial distribution with parameters p and n.",null,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"pareto","rgsl::randist","",null,null],[5,"pareto","rgsl::randist::pareto","This function returns a random variate from the Pareto distribution of order a. The distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"pareto_pdf","","This function computes the probability density p(x) at x for a Pareto distribution with exponent a and scale b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"pareto_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"pareto_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"pareto_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"pareto_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"pascal","rgsl::randist","",null,null],[5,"pascal","rgsl::randist::pascal","This function returns a random integer from the Pascal distribution. The Pascal distribution is simply a negative binomial distribution with an integer value of n.",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"u32"}],"output":{"name":"u32"}}],[5,"pascal_pdf","","This function computes the probability p(k) of obtaining k from a Pascal distribution with parameters p and n, using the formula given above.",null,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"u32"}],"output":{"name":"f64"}}],[5,"pascal_P","","This function computes the cumulative distribution functions P(k), Q(k) for the Pascal distribution with parameters p and n.",null,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"u32"}],"output":{"name":"f64"}}],[5,"pascal_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the Pascal distribution with parameters p and n.",null,{"inputs":[{"name":"u32"},{"name":"f64"},{"name":"u32"}],"output":{"name":"f64"}}],[0,"poisson","rgsl::randist","",null,null],[5,"poisson","rgsl::randist::poisson","This function returns a random integer from the Poisson distribution with mean mu. The probability distribution for Poisson variates is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"u32"}}],[5,"poisson_pdf","","This function computes the probability p(k) of obtaining k from a Poisson distribution with mean mu, using the formula given above.",null,{"inputs":[{"name":"u32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"poisson_P","","This function computes the cumulative distribution functions P(k), Q(k) for the Poisson distribution with parameter mu.",null,{"inputs":[{"name":"u32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"poisson_Q","","This function computes the cumulative distribution functions P(k), Q(k) for the Poisson distribution with parameter mu.",null,{"inputs":[{"name":"u32"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"rayleigh","rgsl::randist","",null,null],[5,"rayleigh","rgsl::randist::rayleigh","This function returns a random variate from the Rayleigh distribution with scale parameter sigma. The distribution is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"rayleigh_pdf","","This function computes the probability density p(x) at x for a Rayleigh distribution with scale parameter sigma, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"rayleigh_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"rayleigh_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"rayleigh_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"rayleigh_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"rayleigh_tail","rgsl::randist","",null,null],[5,"rayleigh_tail","rgsl::randist::rayleigh_tail","This function returns a random variate from the tail of the Rayleigh distribution with scale parameter sigma and a lower limit of a. The distribution is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"rayleigh_tail_pdf","","This function computes the probability density p(x) at x for a Rayleigh tail distribution with scale parameter sigma and lower limit a, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"shuffling_sampling","rgsl::randist","The following functions allow the shuffling and sampling of a set of objects.\nThe algorithms rely on a random number generator as a source of randomness and a poor quality generator can lead to correlations in the output.\nIn particular it is important to avoid generators with a short period. For more information see Knuth, v2, 3rd ed, Section 3.4.2, “Random Sampling and Shuffling”.",null,null],[5,"shuffle","rgsl::randist::shuffling_sampling","This function randomly shuffles the order of n objects, each of size size, stored in the array base[0..n-1]. The output of the random number generator r is used to\nproduce the permutation. The algorithm generates all possible n! permutations with equal probability, assuming a perfect source of random numbers.",null,null],[5,"choose","","This function fills the array dest[k] with k objects taken randomly from the n elements of the array src[0..n-1]. The objects are each of size size.\nThe output of the random number generator r is used to make the selection. The algorithm ensures all possible samples are equally likely, assuming a perfect source of randomness.",null,null],[5,"sample","","This function is like gsl_ran_choose but samples k items from the original array of n items src with replacement, so the same object can appear more\nthan once in the output sequence dest. There is no requirement that k be less than n in this case.",null,null],[0,"spherical_vector","rgsl::randist","The spherical distributions generate random vectors, located on a spherical surface.\nThey can be used as random directions, for example in the steps of a random walk.",null,null],[5,"dir_2d","rgsl::randist::spherical_vector","This function returns a random direction vector v = (x,y) in two dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 = 1.\nThe obvious way to do this is to take a uniform random number between 0 and 2\\pi and let x and y be the sine and cosine respectively.\nTwo trig functions would have been expensive in the old days, but with modern hardware implementations, this is sometimes the fastest way to go.\nThis is the case for the Pentium (but not the case for the Sun Sparcstation).\nOne can avoid the trig evaluations by choosing x and y in the interior of a unit circle (choose them at random from the interior of the enclosing square,\nand then reject those that are outside the unit circle), and then dividing by \\sqrt{x^2 + y^2}. A much cleverer approach, attributed to von Neumann\n(See Knuth, v2, 3rd ed, p140, exercise 23), requires neither trig nor a square root. In this approach, u and v are chosen at random from the interior of\na unit circle, and then x=(u^2-v^2)/(u^2+v^2) and y=2uv/(u^2+v^2).",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"dir_2d_trig_method","","This function returns a random direction vector v = (x,y) in two dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 = 1.\nThe obvious way to do this is to take a uniform random number between 0 and 2\\pi and let x and y be the sine and cosine respectively.\nTwo trig functions would have been expensive in the old days, but with modern hardware implementations, this is sometimes the fastest way to go.\nThis is the case for the Pentium (but not the case for the Sun Sparcstation).\nOne can avoid the trig evaluations by choosing x and y in the interior of a unit circle (choose them at random from the interior of the enclosing square,\nand then reject those that are outside the unit circle), and then dividing by \\sqrt{x^2 + y^2}. A much cleverer approach, attributed to von Neumann\n(See Knuth, v2, 3rd ed, p140, exercise 23), requires neither trig nor a square root. In this approach, u and v are chosen at random from the interior of\na unit circle, and then x=(u^2-v^2)/(u^2+v^2) and y=2uv/(u^2+v^2).",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"dir_3d","","This function returns a random direction vector v = (x,y,z) in three dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 + z^2 = 1.\nThe method employed is due to Robert E. Knop (CACM 13, 326 (1970)), and explained in Knuth, v2, 3rd ed, p136. It uses the surprising fact that the\ndistribution projected along any axis is actually uniform (this is only true for 3 dimensions).",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"dir_nd","","This function returns a random direction vector v = (x_1,x_2,...,x_n) in n dimensions. The vector is normalized such that |v|^2 = x_1^2 + x_2^2 + ... + x_n^2 = 1.\nThe method uses the fact that a multivariate Gaussian distribution is spherically symmetric. Each component is generated to have a Gaussian distribution, and then\nthe components are normalized. The method is described by Knuth, v2, 3rd ed, p135–136, and attributed to G. W. Brown, Modern Mathematics for the Engineer (1956).",null,null],[0,"t_distribution","rgsl::randist","The t-distribution arises in statistics. If Y_1 has a normal distribution and Y_2 has a chi-squared distribution with \\nu degrees of freedom then the ratio,",null,null],[5,"tdist","rgsl::randist::t_distribution","This function returns a random variate from the t-distribution. The distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"tdist_pdf","","This function computes the probability density p(x) at x for a t-distribution with nu degrees of freedom, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"tdist_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"tdist_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"tdist_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"tdist_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"weibull","rgsl::randist","",null,null],[5,"weibull","rgsl::randist::weibull","This function returns a random variate from the Weibull distribution. The distribution function is,",null,{"inputs":[{"name":"rng"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"weibull_pdf","","This function computes the probability density p(x) at x for a Weibull distribution with scale a and exponent b, using the formula given above.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"weibull_P","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"weibull_Q","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"weibull_Pinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"weibull_Qinv","","This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[0,"types","rgsl","",null,null],[0,"basis_spline","rgsl::types","B-splines are commonly used as basis functions to fit smoothing curves to large data sets.\n To do this, the abscissa axis is broken up into some number of intervals, where the endpoints of each interval are called breakpoints.\n These breakpoints are then converted to knots by imposing various continuity and smoothness conditions at each interface. Given a nondecreasing knot vector t = {t_0, t_1, …, t_{n+k-1}}, the n basis splines of order k are defined by",null,null],[3,"BSpLineWorkspace","rgsl::types::basis_spline","",null,null],[3,"BSpLineDerivWorkspace","","",null,null],[11,"new","","This function allocates a workspace for computing B-splines of order k.\nThe number of breakpoints is given by nbreak. This leads to n = nbreak + k - 2 basis functions.\nCubic B-splines are specified by k = 4. The size of the workspace is O(5k + nbreak).",9,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"knots","","This function computes the knots associated with the given breakpoints and stores them internally in w-&gt;knots.",9,null],[11,"knots_uniform","","This function assumes uniformly spaced breakpoints on [a,b] and constructs the corresponding knot vector using the previously specified nbreak parameter.\nThe knots are stored in w-&gt;knots.",9,null],[11,"eval","","This function evaluates all B-spline basis functions at the position x and stores them in the vector B, so that the i-th element is B_i(x).\nThe vector B must be of length n = nbreak + k - 2. This value may also be obtained by calling gsl_bspline_ncoeffs.\nComputing all the basis functions at once is more efficient than computing them individually, due to the nature of the defining recurrence relation.",9,null],[11,"eval_non_zero","","This function evaluates all potentially nonzero B-spline basis functions at the position x and stores them in the vector Bk, so that the i-th element is B_(istart+i)(x).\nThe last element of Bk is B_(iend)(x). The vector Bk must be of length k.\nBy returning only the nonzero basis functions, this function allows quantities involving linear combinations of the B_i(x) to be computed without unnecessary terms (such linear combinations occur, for example, when evaluating an interpolated function).",9,null],[11,"ncoeffs","","This function returns the number of B-spline coefficients given by n = nbreak + k - 2.",9,null],[11,"greville_abscissa","","The Greville abscissae are defined to be the mean location of k-1 consecutive knots in the knot vector for each basis spline function of order k.\nWith the first and last knots in the gsl_bspline_workspace knot vector excluded, there are gsl_bspline_ncoeffs Greville abscissae for any given B-spline basis.\nThese values are often used in B-spline collocation applications and may also be called Marsden-Schoenberg points.",9,null],[11,"drop","","",9,null],[11,"new","","This function allocates a workspace for computing the derivatives of a B-spline basis function of order k.\nThe size of the workspace is O(2k^2).",10,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"eval","","This function evaluates all B-spline basis function derivatives of orders 0 through nderiv (inclusive) at the position x and stores them in the matrix dB.\nThe (i,j)-th element of dB is d^jB_i(x)/dx^j. The matrix dB must be of size n = nbreak + k - 2 by nderiv + 1.\nThe value n may also be obtained by calling gsl_bspline_ncoeffs. Note that function evaluations are included as the zeroth order derivatives in dB.\nComputing all the basis function derivatives at once is more efficient than computing them individually, due to the nature of the defining recurrence relation.",10,null],[11,"eval_non_zero","","This function evaluates all potentially nonzero B-spline basis function derivatives of orders 0 through nderiv (inclusive) at the position x and stores them in the matrix dB.\nThe (i,j)-th element of dB is d^j/dx^j B_(istart+i)(x). The last row of dB contains d^j/dx^j B_(iend)(x).\nThe matrix dB must be of size k by at least nderiv + 1. Note that function evaluations are included as the zeroth order derivatives in dB.\nBy returning only the nonzero basis functions, this function allows quantities involving linear combinations of the B_i(x) and their derivatives to be computed without unnecessary terms.",10,null],[11,"drop","","",10,null],[0,"chebyshev","rgsl::types","#Chebyshev Approximations",null,null],[3,"ChebSeries","rgsl::types::chebyshev","",null,null],[11,"new","","",11,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"init","","This function computes the Chebyshev approximation cs for the function f over the range (a,b) to the previously specified order. The\ncomputation of the Chebyshev approximation is an O(n^2) process, and requires n function evaluations.",11,null],[11,"order","","This function returns the order of Chebyshev series cs.",11,null],[11,"size","","This function returns the size of the Chebyshev coefficient array c[] for the Chebyshev series cs.",11,null],[11,"as_slice","","This function returns a pointer to the coefficient array c[] location in memory for the Chebyshev series cs.",11,null],[11,"as_mut_slice","","This function returns a pointer to the coefficient array c[] location in memory for the Chebyshev series cs.",11,null],[11,"eval","","This function evaluates the Chebyshev series cs at a given point x.",11,null],[11,"eval_err","","This function computes the Chebyshev series cs at a given point x, estimating both the series result and its absolute error abserr.\nThe error estimate is made from the first neglected term in the series.",11,null],[11,"eval_n","","This function evaluates the Chebyshev series cs at a given point x, to (at most) the given order order.",11,null],[11,"eval_n_err","","This function evaluates a Chebyshev series cs at a given point x, estimating both the series result and its absolute error abserr, to\n(at most) the given order order. The error estimate is made from the first neglected term in the series.",11,null],[11,"calc_deriv","","This function computes the derivative of the series cs, storing the derivative coefficients in the previously allocated deriv. The\ntwo series cs and deriv must have been allocated with the same order.",11,null],[11,"calc_integ","","This function computes the integral of the series cs, storing the integral coefficients in the previously allocated integ. The two series\ncs and integ must have been allocated with the same order. The lower limit of the integration is taken to be the left hand end of the range a.",11,null],[11,"drop","","",11,null],[0,"combination","rgsl::types","#Combinations",null,null],[3,"Combination","rgsl::types::combination","",null,null],[11,"new","","This function allocates memory for a new combination with parameters n, k. The combination is not initialized and its elements are\nundefined. Use the function Combination::new_init_first if you want to create a combination which is initialized to the lexicographically\nfirst combination. A null pointer is returned if insufficient memory is available to create the combination.",12,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"new_init_first","","This function allocates memory for a new combination with parameters n, k and initializes it to the lexicographically first combination.\nA null pointer is returned if insufficient memory is available to create the combination.",12,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"init_first","","This function initializes the combination c to the lexicographically first combination, i.e. (0,1,2,…,k-1).",12,null],[11,"init_last","","This function initializes the combination c to the lexicographically last combination, i.e. (n-k,n-k+1,…,n-1).",12,null],[11,"copy","","This function copies the elements of the combination self into the combination dest. The two combinations must have the same size.",12,null],[11,"get","","This function returns the value of the i-th element of the combination self. If i lies outside the allowed range of 0 to k-1 then the\nerror handler is invoked and 0 is returned.",12,null],[11,"n","","This function returns the range (n) of the combination self.",12,null],[11,"k","","This function returns the number of elements (k) in the combination self.",12,null],[11,"as_slice","","This function returns a pointer to the array of elements in the combination self.",12,null],[11,"as_mut_slice","","This function returns a pointer to the array of elements in the combination self.",12,null],[11,"is_valid","","This function checks that the combination self is valid. The k elements should lie in the range 0 to n-1, with each value occurring\nonce at most and in increasing order.",12,null],[11,"next","","This function advances the combination self to the next combination in lexicographic order and returns Success. If no further combinations\nare available it returns Failure and leaves self unmodified. Starting with the first combination and repeatedly applying this function will\niterate through all possible combinations of a given order.",12,null],[11,"prev","","This function steps backwards from the combination self to the previous combination in lexicographic order, returning Success. If no\nprevious combination is available it returns Failure and leaves self unmodified.",12,null],[11,"drop","","",12,null],[11,"fmt","","",12,null],[0,"complex","rgsl::types","",null,null],[3,"ComplexF64","rgsl::types::complex","",null,null],[12,"data","","",13,null],[3,"ComplexF32","","",null,null],[12,"data","","",14,null],[11,"rect","","This function uses the rectangular Cartesian components (x,y) to return the complex number z = x + i y.",13,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"complexf64"}}],[11,"polar","","This function returns the complex number z = r \\exp(i \\theta) = r (\\cos(\\theta) + i \\sin(\\theta)) from the polar representation (r,theta).",13,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"complexf64"}}],[11,"arg","","This function returns the argument of the complex number z, \\arg(z), where -\\pi &lt; \\arg(z) &lt;= \\pi.",13,null],[11,"abs","","This function returns the magnitude of the complex number z, |z|.",13,null],[11,"abs2","","This function returns the squared magnitude of the complex number z, |z|^2.",13,null],[11,"logabs","","This function returns the natural logarithm of the magnitude of the complex number z, \\log|z|.\nIt allows an accurate evaluation of \\log|z| when |z| is close to one.\nThe direct evaluation of log(gsl_complex_abs(z)) would lead to a loss of precision in this case.",13,null],[11,"add","","This function returns the sum of the complex numbers a and b, z=a+b.",13,null],[11,"sub","","This function returns the difference of the complex numbers a and b, z=a-b.",13,null],[11,"mul","","This function returns the product of the complex numbers a and b, z=ab.",13,null],[11,"div","","This function returns the quotient of the complex numbers a and b, z=a/b.",13,null],[11,"add_real","","This function returns the sum of the complex number a and the real number x, z=a+x.",13,null],[11,"sub_real","","This function returns the difference of the complex number a and the real number x, z=a-x.",13,null],[11,"mul_real","","This function returns the product of the complex number a and the real number x, z=ax.",13,null],[11,"div_real","","This function returns the quotient of the complex number a and the real number x, z=a/x.",13,null],[11,"add_imag","","This function returns the sum of the complex number a and the imaginary number iy, z=a+iy.",13,null],[11,"sub_imag","","This function returns the difference of the complex number a and the imaginary number iy, z=a-iy.",13,null],[11,"mul_imag","","This function returns the product of the complex number a and the imaginary number iy, z=a*(iy).",13,null],[11,"div_imag","","This function returns the quotient of the complex number a and the imaginary number iy, z=a/(iy).",13,null],[11,"conjugate","","This function returns the complex conjugate of the complex number z, z^* = x - i y.",13,null],[11,"inverse","","This function returns the inverse, or reciprocal, of the complex number z, 1/z = (x - i y)/(x^2 + y^2).",13,null],[11,"negative","","This function returns the negative of the complex number z, -z = (-x) + i(-y).",13,null],[11,"sqrt","","This function returns the square root of the complex number z, \\sqrt z.\nThe branch cut is the negative real axis. The result always lies in the right half of the complex plane.",13,null],[11,"sqrt_real","","This function returns the complex square root of the real number x, where x may be negative.",13,{"inputs":[{"name":"f64"}],"output":{"name":"complexf64"}}],[11,"pow","","The function returns the complex number z raised to the complex power a, z^a.\nThis is computed as \\exp(\\log(z)*a) using complex logarithms and complex exponentials.",13,null],[11,"pow_real","","This function returns the complex number z raised to the real power x, z^x.",13,null],[11,"exp","","This function returns the complex exponential of the complex number z, \\exp(z).",13,null],[11,"log","","This function returns the complex natural logarithm (base e) of the complex number z, \\log(z).\nThe branch cut is the negative real axis.",13,null],[11,"log10","","This function returns the complex base-10 logarithm of the complex number z, \\log_10 (z).",13,null],[11,"log_b","","This function returns the complex base-b logarithm of the complex number z, \\log_b(z).\nThis quantity is computed as the ratio \\log(z)/\\log(b).",13,null],[11,"sin","","This function returns the complex sine of the complex number z, \\sin(z) = (\\exp(iz) - \\exp(-iz))/(2i).",13,null],[11,"cos","","This function returns the complex cosine of the complex number z, \\cos(z) = (\\exp(iz) + \\exp(-iz))/2.",13,null],[11,"tan","","This function returns the complex tangent of the complex number z, \\tan(z) = \\sin(z)/\\cos(z).",13,null],[11,"sec","","This function returns the complex secant of the complex number z, \\sec(z) = 1/\\cos(z).",13,null],[11,"csc","","This function returns the complex cosecant of the complex number z, \\csc(z) = 1/\\sin(z).",13,null],[11,"cot","","This function returns the complex cotangent of the complex number z, \\cot(z) = 1/\\tan(z).",13,null],[11,"arcsin","","This function returns the complex arcsine of the complex number z, \\arcsin(z).\nThe branch cuts are on the real axis, less than -1 and greater than 1.",13,null],[11,"arcsin_real","","This function returns the complex arcsine of the real number z, \\arcsin(z).",13,{"inputs":[{"name":"f64"}],"output":{"name":"complexf64"}}],[11,"arccos","","This function returns the complex arccosine of the complex number z, \\arccos(z).\nThe branch cuts are on the real axis, less than -1 and greater than 1.",13,null],[11,"arccos_real","","This function returns the complex arccosine of the real number z, \\arccos(z).",13,{"inputs":[{"name":"f64"}],"output":{"name":"complexf64"}}],[11,"arctan","","This function returns the complex arctangent of the complex number z, \\arctan(z).\nThe branch cuts are on the imaginary axis, below -i and above i.",13,null],[11,"arcsec","","This function returns the complex arcsecant of the complex number z, \\arcsec(z) = \\arccos(1/z).",13,null],[11,"arcsec_real","","This function returns the complex arcsecant of the real number z, \\arcsec(z) = \\arccos(1/z).",13,{"inputs":[{"name":"f64"}],"output":{"name":"complexf64"}}],[11,"arccsc","","This function returns the complex arccosecant of the complex number z, \\arccsc(z) = \\arcsin(1/z).",13,null],[11,"arccsc_real","","This function returns the complex arccosecant of the real number z, \\arccsc(z) = \\arcsin(1/z).",13,{"inputs":[{"name":"f64"}],"output":{"name":"complexf64"}}],[11,"arccot","","This function returns the complex arccotangent of the complex number z, \\arccot(z) = \\arctan(1/z).",13,null],[11,"sinh","","This function returns the complex hyperbolic sine of the complex number z, \\sinh(z) = (\\exp(z) - \\exp(-z))/2.",13,null],[11,"cosh","","This function returns the complex hyperbolic cosine of the complex number z, \\cosh(z) = (\\exp(z) + \\exp(-z))/2.",13,null],[11,"tanh","","This function returns the complex hyperbolic tangent of the complex number z, \\tanh(z) = \\sinh(z)/\\cosh(z).",13,null],[11,"sech","","This function returns the complex hyperbolic secant of the complex number z, \\sech(z) = 1/\\cosh(z).",13,null],[11,"csch","","This function returns the complex hyperbolic cosecant of the complex number z, \\csch(z) = 1/\\sinh(z).",13,null],[11,"coth","","This function returns the complex hyperbolic cotangent of the complex number z, \\coth(z) = 1/\\tanh(z).",13,null],[11,"arcsinh","","This function returns the complex hyperbolic arcsine of the complex number z, \\arcsinh(z).\nThe branch cuts are on the imaginary axis, below -i and above i.",13,null],[11,"arccosh","","This function returns the complex hyperbolic arccosine of the complex number z, \\arccosh(z).\nThe branch cut is on the real axis, less than 1.\nNote that in this case we use the negative square root in formula 4.6.21 of Abramowitz &amp; Stegun giving \\arccosh(z)=\\log(z-\\sqrt{z^2-1}).",13,null],[11,"arccosh_real","","This function returns the complex hyperbolic arccosine of the real number z, \\arccosh(z).",13,{"inputs":[{"name":"f64"}],"output":{"name":"complexf64"}}],[11,"arctanh","","This function returns the complex hyperbolic arctangent of the complex number z, \\arctanh(z).\nThe branch cuts are on the real axis, less than -1 and greater than 1.",13,null],[11,"arctanh_real","","This function returns the complex hyperbolic arctangent of the real number z, \\arctanh(z).",13,{"inputs":[{"name":"f64"}],"output":{"name":"complexf64"}}],[11,"arcsech","","This function returns the complex hyperbolic arcsecant of the complex number z, \\arcsech(z) = \\arccosh(1/z).",13,null],[11,"arccsch","","This function returns the complex hyperbolic arccosecant of the complex number z, \\arccsch(z) = \\arcsin(1/z).",13,null],[11,"arccoth","","This function returns the complex hyperbolic arccotangent of the complex number z, \\arccoth(z) = \\arctanh(1/z).",13,null],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"default","","",13,{"inputs":[],"output":{"name":"complexf64"}}],[11,"fmt","","",14,null],[11,"clone","","",14,null],[11,"default","","",14,{"inputs":[],"output":{"name":"complexf32"}}],[0,"discrete_hankel","rgsl::types","#Discrete Hankel Transforms",null,null],[3,"DiscreteHankel","rgsl::types::discrete_hankel","",null,null],[11,"new","","This function allocates a Discrete Hankel transform object of size size.",15,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"new_with_init","","This function allocates a Discrete Hankel transform object of size size and initializes it for the given values of nu and xmax.",15,{"inputs":[{"name":"usize"},{"name":"f64"},{"name":"f64"}],"output":{"name":"option"}}],[11,"init","","This function initializes the transform self for the given values of nu and xmax.",15,null],[11,"apply","","This function applies the transform t to the array f_in whose size is equal to the size of the transform. The result is stored in the array\nf_out which must be of the same length.",15,null],[11,"x_sample","","This function returns the value of the n-th sample point in the unit interval, (j_{\\nu,n+1}/j_{\\nu,M}) X. These are the points where the\nfunction f(t) is assumed to be sampled.",15,null],[11,"k_sample","","This function returns the value of the n-th sample point in “k-space”, j_{\\nu,n+1}/X.",15,null],[11,"drop","","",15,null],[0,"eigen_symmetric_workspace","rgsl::types","#Real Symmetric Matrices",null,null],[3,"EigenSymmetricWorkspace","rgsl::types::eigen_symmetric_workspace","",null,null],[3,"EigenSymmetricVWorkspace","","",null,null],[3,"EigenHermitianWorkspace","","",null,null],[3,"EigenHermitianVWorkspace","","",null,null],[3,"EigenNonSymmWorkspace","","",null,null],[3,"EigenNonSymmVWorkspace","","",null,null],[3,"EigenGenSymmWorkspace","","",null,null],[3,"EigenGenSymmVWorkspace","","",null,null],[3,"EigenGenHermWorkspace","","",null,null],[3,"EigenGenHermVWorkspace","","",null,null],[3,"EigenGenWorkspace","","",null,null],[3,"EigenGenVWorkspace","","",null,null],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n real symmetric matrices. The size of the workspace is O(2n).",16,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"symm","","This function computes the eigenvalues of the real symmetric matrix A. Additional workspace of the appropriate size must be provided in\nw. The diagonal and lower triangular part of A are destroyed during the computation, but the strict upper triangular part is not referenced.\nThe eigenvalues are stored in the vector eval and are unordered.",16,null],[11,"drop","","",16,null],[11,"new","","This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n real symmetric matrices. The size of the workspace is O(4n).",17,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"symmv","","This function computes the eigenvalues and eigenvectors of the real symmetric matrix A. Additional workspace of the appropriate size must\nbe provided in w. The diagonal and lower triangular part of A are destroyed during the computation, but the strict upper triangular part\nis not referenced. The eigenvalues are stored in the vector eval and are unordered. The corresponding eigenvectors are stored in the columns\nof the matrix evec. For example, the eigenvector in the first column corresponds to the first eigenvalue. The eigenvectors are guaranteed\nto be mutually orthogonal and normalised to unit magnitude.",17,null],[11,"drop","","",17,null],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n complex hermitian matrices. The size of the workspace is O(3n).",18,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"herm","","This function computes the eigenvalues of the complex hermitian matrix A. Additional workspace of the appropriate size must be provided\nin w. The diagonal and lower triangular part of A are destroyed during the computation, but the strict upper triangular part is not\nreferenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored in the vector\neval and are unordered.",18,null],[11,"drop","","",18,null],[11,"new","","This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n complex hermitian matrices. The size of the\nworkspace is O(5n).",19,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"hermv","","This function computes the eigenvalues and eigenvectors of the complex hermitian matrix A. Additional workspace of the appropriate size\nmust be provided in w. The diagonal and lower triangular part of A are destroyed during the computation, but the strict upper triangular\npart is not referenced. The imaginary parts of the diagonal are assumed to be zero and are not referenced. The eigenvalues are stored\nin the vector eval and are unordered. The corresponding complex eigenvectors are stored in the columns of the matrix evec. For example,\nthe eigenvector in the first column corresponds to the first eigenvalue. The eigenvectors are guaranteed to be mutually orthogonal and\nnormalised to unit magnitude.",19,null],[11,"drop","","",19,null],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n complex hermitian matrices. The size of the workspace is O(3n).",20,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"params","","This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_nonsymm.",20,null],[11,"nonsymm","","This function computes the eigenvalues of the real nonsymmetric matrix A and stores them in the vector eval. If T is desired, it is stored\nin the upper portion of A on output. Otherwise, on output, the diagonal of A will contain the 1-by-1 real eigenvalues and 2-by-2 complex\nconjugate eigenvalue systems, and the rest of A is destroyed. In rare cases, this function may fail to find all eigenvalues. If this\nhappens, an error code is returned and the number of converged eigenvalues is stored in w-&gt;n_evals. The converged eigenvalues are stored\nin the beginning of eval.",20,null],[11,"nonsymm_Z","","This function is identical to gsl_eigen_nonsymm except that it also computes the Schur vectors and stores them into Z.",20,null],[11,"n_evals","","",20,null],[11,"drop","","",20,null],[11,"new","","This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n real nonsymmetric matrices. The size of the\nworkspace is O(5n).",21,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"params","","This function sets parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_nonsymmv. If balance\nis set to 1, a balancing transformation is applied to the matrix. See gsl_eigen_nonsymm_params for more information. Balancing is turned\noff by default since it does not preserve the orthogonality of the Schur vectors.",21,null],[11,"nonsymmv","","This function computes eigenvalues and right eigenvectors of the n-by-n real nonsymmetric matrix A. It first calls gsl_eigen_nonsymm to\ncompute the eigenvalues, Schur form T, and Schur vectors. Then it finds eigenvectors of T and backtransforms them using the Schur vectors.\nThe Schur vectors are destroyed in the process, but can be saved by using gsl_eigen_nonsymmv_Z. The computed eigenvectors are normalized\nto have unit magnitude. On output, the upper portion of A contains the Schur form T. If gsl_eigen_nonsymm fails, no eigenvectors are\ncomputed, and an error code is returned.",21,null],[11,"nonsymmv_Z","","This function is identical to gsl_eigen_nonsymmv except that it also saves the Schur vectors into Z.",21,null],[11,"drop","","",21,null],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n real generalized symmetric-definite eigensystems. The size of\nthe workspace is O(2n).",22,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"gensymm","","This function computes the eigenvalues of the real generalized symmetric-definite matrix pair (A, B), and stores them in eval, using\nthe method outlined above. On output, B contains its Cholesky decomposition and A is destroyed.",22,null],[11,"drop","","",22,null],[11,"new","","This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n real generalized symmetric-definite eigensystems. The size of\nthe workspace is O(4n).",23,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"gensymmv","","This function computes the eigenvalues and eigenvectors of the real generalized symmetric-definite matrix pair (A, B), and stores them\nin eval and evec respectively. The computed eigenvectors are normalized to have unit magnitude. On output, B contains its Cholesky\ndecomposition and A is destroyed.",23,null],[11,"drop","","",23,null],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n complex generalized hermitian-definite eigensystems. The size\nof the workspace is O(3n).",24,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"genherm","","This function computes the eigenvalues of the complex generalized hermitian-definite matrix pair (A, B), and stores them in eval, using\nthe method outlined above. On output, B contains its Cholesky decomposition and A is destroyed.",24,null],[11,"drop","","",24,null],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n complex generalized hermitian-definite eigensystems. The size\nof the workspace is O(3n).",25,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"genhermv","","This function computes the eigenvalues of the complex generalized hermitian-definite matrix pair (A, B), and stores them in eval, using\nthe method outlined above. On output, B contains its Cholesky decomposition and A is destroyed.",25,null],[11,"drop","","",25,null],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n real generalized nonsymmetric eigensystems. The size of the\nworkspace is O(n).",26,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"params","","This function sets some parameters which determine how the eigenvalue problem is solved in subsequent calls to gsl_eigen_gen.",26,null],[11,"gen","","This function computes the eigenvalues of the real generalized nonsymmetric matrix pair (A, B), and stores them as pairs in (alpha,\nbeta), where alpha is complex and beta is real. If \\beta_i is non-zero, then \\lambda = \\alpha_i / \\beta_i is an eigenvalue. Likewise,\nif \\alpha_i is non-zero, then \\mu = \\beta_i / \\alpha_i is an eigenvalue of the alternate problem \\mu A y = B y. The elements of beta\nare normalized to be non-negative.",26,null],[11,"gen_QZ","","This function is identical to gsl_eigen_gen except that it also computes the left and right Schur vectors and stores them into Q and\nZ respectively.",26,null],[11,"drop","","",26,null],[11,"new","","This function allocates a workspace for computing eigenvalues of n-by-n real generalized nonsymmetric eigensystems. The size of the\nworkspace is O(n).",27,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"genv","","This function computes eigenvalues and right eigenvectors of the n-by-n real generalized nonsymmetric matrix pair (A, B). The eigenvalues\nare stored in (alpha, beta) and the eigenvectors are stored in evec. It first calls gsl_eigen_gen to compute the eigenvalues, Schur forms,\nand Schur vectors. Then it finds eigenvectors of the Schur forms and backtransforms them using the Schur vectors. The Schur vectors are\ndestroyed in the process, but can be saved by using gsl_eigen_genv_QZ. The computed eigenvectors are normalized to have unit magnitude.\nOn output, (A, B) contains the generalized Schur form (S, T). If gsl_eigen_gen fails, no eigenvectors are computed, and an error code is\nreturned.",27,null],[11,"genv_QZ","","This function is identical to gsl_eigen_genv except that it also computes the left and right Schur vectors and stores them into Q and Z\nrespectively.",27,null],[11,"drop","","",27,null],[0,"fast_fourier_transforms","rgsl::types","",null,null],[3,"FftComplexWaveTable","rgsl::types::fast_fourier_transforms","",null,null],[3,"FftComplexWorkspace","","",null,null],[11,"new","","This function prepares a trigonometric lookup table for a complex FFT of length n. The function returns a pointer to the newly allocated\ngsl_fft_complex_wavetable if no errors were detected, and a null pointer in the case of error. The length n is factorized into a product\nof subtransforms, and the factors and their trigonometric coefficients are stored in the wavetable. The trigonometric coefficients are\ncomputed using direct calls to sin and cos, for accuracy. Recursion relations could be used to compute the lookup table faster, but if\nan application performs many FFTs of the same length then this computation is a one-off overhead which does not affect the final throughput.",28,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"factor","","",28,null],[11,"drop","","",28,null],[11,"new","","This function allocates a workspace for a complex transform of length n.",29,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"drop","","",29,null],[0,"histograms","rgsl::types","#Histograms",null,null],[3,"Histogram","rgsl::types::histograms","",null,null],[3,"HistogramPdf","","The probability distribution function for a histogram consists of a set of bins which measure the probability of an event falling into a\ngiven range of a continuous variable x. A probability distribution function is defined by the following struct, which actually stores the\ncumulative probability distribution function. This is the natural quantity for generating samples via the inverse transform method, because\nthere is a one-to-one mapping between the cumulative probability distribution and the range [0,1]. It can be shown that by taking a uniform\nrandom number in this range and finding its corresponding coordinate in the cumulative probability distribution we obtain samples with the\ndesired probability distribution.",null,null],[3,"Histogram2D","","A two dimensional histogram consists of a set of bins which count the number of events falling in a given area of the (x,y) plane. The simplest\nway to use a two dimensional histogram is to record two-dimensional position information, n(x,y). Another possibility is to form a joint\ndistribution by recording related variables. For example a detector might record both the position of an event (x) and the amount of energy\nit deposited E. These could be histogrammed as the joint distribution n(x,E).",null,null],[3,"Histogram2DPdf","","As in the one-dimensional case, a two-dimensional histogram made by counting events can be regarded as a measurement of a probability distribution.\nAllowing for statistical error, the height of each bin represents the probability of an event where (x,y) falls in the range of that bin. For a\ntwo-dimensional histogram the probability distribution takes the form p(x,y) dx dy where,",null,null],[11,"new","","This function allocates memory for a histogram with n bins, and returns a pointer to a newly created gsl_histogram struct. If insufficient\nmemory is available a null pointer is returned and the error handler is invoked with an error code of Value::NoMem. The bins and ranges are\nnot initialized, and should be prepared using one of the range-setting functions below in order to make the histogram ready for use.",30,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"set_ranges","","This function sets the ranges of the existing histogram h using the array range of size size. The values of the histogram bins are reset\nto zero. The range array should contain the desired bin limits. The ranges can be arbitrary, subject to the restriction that they are\nmonotonically increasing.",30,null],[11,"set_ranges_uniform","","This function sets the ranges of the existing histogram h to cover the range xmin to xmax uniformly. The values of the histogram bins\nare reset to zero. The bin ranges are shown in the table below,",30,null],[11,"copy","","This function copies the self histogram into the pre-existing histogram dest, making dest into an exact copy of self. The two histograms\nmust be of the same size.",30,null],[11,"clone","","This function returns a pointer to a newly created histogram which is an exact copy of the self histogram.",30,null],[11,"increment","","This function updates the self histogram by adding one (1.0) to the bin whose range contains the coordinate x.",30,null],[11,"accumulate","","This function is similar to gsl_histogram_increment but increases the value of the appropriate bin in the histogram h by the floating-point\nnumber weight.",30,null],[11,"get","","This function returns the contents of the i-th bin of the histogram h. If i lies outside the valid range of indices for the histogram then\nthe error handler is called with an error code of Value::Dom and the function returns 0.",30,null],[11,"get_range","","This function finds the upper and lower range limits of the i-th bin of the self histogram. If the index i is valid then the corresponding\nrange limits are stored in lower and upper. The lower limit is inclusive (i.e. events with this coordinate are included in the bin) and\nthe upper limit is exclusive (i.e. events with the coordinate of the upper limit are excluded and fall in the neighboring higher bin,\nif it exists). The function returns 0 to indicate success. If i lies outside the valid range of indices for the histogram then\nthe error handler is called and the function returns an error code of Value::Dom.",30,null],[11,"max","","This function returns the maximum upper and minimum lower range limits and the number of bins of the self histogram. They provide a way\nof determining these values without accessing the gsl_histogram struct directly.",30,null],[11,"min","","This function returns the maximum upper and minimum lower range limits and the number of bins of the self histogram. They provide a way\nof determining these values without accessing the gsl_histogram struct directly.",30,null],[11,"bins","","This function returns the maximum upper and minimum lower range limits and the number of bins of the self histogram. They provide a way\nof determining these values without accessing the gsl_histogram struct directly.",30,null],[11,"reset","","This function resets all the bins in the self histogram to zero.",30,null],[11,"find","","This function finds and sets the index i to the bin number which covers the coordinate x in the self histogram. The bin is located using\na binary search. The search includes an optimization for histograms with uniform range, and will return the correct bin immediately in\nthis case. If x is found in the range of the histogram then the function sets the index i and returns ::Value::Success. If x lies outside\nthe valid range of the histogram then the function returns Value::Dom and the error handler is invoked.",30,null],[11,"max_val","","This function returns the maximum value contained in the histogram bins.",30,null],[11,"max_bin","","This function returns the index of the bin containing the maximum value. In the case where several bins contain the same maximum value\nthe smallest index is returned.",30,null],[11,"min_val","","This function returns the minimum value contained in the histogram bins.",30,null],[11,"min_bin","","This function returns the index of the bin containing the minimum value. In the case where several bins contain the same maximum value\nthe smallest index is returned.",30,null],[11,"mean","","This function returns the mean of the histogrammed variable, where the histogram is regarded as a probability distribution. Negative\nbin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width.",30,null],[11,"sigma","","This function returns the standard deviation of the histogrammed variable, where the histogram is regarded as a probability distribution.\nNegative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width.",30,null],[11,"sum","","This function returns the sum of all bin values. Negative bin values are included in the sum.",30,null],[11,"equal_bins_p","","This function returns true if the all of the individual bin ranges of the two histograms are identical, and false otherwise.",30,null],[11,"add","","This function adds the contents of the bins in histogram other to the corresponding bins of self histogram, i.e. h&#39;_1(i) = h_1(i) + h_2(i).\nThe two histograms must have identical bin ranges.",30,null],[11,"sub","","This function subtracts the contents of the bins in histogram other from the corresponding bins of self histogram, i.e. h&#39;_1(i) = h_1(i) - h_2(i).\nThe two histograms must have identical bin ranges.",30,null],[11,"mul","","This function multiplies the contents of the bins of self histogram by the contents of the corresponding bins in other histogram, i.e. h&#39;_1(i) =\nh_1(i) * h_2(i). The two histograms must have identical bin ranges.",30,null],[11,"div","","This function divides the contents of the bins of self histogram by the contents of the corresponding bins in other histogram, i.e. h&#39;_1(i) = h_1(i)\n/ h_2(i). The two histograms must have identical bin ranges.",30,null],[11,"scale","","This function multiplies the contents of the bins of self histogram by the constant scale, i.e. h&#39;_1(i) = h_1(i) * scale.",30,null],[11,"shift","","This function shifts the contents of the bins of self histogram by the constant offset, i.e. h&#39;_1(i) = h_1(i) + offset.",30,null],[11,"print","","",30,null],[11,"drop","","",30,null],[11,"new","","This function allocates memory for a probability distribution with n bins and returns a pointer to a newly initialized gsl_histogram_pdf\nstruct. If insufficient memory is available a null pointer is returned and the error handler is invoked with an error code of Value::NoMem.",31,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"init","","This function initializes the probability distribution self with the contents of the histogram h. If any of the bins of h are negative then\nthe error handler is invoked with an error code of Value::Dom because a probability distribution cannot contain negative values.",31,null],[11,"sample","","This function uses r, a uniform random number between zero and one, to compute a single random sample from the probability distribution\nself. The algorithm used to compute the sample s is given by the following formula,",31,null],[11,"drop","","",31,null],[11,"new","","This function allocates memory for a two-dimensional histogram with nx bins in the x direction and ny bins in the y direction. The\nfunction returns a pointer to a newly created gsl_histogram2d struct. If insufficient memory is available a null pointer is returned\nand the error handler is invoked with an error code of Value::NoMem. The bins and ranges must be initialized with one of the\nfunctions below before the histogram is ready for use.",32,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"set_ranges","","This function sets the ranges of the existing histogram h using the arrays xrange and yrange of size xsize and ysize respectively.\nThe values of the histogram bins are reset to zero.",32,null],[11,"set_ranges_uniform","","This function sets the ranges of the existing histogram h to cover the ranges xmin to xmax and ymin to ymax uniformly. The values\nof the histogram bins are reset to zero.",32,null],[11,"copy","","This function copies the histogram src into the pre-existing histogram dest, making dest into an exact copy of src. The two histograms\nmust be of the same size.",32,null],[11,"clone","","his function returns a pointer to a newly created histogram which is an exact copy of the histogram self.",32,null],[11,"increment","","This function updates the histogram h by adding one (1.0) to the bin whose x and y ranges contain the coordinates (x,y).",32,null],[11,"accumulate","","This function is similar to gsl_histogram2d_increment but increases the value of the appropriate bin in the histogram h by the floating-point\nnumber weight.",32,null],[11,"get","","This function returns the contents of the (i,j)-th bin of the histogram h. If (i,j) lies outside the valid range of indices for the\nhistogram then the error handler is called with an error code of Value::Dom and the function returns 0.",32,null],[11,"get_xrange","","This function finds the upper and lower range limits of the i-th and j-th bins in the x and y directions of the histogram h. The range\nlimits are stored in xlower and xupper or ylower and yupper. The lower limits are inclusive (i.e. events with these coordinates are included\nin the bin) and the upper limits are exclusive (i.e. events with the value of the upper limit are not included and fall in the neighboring\nhigher bin, if it exists). The functions return 0 to indicate success. If i or j lies outside the valid range of indices for the histogram\nthen the error handler is called with an error code of Value::Dom.",32,null],[11,"get_yrange","","This function finds the upper and lower range limits of the i-th and j-th bins in the x and y directions of the histogram h. The range\nlimits are stored in xlower and xupper or ylower and yupper. The lower limits are inclusive (i.e. events with these coordinates are included\nin the bin) and the upper limits are exclusive (i.e. events with the value of the upper limit are not included and fall in the neighboring\nhigher bin, if it exists). The functions return 0 to indicate success. If i or j lies outside the valid range of indices for the histogram\nthen the error handler is called with an error code of Value::Dom.",32,null],[11,"xmax","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\nThey provide a way of determining these values without accessing the gsl_histogram2d struct directly.",32,null],[11,"xmin","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\nThey provide a way of determining these values without accessing the gsl_histogram2d struct directly.",32,null],[11,"nx","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\nThey provide a way of determining these values without accessing the gsl_histogram2d struct directly.",32,null],[11,"ymax","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\nThey provide a way of determining these values without accessing the gsl_histogram2d struct directly.",32,null],[11,"ymin","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\nThey provide a way of determining these values without accessing the gsl_histogram2d struct directly.",32,null],[11,"ny","","This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\nThey provide a way of determining these values without accessing the gsl_histogram2d struct directly.",32,null],[11,"reset","","This function resets all the bins of the histogram h to zero.",32,null],[11,"find","","This function finds and sets the indices i and j to the bin which covers the coordinates (x,y). The bin is located using a binary search.\nThe search includes an optimization for histograms with uniform ranges, and will return the correct bin immediately in this case. If\n(x,y) is found then the function sets the indices (i,j) and returns ::Value::Success. If (x,y) lies outside the valid range of the histogram\nthen the function returns Value::Dom and the error handler is invoked.",32,null],[11,"max_val","","This function returns the maximum value contained in the histogram bins.",32,null],[11,"max_bin","","This function finds the indices of the bin containing the maximum value in the histogram h and stores the result in (i,j). In the case\nwhere several bins contain the same maximum value the first bin found is returned.",32,null],[11,"min_val","","This function returns the minimum value contained in the histogram bins.",32,null],[11,"min_bin","","This function finds the indices of the bin containing the minimum value in the histogram h and stores the result in (i,j). In the case\nwhere several bins contain the same maximum value the first bin found is returned.",32,null],[11,"xmean","","This function returns the mean of the histogrammed x variable, where the histogram is regarded as a probability distribution. Negative\nbin values are ignored for the purposes of this calculation.",32,null],[11,"ymean","","This function returns the mean of the histogrammed y variable, where the histogram is regarded as a probability distribution. Negative\nbin values are ignored for the purposes of this calculation.",32,null],[11,"xsigma","","This function returns the standard deviation of the histogrammed x variable, where the histogram is regarded as a probability\ndistribution. Negative bin values are ignored for the purposes of this calculation.",32,null],[11,"ysigma","","This function returns the standard deviation of the histogrammed y variable, where the histogram is regarded as a probability\ndistribution. Negative bin values are ignored for the purposes of this calculation.",32,null],[11,"cov","","This function returns the covariance of the histogrammed x and y variables, where the histogram is regarded as a probability\ndistribution. Negative bin values are ignored for the purposes of this calculation.",32,null],[11,"sum","","This function returns the sum of all bin values. Negative bin values are included in the sum.",32,null],[11,"equal_bins_p","","This function returns 1 if all the individual bin ranges of the two histograms are identical, and 0 otherwise.",32,null],[11,"add","","This function adds the contents of the bins in histogram h2 to the corresponding bins of histogram h1, i.e. h&#39;_1(i,j) = h_1(i,j)\n+ h_2(i,j). The two histograms must have identical bin ranges.",32,null],[11,"sub","","This function subtracts the contents of the bins in histogram h2 from the corresponding bins of histogram h1, i.e. h&#39;_1(i,j) = h_1(i,j)\n- h_2(i,j). The two histograms must have identical bin ranges.",32,null],[11,"mul","","This function multiplies the contents of the bins of histogram h1 by the contents of the corresponding bins in histogram h2, i.e. h&#39;_1(i,j)\n= h_1(i,j) * h_2(i,j). The two histograms must have identical bin ranges.",32,null],[11,"div","","This function divides the contents of the bins of histogram h1 by the contents of the corresponding bins in histogram h2, i.e. h&#39;_1(i,j) =\nh_1(i,j) / h_2(i,j). The two histograms must have identical bin ranges.",32,null],[11,"scale","","This function multiplies the contents of the bins of histogram h by the constant scale, i.e. h&#39;_1(i,j) = h_1(i,j) scale.",32,null],[11,"shift","","This function shifts the contents of the bins of histogram h by the constant offset, i.e. h&#39;_1(i,j) = h_1(i,j) + offset.",32,null],[11,"drop","","",32,null],[11,"new","","This function allocates memory for a two-dimensional probability distribution of size nx-by-ny and returns a pointer to a newly initialized\ngsl_histogram2d_pdf struct. If insufficient memory is available a null pointer is returned and the error handler is invoked with an error\ncode of Value::NoMem.",33,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"init","","This function initializes the two-dimensional probability distribution calculated p from the histogram h. If any of the bins of h are\nnegative then the error handler is invoked with an error code of GSL_EDOM because a probability distribution cannot contain negative\nvalues.",33,null],[11,"sample","","This function uses two uniform random numbers between zero and one, r1 and r2, to compute a single random sample from the two-dimensional\nprobability distribution p.",33,null],[11,"drop","","",33,null],[0,"integration","rgsl::types","",null,null],[3,"IntegrationWorkspace","rgsl::types::integration","The QAG algorithm is a simple adaptive integration procedure. The integration region is divided into subintervals, and on each iteration\nthe subinterval with the largest estimated error is bisected. This reduces the overall error rapidly, as the subintervals become concentrated\naround local difficulties in the integrand. These subintervals are managed by a gsl_integration_workspace struct, which handles the memory\nfor the subinterval ranges, results and error estimates.",null,null],[3,"IntegrationQawsTable","","The QAWS algorithm is designed for integrands with algebraic-logarithmic singularities at the end-points of an integration region. In order\nto work efficiently the algorithm requires a precomputed table of Chebyshev moments.",null,null],[3,"IntegrationQawoTable","","The QAWO algorithm is designed for integrands with an oscillatory factor, \\sin(\\omega x) or \\cos(\\omega x). In order to work efficiently\nthe algorithm requires a table of Chebyshev moments which must be pre-computed with calls to the functions below.",null,null],[3,"CquadWorkspace","","CQUAD is a new doubly-adaptive general-purpose quadrature routine which can handle most types of singularities, non-numerical function\nvalues such as Inf or NaN, as well as some divergent integrals. It generally requires more function evaluations than the integration\nroutines in QUADPACK, yet fails less often for difficult integrands.",null,null],[3,"GLFixedTable","","The fixed-order Gauss-Legendre integration routines are provided for fast integration of smooth functions with known polynomial order.\nThe n-point Gauss-Legendre rule is exact for polynomials of order 2*n-1 or less. For example, these rules are useful when integrating\nbasis functions to form mass matrices for the Galerkin method. Unlike other numerical integration routines within the library, these\nroutines do not accept absolute or relative error bounds.",null,null],[11,"new","","This function allocates a workspace sufficient to hold n double precision intervals, their integration results and error estimates. One\nworkspace may be used multiple times as all necessary reinitialization is performed automatically by the integration routines.",34,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"qag","","This function applies an integration rule adaptively until an estimate of the integral of f over (a,b) is achieved within the desired\nabsolute and relative error limits, epsabs and epsrel. The function returns the final approximation, result, and an estimate of the\nabsolute error, abserr. The integration rule is determined by the value of key, which should be chosen from the following symbolic names,",34,null],[11,"qags","","This function applies the Gauss-Kronrod 21-point integration rule adaptively until an estimate of the integral of f over (a,b) is achieved\nwithin the desired absolute and relative error limits, epsabs and epsrel. The results are extrapolated using the epsilon-algorithm, which\naccelerates the convergence of the integral in the presence of discontinuities and integrable singularities. The function returns the\nfinal approximation from the extrapolation, result, and an estimate of the absolute error, abserr. The subintervals and their results are\nstored in the memory provided by workspace. The maximum number of subintervals is given by limit, which may not exceed the allocated size\nof the workspace.",34,null],[11,"qagp","","This function applies the adaptive integration algorithm QAGS taking account of the user-supplied locations of singular points. The array\npts of length npts should contain the endpoints of the integration ranges defined by the integration region and locations of the singularities.\nFor example, to integrate over the region (a,b) with break-points at x_1, x_2, x_3 (where a &lt; x_1 &lt; x_2 &lt; x_3 &lt; b) the following pts array\nshould be used",34,null],[11,"qagi","","This function computes the integral of the function f over the infinite interval (-\\infty,+\\infty). The integral is mapped onto the\nsemi-open interval (0,1] using the transformation x = (1-t)/t,",34,null],[11,"qagiu","","This function computes the integral of the function f over the semi-infinite interval (a,+\\infty). The integral is mapped onto the\nsemi-open interval (0,1] using the transformation x = a + (1-t)/t,",34,null],[11,"qagil","","This function computes the integral of the function f over the semi-infinite interval (-\\infty,b). The integral is mapped onto the semi-open\ninterval (0,1] using the transformation x = b - (1-t)/t,",34,null],[11,"qawc","","This function computes the Cauchy principal value of the integral of f over (a,b), with a singularity at c,",34,null],[11,"sort_results","","",34,null],[11,"qpsrt","","",34,null],[11,"sum_results","","",34,null],[11,"retrieve","","",34,null],[11,"update","","",34,null],[11,"set_initial_result","","",34,null],[11,"initialise","","",34,null],[11,"limit","","",34,null],[11,"size","","",34,null],[11,"drop","","",34,null],[11,"new","","This function allocates space for a gsl_integration_qaws_table struct describing a singular weight function W(x) with the parameters\n(\\alpha, \\beta, \\mu, \\nu),",35,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"i32"},{"name":"i32"}],"output":{"name":"option"}}],[11,"set","","This function modifies the parameters (\\alpha, \\beta, \\mu, \\nu)",35,null],[11,"qaws","","This function computes the integral of the function f(x) over the interval (a,b) with the singular weight function (x-a)^\\alpha\n(b-x)^\\beta \\log^\\mu (x-a) \\log^\\nu (b-x). The parameters of the weight function (\\alpha, \\beta, \\mu, \\nu) are taken from the\ntable self. The integral is,",35,null],[11,"drop","","",35,null],[11,"new","","This function allocates space for a gsl_integration_qawo_table struct and its associated workspace describing a sine or cosine weight\nfunction W(x) with the parameters (\\omega, L),",36,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"integrationqawo"},{"name":"usize"}],"output":{"name":"option"}}],[11,"set","","This function changes the parameters omega, L and sine of the existing self workspace.",36,null],[11,"set_length","","This function allows the length parameter l of the self workspace to be changed.",36,null],[11,"qawo","","This function uses an adaptive algorithm to compute the integral of f over (a,b) with the weight function \\sin(\\omega x) or \\cos(\\omega x)\ndefined by the table wf,",36,null],[11,"drop","","",36,null],[11,"new","","This function allocates a workspace sufficient to hold the data for n intervals. The number n is not the maximum number of intervals\nthat will be evaluated. If the workspace is full, intervals with smaller error estimates will be discarded. A minimum of 3 intervals\nis required and for most functions, a workspace of size 100 is sufficient.",37,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"cquad","","This function computes the integral of f over (a,b) within the desired absolute and relative error limits, epsabs and epsrel using\nthe CQUAD algorithm. The function returns the final approximation, result, an estimate of the absolute error, abserr, and the number\nof function evaluations required, nevals.",37,null],[11,"drop","","",37,null],[11,"new","","This function determines the Gauss-Legendre abscissae and weights necessary for an n-point fixed order integration scheme. If possible,\nhigh precision precomputed coefficients are used. If precomputed weights are not available, lower precision coefficients are computed\non the fly.",38,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"point","","For i in [0, …, t-&gt;n - 1], this function obtains the i-th Gauss-Legendre point xi and weight wi on the interval [a,b]. The points\nand weights are ordered by increasing point value. A function f may be integrated on [a,b] by summing wi * f(xi) over i.",38,null],[11,"glfixed","","This function applies the Gauss-Legendre integration rule contained in table self and returns the result.",38,null],[11,"drop","","",38,null],[0,"interpolation","rgsl::types","#Interpolation",null,null],[3,"InterpAccel","rgsl::types::interpolation","evaluation accelerator",null,null],[12,"cache","","cache of index",39,null],[12,"miss_count","","keep statistics",39,null],[12,"hit_count","","",39,null],[3,"Interp","","",null,null],[3,"InterpType","","",null,null],[3,"Spline","","general interpolation object",null,null],[11,"clone","","",39,null],[11,"new","","This function returns a pointer to an accelerator object, which is a kind of iterator for interpolation lookups. It tracks the state\nof lookups, thus allowing for application of various acceleration strategies.",39,{"inputs":[],"output":{"name":"interpaccel"}}],[11,"reset","","This function reinitializes the accelerator object acc. It should be used when the cached information is no longer applicable—for\nexample, when switching to a new dataset.",39,null],[11,"find","","This function performs a lookup action on the data array x_array of size size, using the given accelerator a. This is how lookups\nare performed during evaluation of an interpolation. The function returns an index i such that x_array[i] &lt;= x &lt; x_array[i+1].",39,null],[11,"new","","This function returns a pointer to a newly allocated interpolation object of type T for size data-points.",40,{"inputs":[{"name":"interptype"},{"name":"usize"}],"output":{"name":"option"}}],[11,"init","","This function initializes the interpolation object interp for the data (xa,ya) where xa and ya are arrays of size size. The interpolation\nobject (gsl_interp) does not save the data arrays xa and ya and only stores the static state computed from the data. The xa data array\nis always assumed to be strictly ordered, with increasing x values; the behavior for other arrangements is not defined.",40,null],[11,"name","","This function returns the name of the interpolation type used by interp. For example,",40,null],[11,"min_size","","This function returns the minimum number of points required by the interpolation object interp or interpolation type T. For example,\nAkima spline interpolation requires a minimum of 5 points.",40,null],[11,"drop","","",40,null],[11,"clone","","",41,null],[11,"min_size","","This function returns the minimum number of points required by the interpolation object interp or interpolation type T. For example,\nAkima spline interpolation requires a minimum of 5 points.",41,null],[11,"linear","","Linear interpolation. This interpolation method does not require any additional memory.",41,{"inputs":[],"output":{"name":"interptype"}}],[11,"polynomial","","Polynomial interpolation. This method should only be used for interpolating small numbers of points because polynomial interpolation\nintroduces large oscillations, even for well-behaved datasets. The number of terms in the interpolating polynomial is equal to the\nnumber of points.",41,{"inputs":[],"output":{"name":"interptype"}}],[11,"cspline","","Cubic spline with natural boundary conditions. The resulting curve is piecewise cubic on each interval, with matching first and second\nderivatives at the supplied data-points. The second derivative is chosen to be zero at the first point and last point.",41,{"inputs":[],"output":{"name":"interptype"}}],[11,"cspline_periodic","","Cubic spline with periodic boundary conditions. The resulting curve is piecewise cubic on each interval, with matching first and second\nderivatives at the supplied data-points. The derivatives at the first and last points are also matched. Note that the last point in\nthe data must have the same y-value as the first point, otherwise the resulting periodic interpolation will have a discontinuity at\nthe boundary.",41,{"inputs":[],"output":{"name":"interptype"}}],[11,"akima","","Non-rounded Akima spline with natural boundary conditions. This method uses the non-rounded corner algorithm of Wodicka.",41,{"inputs":[],"output":{"name":"interptype"}}],[11,"akima_periodic","","Non-rounded Akima spline with periodic boundary conditions. This method uses the non-rounded corner algorithm of Wodicka.",41,{"inputs":[],"output":{"name":"interptype"}}],[11,"new","","",42,{"inputs":[{"name":"interptype"},{"name":"usize"}],"output":{"name":"option"}}],[11,"init","","",42,null],[11,"name","","",42,null],[11,"min_size","","",42,null],[11,"eval","","",42,null],[11,"eval_e","","",42,null],[11,"eval_deriv","","",42,null],[11,"eval_deriv_e","","",42,null],[11,"eval_deriv2","","",42,null],[11,"eval_deriv2_e","","",42,null],[11,"eval_integ","","",42,null],[11,"eval_integ_e","","",42,null],[11,"drop","","",42,null],[0,"mathieu","rgsl::types","The routines described in this section compute the angular and radial Mathieu functions, and their characteristic values. Mathieu functions are the solutions of the following two differential equations:",null,null],[3,"MathieuWorkspace","rgsl::types::mathieu","The Mathieu functions can be computed for a single order or for multiple orders, using array-based routines.\nThe array-based routines require a preallocated workspace.",null,null],[11,"new","","This function returns a workspace for the array versions of the Mathieu routines.\nThe arguments n and qmax specify the maximum order and q-value of Mathieu functions which can be computed with this workspace.",43,{"inputs":[{"name":"usize"},{"name":"f64"}],"output":{"name":"option"}}],[11,"mathieu_a","","This routine computes the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.",43,null],[11,"mathieu_b","","This routine computes the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.",43,null],[11,"mathieu_a_array","","This routine computes a series of Mathieu characteristic values a_n(q), b_n(q) for n from order_min to order_max inclusive, storing the results in the array result_array.",43,null],[11,"mathieu_b_array","","This routine computes a series of Mathieu characteristic values a_n(q), b_n(q) for n from order_min to order_max inclusive, storing the results in the array result_array.",43,null],[11,"mathieu_ce","","This routine computes the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.",43,null],[11,"mathieu_se","","This routine computes the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.",43,null],[11,"mathieu_ce_array","","This routine computes a series of the angular Mathieu functions ce_n(q,x) and se_n(q,x) of order n from nmin to nmax inclusive, storing the results in the array result_array.",43,null],[11,"mathieu_se_array","","This routine computes a series of the angular Mathieu functions ce_n(q,x) and se_n(q,x) of order n from nmin to nmax inclusive, storing the results in the array result_array.",43,null],[11,"mathieu_Mc","","This routine computes the radial j-th kind Mathieu functions Mc_n^{(j)}(q,x) and Ms_n^{(j)}(q,x) of order n.",43,null],[11,"mathieu_Ms","","This routine computes the radial j-th kind Mathieu functions Mc_n^{(j)}(q,x) and Ms_n^{(j)}(q,x) of order n.",43,null],[11,"mathieu_Mc_array","","This routine computes a series of the radial Mathieu functions of kind j, with order from nmin to nmax inclusive, storing the results in the array result_array.",43,null],[11,"mathieu_Ms_array","","This routine computes a series of the radial Mathieu functions of kind j, with order from nmin to nmax inclusive, storing the results in the array result_array.",43,null],[11,"drop","","",43,null],[0,"matrix","rgsl::types","#Matrices",null,null],[3,"MatrixView","rgsl::types::matrix","",null,null],[3,"MatrixF64","","",null,null],[3,"MatrixF32","","",null,null],[11,"from_matrix","","These functions return a matrix view of a submatrix of the matrix m. The upper-left element of the submatrix is the element (k1,k2)\nof the original matrix. The submatrix has n1 rows and n2 columns. The physical number of columns in memory given by tda is unchanged.\nMathematically, the (i,j)-th element of the new matrix is given by,",44,{"inputs":[{"name":"matrixf64"},{"name":"usize"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"matrixview"}}],[11,"from_array","","These functions return a matrix view of the array base. The matrix has n1 rows and n2 columns. The physical number of columns in memory\nis also given by n2. Mathematically, the (i,j)-th element of the new matrix is given by,",44,null],[11,"from_array_with_tda","","These functions return a matrix view of the array base with a physical number of columns tda which may differ from the corresponding\ndimension of the matrix. The matrix has n1 rows and n2 columns, and the physical number of columns in memory is given by tda.\nMathematically, the (i,j)-th element of the new matrix is given by,",44,null],[11,"from_vector","","These functions return a matrix view of the vector v. The matrix has n1 rows and n2 columns. The vector must have unit stride. The\nphysical number of columns in memory is also given by n2. Mathematically, the (i,j)-th element of the new matrix is given by,",44,{"inputs":[{"name":"vectorf64"},{"name":"usize"},{"name":"usize"}],"output":{"name":"matrixview"}}],[11,"from_vector_with_tda","","These functions return a matrix view of the vector v with a physical number of columns tda which may differ from the corresponding\nmatrix dimension. The vector must have unit stride. The matrix has n1 rows and n2 columns, and the physical number of columns in\nmemory is given by tda. Mathematically, the (i,j)-th element of the new matrix is given by,",44,{"inputs":[{"name":"vectorf64"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"matrixview"}}],[11,"matrix","","",44,null],[11,"new","","Creates a new MatrixF64 with all elements set to zero",45,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get","","This function returns the (i,j)-th element of the matrix.\nIf y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.",45,null],[11,"set","","This function sets the value of the (i,j)-th element of the matrix to value.\nIf y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.",45,null],[11,"set_all","","This function sets all the elements of the matrix to the value x.",45,null],[11,"set_zero","","This function sets all the elements of the matrix to zero.",45,null],[11,"set_identity","","This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero.\nThis applies to both square and rectangular matrices.",45,null],[11,"copy_from","","This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.",45,null],[11,"copy_to","","This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.",45,null],[11,"swap","","This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.",45,null],[11,"get_row","","This function copies the elements of the y-th row of the matrix into the returned vector.",45,null],[11,"get_col","","This function copies the elements of the x-th column of the matrix into the returned vector.",45,null],[11,"set_row","","This function copies the elements of the vector v into the y-th row of the matrix.\nThe length of the vector must be the same as the length of the row.",45,null],[11,"set_col","","This function copies the elements of the vector v into the x-th column of the matrix.\nThe length of the vector must be the same as the length of the column.",45,null],[11,"swap_rows","","This function exchanges the y1-th and y2-th rows of the matrix in-place.",45,null],[11,"swap_columns","","This function exchanges the x1-th and x2-th columns of the matrix in-place.",45,null],[11,"swap_row_col","","This function exchanges the i-th row and j-th column of the matrix in-place.\nThe matrix must be square for this operation to be possible.",45,null],[11,"transpose_memcpy","","This function returns the transpose of the matrix by copying the elements into it.\nThis function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.",45,null],[11,"transpose","","This function replaces the matrix m by its transpose by copying the elements of the matrix in-place.\nThe matrix must be square for this operation to be possible.",45,null],[11,"add","","This function adds the elements of the other matrix to the elements of the self matrix.\nThe result self(i,j) &lt;- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",45,null],[11,"sub","","This function subtracts the elements of the other matrix from the elements of the self matrix.\nThe result self(i,j) &lt;- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",45,null],[11,"mul_elements","","This function multiplies the elements of the self matrix by the elements of the other matrix.\nThe result self(i,j) &lt;- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",45,null],[11,"div_elements","","This function divides the elements of the self matrix by the elements of the other matrix.\nThe result self(i,j) &lt;- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",45,null],[11,"scale","","This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) &lt;- x self(i,j) is stored in self.",45,null],[11,"add_constant","","This function adds the constant value x to the elements of the self matrix. The result self(i,j) &lt;- self(i,j) + x is stored in self.",45,null],[11,"max","","This function returns the maximum value in the self matrix.",45,null],[11,"min","","This function returns the minimum value in the self matrix.",45,null],[11,"minmax","","This function returns the minimum and maximum values in the self matrix, storing them in min_out and max_out.",45,null],[11,"max_index","","This function returns the indices of the maximum value in the self matrix, storing them in imax and jmax.\nWhen there are several equal maximum elements then the first element found is returned, searching in row-major order.",45,null],[11,"min_index","","This function returns the indices of the minimum value in the self matrix, storing them in imin and jmin.\nWhen there are several equal minimum elements then the first element found is returned, searching in row-major order.",45,null],[11,"minmax_index","","This function returns the indices of the minimum and maximum values in the self matrix, storing them in (imin,jmin) and (imax,jmax).\nWhen there are several equal minimum or maximum elements then the first elements found are returned, searching in row-major order.",45,null],[11,"is_null","","This function returns true if all the elements of the self matrix are stricly zero.",45,null],[11,"is_pos","","This function returns true if all the elements of the self matrix are stricly positive.",45,null],[11,"is_neg","","This function returns true if all the elements of the self matrix are stricly negative.",45,null],[11,"is_non_neg","","This function returns true if all the elements of the self matrix are stricly non-negative.",45,null],[11,"equal","","This function returns true if all elements of the two matrix are equal.",45,null],[11,"size1","","",45,null],[11,"size2","","",45,null],[11,"clone","","",45,null],[11,"drop","","",45,null],[11,"fmt","","",45,null],[11,"new","","Creates a new MatrixF64 with all elements set to zero",46,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get","","This function returns the (i,j)-th element of the matrix.\nIf y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.",46,null],[11,"set","","This function sets the value of the (i,j)-th element of the matrix to value.\nIf y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.",46,null],[11,"set_all","","This function sets all the elements of the matrix to the value x.",46,null],[11,"set_zero","","This function sets all the elements of the matrix to zero.",46,null],[11,"set_identity","","This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero.\nThis applies to both square and rectangular matrices.",46,null],[11,"copy_from","","This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.",46,null],[11,"copy_to","","This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.",46,null],[11,"swap","","This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.",46,null],[11,"get_row","","This function copies the elements of the y-th row of the matrix into the returned vector.",46,null],[11,"get_col","","This function copies the elements of the x-th column of the matrix into the returned vector.",46,null],[11,"set_row","","This function copies the elements of the vector v into the y-th row of the matrix.\nThe length of the vector must be the same as the length of the row.",46,null],[11,"set_col","","This function copies the elements of the vector v into the x-th column of the matrix.\nThe length of the vector must be the same as the length of the column.",46,null],[11,"swap_rows","","This function exchanges the y1-th and y2-th rows of the matrix in-place.",46,null],[11,"swap_columns","","This function exchanges the x1-th and x2-th columns of the matrix in-place.",46,null],[11,"swap_row_col","","This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.",46,null],[11,"transpose_memcpy","","This function returns the transpose of the matrix by copying the elements into it.\nThis function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.",46,null],[11,"transpose","","This function replaces the matrix m by its transpose by copying the elements of the matrix in-place.\nThe matrix must be square for this operation to be possible.",46,null],[11,"add","","This function adds the elements of the other matrix to the elements of the self matrix.\nThe result self(i,j) &lt;- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",46,null],[11,"sub","","This function subtracts the elements of the other matrix from the elements of the self matrix.\nThe result self(i,j) &lt;- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",46,null],[11,"mul_elements","","This function multiplies the elements of the self matrix by the elements of the other matrix.\nThe result self(i,j) &lt;- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",46,null],[11,"div_elements","","This function divides the elements of the self matrix by the elements of the other matrix.\nThe result self(i,j) &lt;- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",46,null],[11,"scale","","This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) &lt;- x self(i,j) is stored in self.",46,null],[11,"add_constant","","This function adds the constant value x to the elements of the self matrix. The result self(i,j) &lt;- self(i,j) + x is stored in self.",46,null],[11,"max","","This function returns the maximum value in the self matrix.",46,null],[11,"min","","This function returns the minimum value in the self matrix.",46,null],[11,"minmax","","This function returns the minimum and maximum values in the self matrix, storing them in min_out and max_out.",46,null],[11,"max_index","","This function returns the indices of the maximum value in the self matrix, storing them in imax and jmax.\nWhen there are several equal maximum elements then the first element found is returned, searching in row-major order.",46,null],[11,"min_index","","This function returns the indices of the minimum value in the self matrix, storing them in imin and jmin.\nWhen there are several equal minimum elements then the first element found is returned, searching in row-major order.",46,null],[11,"minmax_index","","This function returns the indices of the minimum and maximum values in the self matrix, storing them in (imin,jmin) and (imax,jmax).\nWhen there are several equal minimum or maximum elements then the first elements found are returned, searching in row-major order.",46,null],[11,"is_null","","This function returns true if all the elements of the self matrix are stricly zero.",46,null],[11,"is_pos","","This function returns true if all the elements of the self matrix are stricly positive.",46,null],[11,"is_neg","","This function returns true if all the elements of the self matrix are stricly negative.",46,null],[11,"is_non_neg","","This function returns true if all the elements of the self matrix are stricly non-negative.",46,null],[11,"equal","","This function returns true if all elements of the two matrix are equal.",46,null],[11,"clone","","",46,null],[11,"drop","","",46,null],[11,"fmt","","",46,null],[0,"matrix_complex","rgsl::types","",null,null],[3,"MatrixComplexF64","rgsl::types::matrix_complex","",null,null],[3,"MatrixComplexF32","","",null,null],[11,"new","","Creates a new MatrixF64 with all elements set to zero",47,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get","","This function returns the (i,j)-th element of the matrix.\nIf y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.",47,null],[11,"set","","This function sets the value of the (i,j)-th element of the matrix to value.\nIf y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.",47,null],[11,"set_all","","This function sets all the elements of the matrix to the value x.",47,null],[11,"set_zero","","This function sets all the elements of the matrix to zero.",47,null],[11,"set_identity","","This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero.\nThis applies to both square and rectangular matrices.",47,null],[11,"copy_from","","This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.",47,null],[11,"copy_to","","This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.",47,null],[11,"swap","","This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.",47,null],[11,"get_row","","This function copies the elements of the y-th row of the matrix into the returned vector.",47,null],[11,"get_col","","This function copies the elements of the x-th column of the matrix into the returned vector.",47,null],[11,"set_row","","This function copies the elements of the vector v into the y-th row of the matrix.\nThe length of the vector must be the same as the length of the row.",47,null],[11,"set_col","","This function copies the elements of the vector v into the x-th column of the matrix.\nThe length of the vector must be the same as the length of the column.",47,null],[11,"swap_rows","","This function exchanges the y1-th and y2-th rows of the matrix in-place.",47,null],[11,"swap_columns","","This function exchanges the x1-th and x2-th columns of the matrix in-place.",47,null],[11,"swap_row_col","","This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.",47,null],[11,"transpose_memcpy","","This function returns the transpose of the matrix by copying the elements into it.\nThis function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.",47,null],[11,"transpose","","This function replaces the matrix m by its transpose by copying the elements of the matrix in-place.\nThe matrix must be square for this operation to be possible.",47,null],[11,"add","","This function adds the elements of the other matrix to the elements of the self matrix.\nThe result self(i,j) &lt;- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",47,null],[11,"sub","","This function subtracts the elements of the other matrix from the elements of the self matrix.\nThe result self(i,j) &lt;- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",47,null],[11,"mul_elements","","This function multiplies the elements of the self matrix by the elements of the other matrix.\nThe result self(i,j) &lt;- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",47,null],[11,"div_elements","","This function divides the elements of the self matrix by the elements of the other matrix.\nThe result self(i,j) &lt;- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",47,null],[11,"scale","","This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) &lt;- x self(i,j) is stored in self.",47,null],[11,"add_constant","","This function adds the constant value x to the elements of the self matrix. The result self(i,j) &lt;- self(i,j) + x is stored in self.",47,null],[11,"is_null","","This function returns true if all the elements of the self matrix are stricly zero.",47,null],[11,"is_pos","","This function returns true if all the elements of the self matrix are stricly positive.",47,null],[11,"is_neg","","This function returns true if all the elements of the self matrix are stricly negative.",47,null],[11,"is_non_neg","","This function returns true if all the elements of the self matrix are stricly non-negative.",47,null],[11,"equal","","This function returns true if all elements of the two matrix are equal.",47,null],[11,"clone","","",47,null],[11,"drop","","",47,null],[11,"fmt","","",47,null],[11,"new","","Creates a new MatrixF64 with all elements set to zero",48,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get","","This function returns the (i,j)-th element of the matrix.\nIf y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.",48,null],[11,"set","","This function sets the value of the (i,j)-th element of the matrix to value.\nIf y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.",48,null],[11,"set_all","","This function sets all the elements of the matrix to the value x.",48,null],[11,"set_zero","","This function sets all the elements of the matrix to zero.",48,null],[11,"set_identity","","This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero.\nThis applies to both square and rectangular matrices.",48,null],[11,"copy_from","","This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.",48,null],[11,"copy_to","","This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.",48,null],[11,"swap","","This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.",48,null],[11,"get_row","","This function copies the elements of the y-th row of the matrix into the returned vector.",48,null],[11,"get_col","","This function copies the elements of the x-th column of the matrix into the returned vector.",48,null],[11,"set_row","","This function copies the elements of the vector v into the y-th row of the matrix.\nThe length of the vector must be the same as the length of the row.",48,null],[11,"set_col","","This function copies the elements of the vector v into the x-th column of the matrix.\nThe length of the vector must be the same as the length of the column.",48,null],[11,"swap_rows","","This function exchanges the y1-th and y2-th rows of the matrix in-place.",48,null],[11,"swap_columns","","This function exchanges the x1-th and x2-th columns of the matrix in-place.",48,null],[11,"swap_row_col","","This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.",48,null],[11,"transpose_memcpy","","This function returns the transpose of the matrix by copying the elements into it.\nThis function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.",48,null],[11,"transpose","","This function replaces the matrix m by its transpose by copying the elements of the matrix in-place.\nThe matrix must be square for this operation to be possible.",48,null],[11,"add","","This function adds the elements of the other matrix to the elements of the self matrix.\nThe result self(i,j) &lt;- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",48,null],[11,"sub","","This function subtracts the elements of the other matrix from the elements of the self matrix.\nThe result self(i,j) &lt;- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",48,null],[11,"mul_elements","","This function multiplies the elements of the self matrix by the elements of the other matrix.\nThe result self(i,j) &lt;- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",48,null],[11,"div_elements","","This function divides the elements of the self matrix by the elements of the other matrix.\nThe result self(i,j) &lt;- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.",48,null],[11,"scale","","This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) &lt;- x self(i,j) is stored in self.",48,null],[11,"add_constant","","This function adds the constant value x to the elements of the self matrix. The result self(i,j) &lt;- self(i,j) + x is stored in self.",48,null],[11,"is_null","","This function returns true if all the elements of the self matrix are stricly zero.",48,null],[11,"is_pos","","This function returns true if all the elements of the self matrix are stricly positive.",48,null],[11,"is_neg","","This function returns true if all the elements of the self matrix are stricly negative.",48,null],[11,"is_non_neg","","This function returns true if all the elements of the self matrix are stricly non-negative.",48,null],[11,"equal","","This function returns true if all elements of the two matrix are equal.",48,null],[11,"clone","","",48,null],[11,"drop","","",48,null],[11,"fmt","","",48,null],[0,"minimizer","rgsl::types","#One dimensional Minimization",null,null],[3,"Minimizer","rgsl::types::minimizer","",null,null],[3,"MinimizerType","","",null,null],[12,"name","","",49,null],[11,"new","","This function returns a pointer to a newly allocated instance of a minimizer of type T. For example, the following code creates an\ninstance of a golden section minimizer,",50,{"inputs":[{"name":"minimizertype"}],"output":{"name":"option"}}],[11,"set","","This function sets, or resets, an existing minimizer s to use the function f and the initial search interval [x_lower, x_upper], with\na guess for the location of the minimum x_minimum.",50,null],[11,"set_with_values","","This function is equivalent to gsl_min_fminimizer_set but uses the values f_minimum, f_lower and f_upper instead of computing\nf(x_minimum), f(x_lower) and f(x_upper).",50,null],[11,"name","","This function returns a pointer to the name of the minimizer. For example,",50,null],[11,"x_minimum","","This function returns the current estimate of the position of the minimum for the minimizer s.",50,null],[11,"x_lower","","This function returns the current upper and lower bound of the interval for the minimizer s.",50,null],[11,"x_upper","","/// This function returns the current upper and lower bound of the interval for the minimizer s.",50,null],[11,"f_minimum","","This function returns the value of the function at the current estimate of the minimum and at the upper and lower bounds of the\ninterval for the minimizer s.",50,null],[11,"f_lower","","This function returns the value of the function at the current estimate of the minimum and at the upper and lower bounds of the\ninterval for the minimizer s.",50,null],[11,"f_upper","","This function returns the value of the function at the current estimate of the minimum and at the upper and lower bounds of the\ninterval for the minimizer s.",50,null],[11,"iterate","","This function performs a single iteration of the minimizer s. If the iteration encounters an unexpected problem then an error code\nwill be returned,",50,null],[11,"drop","","",50,null],[11,"golden_section","","The golden section algorithm is the simplest method of bracketing the minimum of a function. It is the slowest algorithm provided\nby the library, with linear convergence.",49,{"inputs":[],"output":{"name":"minimizertype"}}],[11,"brent","","The Brent minimization algorithm combines a parabolic interpolation with the golden section algorithm. This produces a fast algorithm\nwhich is still robust.",49,{"inputs":[],"output":{"name":"minimizertype"}}],[11,"quad_golden","","This is a variant of Brent’s algorithm which uses the safeguarded step-length algorithm of Gill and Murray.",49,{"inputs":[],"output":{"name":"minimizertype"}}],[11,"clone","","",49,null],[0,"monte_carlo","rgsl::types","#Monte Carlo Integration",null,null],[3,"PlainMonteCarlo","rgsl::types::monte_carlo","The plain Monte Carlo algorithm samples points randomly from the integration region to estimate the integral and its error. Using this algorithm\nthe estimate of the integral E(f; N) for N randomly distributed points x_i is given by,",null,null],[3,"MiserMonteCarlo","","The MISER algorithm of Press and Farrar is based on recursive stratified sampling. This technique aims to reduce the overall integration error\nby concentrating integration points in the regions of highest variance.",null,null],[3,"MiserParams","","",null,null],[12,"estimate_frac","","This parameter specifies the fraction of the currently available number of function calls which\nare allocated to estimating the variance at each recursive step. The default value is 0.1.",51,null],[12,"min_calls","","This parameter specifies the minimum number of function calls required for each estimate of the\nvariance. If the number of function calls allocated to the estimate using estimate_frac falls\nbelow min_calls then min_calls are used instead. This ensures that each estimate maintains a\nreasonable level of accuracy. The default value of min_calls is 16 * dim.",51,null],[12,"min_calls_per_bisection","","This parameter specifies the minimum number of function calls required to proceed with a bisection\nstep. When a recursive step has fewer calls available than min_calls_per_bisection it performs\na plain Monte Carlo estimate of the current sub-region and terminates its branch of the recursion.\nThe default value of this parameter is 32 * min_calls.",51,null],[12,"alpha","","This parameter controls how the estimated variances for the two sub-regions of a bisection are\ncombined when allocating points. With recursive sampling the overall variance should scale better\nthan 1/N, since the values from the sub-regions will be obtained using a procedure which explicitly\nminimizes their variance. To accommodate this behavior the MISER algorithm allows the total variance\nto depend on a scaling parameter \\alpha,",51,null],[12,"dither","","This parameter introduces a random fractional variation of size dither into each bisection, which\ncan be used to break the symmetry of integrands which are concentrated near the exact center of\nthe hypercubic integration region. The default value of dither is zero, so no variation is introduced.\nIf needed, a typical value of dither is 0.1.",51,null],[3,"VegasMonteCarlo","","The VEGAS algorithm of Lepage is based on importance sampling. It samples points from the probability\ndistribution described by the function |f|, so that the points are concentrated in the regions that\nmake the largest contribution to the integral.",null,null],[11,"new","","This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions.",52,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"init","","This function initializes a previously allocated integration state. This allows an existing workspace to be reused for different\nintegrations.",52,null],[11,"integrate","","This routines uses the plain Monte Carlo algorithm to integrate the function f over the dim-dimensional hypercubic region defined\nby the lower and upper limits in the arrays xl and xu, each of the same size. The integration uses a fixed number of function calls\ncalls, and obtains random sampling points using the random number generator r. A previously allocated workspace s must be supplied.\nThe result of the integration is returned in result, with an estimated absolute error abserr.",52,null],[11,"drop","","",52,null],[11,"new","","This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions. The workspace is used to maintain\nthe state of the integration.",53,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"init","","This function initializes a previously allocated integration state. This allows an existing workspace to be reused for different integrations.",53,null],[11,"integrate","","This routines uses the MISER Monte Carlo algorithm to integrate the function f over the dim-dimensional hypercubic region defined by\nthe lower and upper limits in the arrays xl and xu, each of size dim. The integration uses a fixed number of function calls calls,\nand obtains random sampling points using the random number generator r. A previously allocated workspace s must be supplied. The result\nof the integration is returned in result, with an estimated absolute error abserr.",53,null],[11,"get_params","","This function copies the parameters of the integrator state into the user-supplied params structure.",53,null],[11,"set_params","","This function sets the integrator parameters based on values provided in the params structure.",53,null],[11,"drop","","",53,null],[11,"new","","This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions.\nThe workspace is used to maintain the state of the integration.",54,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"init","","This function initializes a previously allocated integration state. This allows an existing workspace\nto be reused for different integrations.",54,null],[11,"integrate","","This routines uses the VEGAS Monte Carlo algorithm to integrate the function f over the dim-dimensional\nhypercubic region defined by the lower and upper limits in the arrays xl and xu, each of size dim.\nThe integration uses a fixed number of function calls calls, and obtains random sampling points using\nthe random number generator r. A previously allocated workspace s must be supplied. The result of the\nintegration is returned in result, with an estimated absolute error abserr. The result and its error\nestimate are based on a weighted average of independent samples. The chi-squared per degree of freedom\nfor the weighted average is returned via the state struct component, s-&gt;chisq, and must be consistent\nwith 1 for the weighted average to be reliable.",54,null],[11,"chisq","","This function returns the chi-squared per degree of freedom for the weighted estimate of the integral.\nThe returned value should be close to 1. A value which differs significantly from 1 indicates that\nthe values from different iterations are inconsistent. In this case the weighted error will be\nunder-estimated, and further iterations of the algorithm are needed to obtain reliable results.",54,null],[11,"runval","","This function returns the raw (unaveraged) values of the integral result and its error sigma from\nthe most recent iteration of the algorithm.",54,null],[11,"drop","","",54,null],[0,"multifit_solver","rgsl::types","#Nonlinear Least-Squares Fitting",null,null],[3,"MultiFitFunction","rgsl::types::multifit_solver","",null,null],[12,"f","","",55,null],[12,"n","","number of functions",55,null],[12,"p","","number of independent variables",55,null],[12,"params","","",55,null],[3,"MultiFitFdfSolver","","",null,null],[12,"x","","",56,null],[12,"f","","",56,null],[12,"j","","",56,null],[12,"dx","","",56,null],[3,"MultiFitFdfSolverType","","",null,null],[3,"MultiFitFunctionFdf","","",null,null],[12,"f","","",57,null],[12,"df","","",57,null],[12,"fdf","","",57,null],[12,"n","","",57,null],[12,"p","","",57,null],[12,"params","","",57,null],[11,"new","","This function returns a pointer to a newly allocated instance of a solver of type T for n observations and p parameters. The number\nof observations n must be greater than or equal to parameters p.",56,{"inputs":[{"name":"multifitfdfsolvertype"},{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"set","","This function initializes, or reinitializes, an existing solver s to use the function f and the initial guess x.",56,null],[11,"name","","",56,null],[11,"iterate","","This function performs a single iteration of the solver s. If the iteration encounters an unexpected problem then an error code\nwill be returned. The solver maintains a current estimate of the best-fit parameters at all times.",56,null],[11,"position","","This function returns the current position (i.e. best-fit parameters) s-&gt;x of the solver s.",56,null],[11,"driver","","These functions iterate the solver s for a maximum of maxiter iterations. After each iteration, the system is tested for convergence\nusing gsl_multifit_test_delta with the error tolerances epsabs and epsrel.",56,null],[11,"drop","","",56,null],[11,"lmder","","",58,{"inputs":[],"output":{"name":"multifitfdfsolvertype"}}],[11,"lmsder","","",58,{"inputs":[],"output":{"name":"multifitfdfsolvertype"}}],[0,"multiset","rgsl::types","#Multisets",null,null],[3,"MultiSet","rgsl::types::multiset","",null,null],[11,"new","","This function allocates memory for a new multiset with parameters n, k. The multiset is not initialized and its elements are\nundefined. Use the function gsl_multiset_calloc if you want to create a multiset which is initialized to the lexicographically \nfirst multiset element. A null pointer is returned if insufficient memory is available to create the multiset.",59,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"new_init","","This function allocates memory for a new multiset with parameters n, k and initializes it to the lexicographically first multiset\nelement. A null pointer is returned if insufficient memory is available to create the multiset.",59,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"init_first","","This function initializes the multiset c to the lexicographically first multiset element, i.e. 0 repeated k times.",59,null],[11,"init_last","","This function initializes the multiset c to the lexicographically last multiset element, i.e. n-1 repeated k times.",59,null],[11,"copy","","This function copies the elements of the multiset self into the multiset dest. The two multisets must have the same size.",59,null],[11,"get","","This function returns the value of the i-th element of the multiset c. If i lies outside the allowed range of 0 to k-1 then the\nerror handler is invoked and 0 is returned.",59,null],[11,"n","","This function returns the range (n) of the multiset self.",59,null],[11,"k","","This function returns the number of elements (k) in the multiset self.",59,null],[11,"data","","This function returns a pointer to the array of elements in the multiset self.",59,null],[11,"valid","","This function checks that the multiset self is valid. The k elements should lie in the range 0 to n-1, with each value occurring in\nnondecreasing order.",59,null],[11,"next","","This function advances the multiset self to the next multiset element in lexicographic order and returns ::Value::Success. If no\nfurther multisets elements are available it returns enums::value::Failure and leaves self unmodified. Starting with the first multiset and\nrepeatedly applying this function will iterate through all possible multisets of a given order.",59,null],[11,"prev","","This function steps backwards from the multiset self to the previous multiset element in lexicographic order, returning ::Value::Success.\nIf no previous multiset is available it returns enums::value::Failure and leaves self unmodified.",59,null],[11,"print","","",59,null],[11,"drop","","",59,null],[0,"n_tuples","rgsl::types","#N-tuples",null,null],[3,"NTuples","rgsl::types::n_tuples","",null,null],[11,"create","","This function creates a new write-only ntuple file filename for ntuples of size size and returns a pointer to the newly created ntuple\nstruct. Any existing file with the same name is truncated to zero length and overwritten. A pointer to memory for the current ntuple\nrow ntuple_data must be supplied—this is used to copy ntuples in and out of the file.",60,{"inputs":[{"name":"str"},{"name":"t"}],"output":{"name":"option"}}],[11,"open","","This function opens an existing ntuple file filename for reading and returns a pointer to a corresponding ntuple struct. The ntuples\nin the file must have size size. A pointer to memory for the current ntuple row ntuple_data must be supplied—this is used to copy\nntuples in and out of the file.",60,{"inputs":[{"name":"str"},{"name":"t"}],"output":{"name":"option"}}],[11,"write","","This function writes the current ntuple ntuple-&gt;ntuple_data of size ntuple-&gt;size to the corresponding file.",60,null],[11,"bookdata","","This function is a synonym for NTuples::write.",60,null],[11,"read","","This function reads the current row of the ntuple file for ntuple and stores the values in ntuple-&gt;data.",60,null],[11,"project","","",60,null],[11,"drop","","",60,null],[0,"ordinary_differential_equations","rgsl::types","Numerical ODE solvers.",null,null],[3,"ODEiv2System","rgsl::types::ordinary_differential_equations","Description of a system of ODEs.",null,null],[3,"ODEiv2Step","","",null,null],[3,"ODEiv2StepType","","",null,null],[3,"ODEiv2Control","","",null,null],[3,"ODEiv2ControlType","","",null,null],[3,"ODEiv2Evolve","","",null,null],[3,"ODEiv2Driver","","",null,null],[11,"new","","Returns a new ODEiv2System with a given dimension and right-hand side.",61,{"inputs":[{"name":"usize"},{"name":"fnmut"}],"output":{"name":"odeiv2system"}}],[11,"with_jacobian","","Returns a new ODEiv2System with a jacobian function provided.",61,{"inputs":[{"name":"usize"},{"name":"fnmut"},{"name":"fnmut"}],"output":{"name":"odeiv2system"}}],[11,"new","","This function returns a pointer to a newly allocated instance of a stepping function of type T for a system of dim dimensions.\nPlease note that if you use a stepper method that requires access to a driver object, it is advisable to use a driver allocation\nmethod, which automatically allocates a stepper, too.",62,{"inputs":[{"name":"odeiv2steptype"},{"name":"usize"}],"output":{"name":"option"}}],[11,"reset","","This function resets the stepping function s. It should be used whenever the next use of s will not be a continuation of a previous\nstep.",62,null],[11,"name","","This function returns a pointer to the name of the stepping function. For example,",62,null],[11,"order","","This function returns the order of the stepping function on the previous step. The order can vary if the stepping function itself is\nadaptive.",62,null],[11,"set_driver","","This function sets a pointer of the driver object d for stepper s, to allow the stepper to access control (and evolve) object through\nthe driver object. This is a requirement for some steppers, to get the desired error level for internal iteration of stepper.\nAllocation of a driver object calls this function automatically.",62,null],[11,"apply","","This function applies the stepping function s to the system of equations defined by sys, using the step-size h to advance the system\nfrom time t and state y to time t+h. The new state of the system is stored in y on output, with an estimate of the absolute error\nin each component stored in yerr. If the argument dydt_in is not null it should point an array containing the derivatives for the\nsystem at time t on input. This is optional as the derivatives will be computed internally if they are not provided, but allows\nthe reuse of existing derivative information. On output the new derivatives of the system at time t+h will be stored in dydt_out\nif it is not null.",62,null],[11,"drop","","",62,null],[11,"clone","","",63,null],[11,"rk2","","Explicit embedded Runge-Kutta (2, 3) method.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"rk4","","Explicit 4th order (classical) Runge-Kutta. Error estimation is carried out by the step doubling method. For more efficient\nestimate of the error, use the embedded methods described below.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"rk45","","Explicit embedded Runge-Kutta-Fehlberg (4, 5) method. This method is a good general-purpose integrator.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"rkck","","Explicit embedded Runge-Kutta Cash-Karp (4, 5) method.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"rk8pd","","Explicit embedded Runge-Kutta Prince-Dormand (8, 9) method.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"rk1imp","","Implicit Gaussian first order Runge-Kutta. Also known as implicit Euler or backward Euler method. Error estimation is carried out by\nthe step doubling method. This algorithm requires the Jacobian and access to the driver object via gsl_odeiv2_step_set_driver.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"rk2imp","","Implicit Gaussian second order Runge-Kutta. Also known as implicit mid-point rule. Error estimation is carried out by the step doubling\nmethod. This stepper requires the Jacobian and access to the driver object via gsl_odeiv2_step_set_driver.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"rk4imp","","Implicit Gaussian 4th order Runge-Kutta. Error estimation is carried out by the step doubling method. This algorithm requires the\nJacobian and access to the driver object via gsl_odeiv2_step_set_driver.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"bsimp","","Implicit Bulirsch-Stoer method of Bader and Deuflhard. The method is generally suitable for stiff problems. This stepper requires\nthe Jacobian.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"msadams","","A variable-coefficient linear multistep Adams method in Nordsieck form. This stepper uses explicit Adams-Bashforth (predictor) and\nimplicit Adams-Moulton (corrector) methods in P(EC)^m functional iteration mode. Method order varies dynamically between 1 and 12.\nThis stepper requires the access to the driver object via gsl_odeiv2_step_set_driver.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"msbdf","","A variable-coefficient linear multistep backward differentiation formula (BDF) method in Nordsieck form. This stepper uses the explicit\nBDF formula as predictor and implicit BDF formula as corrector. A modified Newton iteration method is used to solve the system of\nnon-linear equations. Method order varies dynamically between 1 and 5. The method is generally suitable for stiff problems. This\nstepper requires the Jacobian and the access to the driver object via gsl_odeiv2_step_set_driver.",63,{"inputs":[],"output":{"name":"odeiv2steptype"}}],[11,"standard_new","","The standard control object is a four parameter heuristic based on absolute and relative errors eps_abs and eps_rel, and scaling\nfactors a_y and a_dydt for the system state y(t) and derivatives y&#39;(t) respectively.",64,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"option"}}],[11,"y_new","","This function creates a new control object which will keep the local error on each step within an absolute error of eps_abs and relative\nerror of eps_rel with respect to the solution y_i(t). This is equivalent to the standard control object with a_y=1 and a_dydt=0.",64,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"option"}}],[11,"yp_new","","This function creates a new control object which will keep the local error on each step within an absolute error of eps_abs and relative\nerror of eps_rel with respect to the derivatives of the solution y&#39;_i(t). This is equivalent to the standard control object with\na_y=0 and a_dydt=1.",64,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"option"}}],[11,"scaled_new","","This function creates a new control object which uses the same algorithm as gsl_odeiv2_control_standard_new but with an absolute error\nwhich is scaled for each component by the array scale_abs. The formula for D_i for this control object is,",64,null],[11,"alloc","","This function returns a pointer to a newly allocated instance of a control function of type T. This function is only needed for\ndefining new types of control functions. For most purposes the standard control functions described above should be sufficient.",64,{"inputs":[{"name":"odeiv2controltype"}],"output":{"name":"option"}}],[11,"init","","This function initializes the control function c with the parameters eps_abs (absolute error), eps_rel (relative error), a_y\n(scaling factor for y) and a_dydt (scaling factor for derivatives).",64,null],[11,"hadjust","","This function adjusts the step-size h using the control function c, and the current values of y, yerr and dydt. The stepping function\nstep is also needed to determine the order of the method. If the error in the y-values yerr is found to be too large then the step-size\nh is reduced and the function returns ODEiv::Dec. If the error is sufficiently small then h may be increased and\nODEiv::Inc is returned. The function returns ODEiv::Nil if the step-size is unchanged. The goal of the function is to estimate\nthe largest step-size which satisfies the user-specified accuracy requirements for the current point.",64,null],[11,"name","","This function returns a pointer to the name of the control function. For example,",64,null],[11,"errlevel","","This function calculates the desired error level of the ind-th component to errlev. It requires the value (y) and value of the derivative\n(dydt) of the component, and the current step size h.",64,null],[11,"set_driver","","This function sets a pointer of the driver object d for control object c.",64,null],[11,"drop","","",64,null],[11,"clone","","",65,null],[11,"scaled","","",65,{"inputs":[],"output":{"name":"odeiv2controltype"}}],[11,"standard","","",65,{"inputs":[],"output":{"name":"odeiv2controltype"}}],[11,"new","","This function returns a pointer to a newly allocated instance of an evolution function for a system of dim dimensions.",66,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"apply","","This function advances the system (e, sys) from time t and position y using the stepping function step. The new time and position\nare stored in t and y on output.",66,null],[11,"apply_fixed_step","","This function advances the ODE-system (e, sys, con) from time t and position y using the stepping function step by a specified step\nsize h. If the local error estimated by the stepping function exceeds the desired error level, the step is not taken and the function\nreturns enums::value::Failure. Otherwise the value returned by user function is returned.",66,null],[11,"reset","","This function resets the evolution function e. It should be used whenever the next use of e will not be a continuation of a previous\nstep.",66,null],[11,"set_driver","","This function sets a pointer of the driver object d for evolve object e.",66,null],[11,"drop","","",66,null],[11,"alloc_y_new","","These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise\nthe evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest\nof the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).",67,{"inputs":[{"name":"odeiv2system"},{"name":"odeiv2steptype"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"option"}}],[11,"alloc_yp_new","","These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise\nthe evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest\nof the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).",67,{"inputs":[{"name":"odeiv2system"},{"name":"odeiv2steptype"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"option"}}],[11,"alloc_standard_new","","These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise\nthe evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest\nof the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).",67,{"inputs":[{"name":"odeiv2system"},{"name":"odeiv2steptype"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"option"}}],[11,"alloc_scaled_new","","These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise\nthe evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest\nof the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).",67,null],[11,"set_hmin","","The function sets a minimum for allowed step size hmin for driver self. Default value is 0.",67,null],[11,"set_hmax","","The function sets a maximum for allowed step size hmax for driver self. Default value is ::DBL_MAX.",67,null],[11,"set_nmax","","The function sets a maximum for allowed number of steps nmax for driver self. Default value of 0 sets no limit for steps.",67,null],[11,"apply","","This function evolves the driver system d from t to t1. Initially vector y should contain the values of dependent variables at\npoint t. If the function is unable to complete the calculation, an error code from gsl_odeiv2_evolve_apply is returned, and t and\ny contain the values from last successful step.",67,null],[11,"apply_fixed_step","","This function evolves the driver system d from t with n steps of size h. If the function is unable to complete the calculation, an\nerror code from gsl_odeiv2_evolve_apply_fixed_step is returned, and t and y contain the values from last successful step.",67,null],[11,"reset","","This function resets the evolution and stepper objects.",67,null],[11,"reset_hstart","","The routine resets the evolution and stepper objects and sets new initial step size to hstart. This function can be used e.g. to\nchange the direction of integration.",67,null],[11,"drop","","",67,null],[0,"permutation","rgsl::types","",null,null],[3,"Permutation","rgsl::types::permutation","",null,null],[11,"new","","This function allocates memory for a new permutation of size n. The permutation is not initialized and its elements are undefined.\nUse the function gsl_permutation_calloc if you want to create a permutation which is initialized to the identity. A null pointer is\nreturned if insufficient memory is available to create the permutation.",68,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"new_with_init","","This function allocates memory for a new permutation of size n and initializes it to the identity. A null pointer is returned if\ninsufficient memory is available to create the permutation.",68,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"init","","This function initializes the permutation p to the identity, i.e. (0,1,2,…,n-1).",68,null],[11,"copy","","This function copies the elements of the permutation src into the permutation dest. The two permutations must have the same size.",68,null],[11,"get","","This function returns the value of the i-th element of the permutation p. If i lies outside the allowed range of 0 to n-1 then\nthe error handler is invoked and 0 is returned.",68,null],[11,"swap","","This function exchanges the i-th and j-th elements of the permutation p.",68,null],[11,"size","","This function returns the size of the permutation p.",68,null],[11,"data","","This function returns a pointer to the array of elements in the permutation p.",68,null],[11,"is_valid","","This function checks that the permutation p is valid. The n elements should contain each of the numbers 0 to n-1 once and only once.",68,null],[11,"reverse","","This function reverses the elements of the permutation p.",68,null],[11,"inverse","","This function computes the inverse of the permutation p, storing the result in inv.",68,null],[11,"next","","This function advances the permutation p to the next permutation in lexicographic order and returns GSL_SUCCESS. If no further\npermutations are available it returns GSL_FAILURE and leaves p unmodified. Starting with the identity permutation and repeatedly\napplying this function will iterate through all possible permutations of a given order.",68,null],[11,"prev","","This function steps backwards from the permutation p to the previous permutation in lexicographic order, returning GSL_SUCCESS.\nIf no previous permutation is available it returns GSL_FAILURE and leaves p unmodified.",68,null],[11,"permute","","This function applies the permutation to the array data of size n with stride stride.",68,null],[11,"permute_inverse","","This function applies the inverse of the permutation p to the array data of size n with stride stride.",68,null],[11,"permute_vector","","This function applies the permutation p to the elements of the vector v, considered as a row-vector acted on by a permutation\nmatrix from the right, v&#39; = v P. The j-th column of the permutation matrix P is given by the p_j-th column of the identity matrix.\nThe permutation p and the vector v must have the same length.",68,null],[11,"permute_vector_inverse","","This function applies the inverse of the permutation p to the elements of the vector v, considered as a row-vector acted on by an inverse permutation\nmatrix from the right, v&#39; = v P^T. Note that for permutation matrices the inverse is the same as the transpose. The j-th column of the permutation\nmatrix P is given by the p_j-th column of the identity matrix. The permutation p and the vector v must have the same length.",68,null],[11,"mul","","This function combines the two permutations pa and pb into a single permutation p, where p = pa * pb. The permutation p is equivalent to applying pb\nfirst and then pa.",68,null],[11,"linear_to_canonical","","This function computes the canonical form of the permutation self and stores it in the output argument q.",68,null],[11,"canonical_to_linear","","This function converts the self permutation in canonical form back into linear form storing it in the output argument p.",68,null],[11,"inversions","","This function counts the number of inversions in the self permutation. An inversion is any pair of elements that are not in order. For example, the\npermutation 2031 has three inversions, corresponding to the pairs (2,0) (2,1) and (3,1). The identity permutation has no inversions.",68,null],[11,"linear_cycles","","This function counts the number of cycles in the self permutation, given in linear form.",68,null],[11,"canonical_cycles","","This function counts the number of cycles in the self permutation, given in canonical form.",68,null],[11,"drop","","",68,null],[11,"fmt","","",68,null],[0,"polynomial","rgsl::types","#General Polynomial Equations",null,null],[3,"PolyComplex","rgsl::types::polynomial","",null,null],[11,"new","","This function allocates space for a gsl_poly_complex_workspace struct and a workspace suitable for solving a polynomial with n coefficients\nusing the routine gsl_poly_complex_solve.",69,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"solve","","This function computes the roots of the general polynomial P(x) = a_0 + a_1 x + a_2 x^2 + ... + a_{n-1} x^{n-1} using balanced-QR reduction\nof the companion matrix. The parameter n specifies the length of the coefficient array. The coefficient of the highest order term must be\nnon-zero. The function requires a workspace w of the appropriate size. The n-1 roots are returned in the packed complex array z of length\n2(n-1), alternating real and imaginary parts.",69,null],[11,"drop","","",69,null],[0,"qrng","rgsl::types","#Quasi-Random Sequences",null,null],[3,"QRng","rgsl::types::qrng","",null,null],[3,"QRngType","","",null,null],[11,"new","","This function returns a pointer to a newly-created instance of a quasi-random sequence generator of type T and dimension d. If\nthere is insufficient memory to create the generator then the function returns a null pointer and the error handler is invoked\nwith an error code of ::NoMem.",70,{"inputs":[{"name":"qrngtype"},{"name":"u32"}],"output":{"name":"option"}}],[11,"init","","This function reinitializes the generator self to its starting point. Note that quasi-random sequences do not use a seed and always\nproduce the same set of values.",70,null],[11,"get","","This function stores the next point from the sequence generator self in the array x. The space available for x must match the\ndimension of the generator. The point x will lie in the range 0 &lt; x_i &lt; 1 for each x_i.",70,null],[11,"name","","This function returns a pointer to the name of the generator.",70,null],[11,"size","","These functions return a pointer to the state of generator r and its size.",70,null],[11,"state","","These functions return a pointer to the state of generator r and its size.",70,null],[11,"copy","","This function copies the quasi-random sequence generator src into the pre-existing generator dest, making dest into an exact copy\nof src. The two generators must be of the same type.",70,null],[11,"clone","","This function returns a pointer to a newly created generator which is an exact copy of the generator self.",70,null],[11,"drop","","",70,null],[11,"clone","","",71,null],[11,"niederreiter_2","","This generator uses the algorithm described in Bratley, Fox, Niederreiter, ACM Trans. Model. Comp. Sim. 2, 195 (1992). It is valid\nup to 12 dimensions.",71,{"inputs":[],"output":{"name":"qrngtype"}}],[11,"sobol","","This generator uses the Sobol sequence described in Antonov, Saleev, USSR Comput. Maths. Math. Phys. 19, 252 (1980). It is valid\nup to 40 dimensions.",71,{"inputs":[],"output":{"name":"qrngtype"}}],[11,"halton","","These generators use the Halton and reverse Halton sequences described in J.H. Halton, Numerische Mathematik 2, 84-90 (1960) and\nB. Vandewoestyne and R. Cools Computational and Applied Mathematics 189, 1&amp;2, 341-361 (2006). They are valid up to 1229 dimensions.",71,{"inputs":[],"output":{"name":"qrngtype"}}],[11,"reversehalton","","",71,{"inputs":[],"output":{"name":"qrngtype"}}],[0,"ran_discrete","rgsl::types","Given K discrete events with different probabilities P[k], produce a random value k consistent with its probability.",null,null],[3,"RanDiscrete","rgsl::types::ran_discrete","",null,null],[11,"new","","This function returns a pointer to a structure that contains the lookup table for the discrete random number generator. The array P[] contains the probabilities of the discrete events;\nthese array elements must all be positive, but they needn’t add up to one (so you can think of them more generally as “weights”)—the preprocessor will normalize appropriately.\nThis return value is used as an argument for the gsl_ran_discrete function below.",72,null],[11,"discrete","","After the new, above, has been called, you use this function to get the discrete random numbers.",72,null],[11,"discrete_pdf","","Returns the probability P[k] of observing the variable k. Since P[k] is not stored as part of the lookup table, it must be recomputed; this computation takes O(K),\nso if K is large and you care about the original array P[k] used to create the lookup table, then you should just keep this original array P[k] around.",72,null],[11,"drop","","",72,null],[0,"result","rgsl::types","",null,null],[3,"Result","rgsl::types::result","The error handling form of the special functions always calculate an error estimate along with the value of the result.\nTherefore, structures are provided for amalgamating a value and error estimate.",null,null],[12,"val","","Contains the value.",73,null],[12,"err","","Contains an estimate of the absolute error in the value.",73,null],[3,"ResultE10","","In some cases, an overflow or underflow can be detected and handled by a function.\nIn this case, it may be possible to return a scaling exponent as well as an error/value pair in order to save the result from exceeding the dynamic range of the built-in types.",null,null],[12,"val","","Contains the value.",74,null],[12,"err","","Contains an estimate of the absolute error in the value.",74,null],[12,"e10","","Exponent field such that the actual result is obtained as result * 10^(e10).",74,null],[11,"clone","","",73,null],[11,"default","","",73,{"inputs":[],"output":{"name":"result"}}],[11,"new","","",73,{"inputs":[],"output":{"name":"result"}}],[11,"clone","","",74,null],[11,"default","","",74,{"inputs":[],"output":{"name":"resulte10"}}],[11,"new","","",74,{"inputs":[],"output":{"name":"resulte10"}}],[0,"series_acceleration","rgsl::types","#Series Acceleration",null,null],[3,"LevinUWorkspace","rgsl::types::series_acceleration","Workspace for Levin U Transform with error estimation",null,null],[3,"LevinUTruncWorkspace","","The following functions perform the same calculation without estimating the errors. They require O(N) storage instead of O(N^2).\nThis may be useful for summing many similar series where the size of the error has already been estimated reliably and is not\nexpected to change.",null,null],[11,"new","","This function allocates a workspace for a Levin u-transform of n terms. The size of the workspace is O(2n^2 + 3n).",75,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"accel","","This function takes the terms of a series in array of size array_size and computes the extrapolated limit of the series using a\nLevin u-transform. Additional working space must be provided in w. The extrapolated sum is stored in sum_accel, with an estimate\nof the absolute error stored in abserr. The actual term-by-term sum is returned in w-&gt;sum_plain. The algorithm calculates the\ntruncation error (the difference between two successive extrapolations) and round-off error (propagated from the individual terms)\nto choose an optimal number of terms for the extrapolation. All the terms of the series passed in through array should be non-zero.",75,null],[11,"sum_plain","","",75,null],[11,"terms_used","","",75,null],[11,"size","","",75,null],[11,"drop","","",75,null],[11,"new","","This function allocates a workspace for a Levin u-transform of n terms, without error estimation. The size of the workspace is O(3n).",76,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"accel","","This function takes the terms of a series in array of size array_size and computes the extrapolated limit of the series using a\nLevin u-transform. Additional working space must be provided in w. The extrapolated sum is stored in sum_accel. The actual\nterm-by-term sum is returned in w-&gt;sum_plain. The algorithm terminates when the difference between two successive extrapolations\nreaches a minimum or is sufficiently small. The difference between these two values is used as estimate of the error and is stored\nin abserr_trunc. To improve the reliability of the algorithm the extrapolated values are replaced by moving averages when\ncalculating the truncation error, smoothing out any fluctuations.",76,null],[11,"sum_plain","","",76,null],[11,"terms_used","","",76,null],[11,"size","","",76,null],[11,"drop","","",76,null],[0,"rng","rgsl::types","#Random Number Generation",null,null],[3,"Rng","rgsl::types::rng","",null,null],[3,"RngType","","",null,null],[5,"default","","",null,{"inputs":[],"output":{"name":"rngtype"}}],[0,"algorithms","","The functions described above make no reference to the actual algorithm used. This is deliberate so that you can switch algorithms without having\nto change any of your application source code. The library provides a large number of generators of different types, including simulation quality\ngenerators, generators provided for compatibility with other libraries and historical generators from the past.",null,null],[5,"mt19937","rgsl::types::rng::algorithms","The MT19937 generator of Makoto Matsumoto and Takuji Nishimura is a variant of the twisted generalized feedback shift-register algorithm, and\nis known as the “Mersenne Twister” generator. It has a Mersenne prime period of 2^19937 - 1 (about 10^6000) and is equi-distributed in 623 dimensions.\nIt has passed the DIEHARD statistical tests. It uses 624 words of state per generator and is comparable in speed to the other generators. The original\ngenerator used a default seed of 4357 and choosing s equal to zero in gsl_rng_set reproduces this. Later versions switched to 5489 as the default seed,\nyou can choose this explicitly via gsl_rng_set instead if you require it.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"ranlxs0","","The generator ranlxs0 is a second-generation version of the RANLUX algorithm of Lüscher, which produces “luxury random numbers”. This generator\nprovides single precision output (24 bits) at three luxury levels ranlxs0, ranlxs1 and ranlxs2, in increasing order of strength. It uses double-precision\nfloating point arithmetic internally and can be significantly faster than the integer version of ranlux, particularly on 64-bit architectures. The period\nof the generator is about 10^171. The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of\nrandomness. The higher luxury levels provide increased decorrelation between samples as an additional safety margin.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"ranlxs1","","The generator ranlxs0 is a second-generation version of the RANLUX algorithm of Lüscher, which produces “luxury random numbers”. This generator\nprovides single precision output (24 bits) at three luxury levels ranlxs0, ranlxs1 and ranlxs2, in increasing order of strength. It uses double-precision\nfloating point arithmetic internally and can be significantly faster than the integer version of ranlux, particularly on 64-bit architectures. The period\nof the generator is about 10^171. The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of\nrandomness. The higher luxury levels provide increased decorrelation between samples as an additional safety margin.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"ranlxs2","","The generator ranlxs0 is a second-generation version of the RANLUX algorithm of Lüscher, which produces “luxury random numbers”. This generator\nprovides single precision output (24 bits) at three luxury levels ranlxs0, ranlxs1 and ranlxs2, in increasing order of strength. It uses double-precision\nfloating point arithmetic internally and can be significantly faster than the integer version of ranlux, particularly on 64-bit architectures. The period\nof the generator is about 10^171. The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of\nrandomness. The higher luxury levels provide increased decorrelation between samples as an additional safety margin.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"ranlxd1","","This generator produces double precision output (48 bits) from the RANLXS generator. The library provides two luxury levels ranlxd1 and ranlxd2,\nin increasing order of strength.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"ranlxd2","","This generator produces double precision output (48 bits) from the RANLXS generator. The library provides two luxury levels ranlxd1 and ranlxd2,\nin increasing order of strength.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"ranlux","","The ranlux generator is an implementation of the original algorithm developed by Lüscher. It uses a lagged-fibonacci-with-skipping algorithm to\nproduce “luxury random numbers”. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers. This\nimplementation is based on integer arithmetic, while the second-generation versions RANLXS and RANLXD described above provide floating-point\nimplementations which will be faster on many platforms. The period of the generator is about 10^171. The algorithm has mathematically proven\nproperties and it can provide truly decorrelated numbers at a known level of randomness. The default level of decorrelation recommended by\nLüscher is provided by gsl_rng_ranlux, while gsl_rng_ranlux389 gives the highest level of randomness, with all 24 bits decorrelated. Both\ntypes of generator use 24 words of state per generator.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"ranlux389","","The ranlux generator is an implementation of the original algorithm developed by Lüscher. It uses a lagged-fibonacci-with-skipping algorithm to\nproduce “luxury random numbers”. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers. This\nimplementation is based on integer arithmetic, while the second-generation versions RANLXS and RANLXD described above provide floating-point\nimplementations which will be faster on many platforms. The period of the generator is about 10^171. The algorithm has mathematically proven\nproperties and it can provide truly decorrelated numbers at a known level of randomness. The default level of decorrelation recommended by\nLüscher is provided by gsl_rng_ranlux, while gsl_rng_ranlux389 gives the highest level of randomness, with all 24 bits decorrelated. Both\ntypes of generator use 24 words of state per generator.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"cmrg","","This is a combined multiple recursive generator by L’Ecuyer. Its sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"mrg","","This is a fifth-order multiple recursive generator by L’Ecuyer, Blouin and Coutre. Its sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"taus","","This is a maximally equidistributed combined Tausworthe generator by L’Ecuyer. The sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"taus2","","This is a maximally equidistributed combined Tausworthe generator by L’Ecuyer. The sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"gfsr4","","The gfsr4 generator is like a lagged-fibonacci generator, and produces each number as an xor’d sum of four previous values.",null,{"inputs":[],"output":{"name":"rngtype"}}],[0,"unix","rgsl::types::rng","The standard Unix random number generators rand, random and rand48 are provided as part of GSL. Although these generators are widely\navailable individually often they aren’t all available on the same platform. This makes it difficult to write portable code using them\nand so we have included the complete set of Unix generators in GSL for convenience. Note that these generators don’t produce high-quality\nrandomness and aren’t suitable for work requiring accurate statistics. However, if you won’t be measuring statistical quantities and just\nwant to introduce some variation into your program then these generators are quite acceptable.",null,null],[5,"rand","rgsl::types::rng::unix","This is the BSD rand generator. Its sequence is",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"random_bsd","","These generators implement the random family of functions, a set of linear feedback shift register generators originally used in BSD\nUnix. There are several versions of random in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older\nGNU/Linux systems) and a glibc2 version. Each version uses a different seeding procedure, and thus produces different sequences.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"random_libc5","","These generators implement the random family of functions, a set of linear feedback shift register generators originally used in BSD\nUnix. There are several versions of random in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older\nGNU/Linux systems) and a glibc2 version. Each version uses a different seeding procedure, and thus produces different sequences.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"random_glic2","","These generators implement the random family of functions, a set of linear feedback shift register generators originally used in BSD\nUnix. There are several versions of random in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older\nGNU/Linux systems) and a glibc2 version. Each version uses a different seeding procedure, and thus produces different sequences.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"rand48","","This is the Unix rand48 generator. Its sequence is",null,{"inputs":[],"output":{"name":"rngtype"}}],[0,"other","rgsl::types::rng","##Other random number generators",null,null],[5,"ranf","rgsl::types::rng::other","This is the CRAY random number generator RANF. Its sequence is",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"ranmar","","This is the RANMAR lagged-fibonacci generator of Marsaglia, Zaman and Tsang. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers.\nIt was included in the CERNLIB high-energy physics library.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"r250","","This is the shift-register generator of Kirkpatrick and Stoll. The sequence is based on the recurrence",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"tt800","","This is an earlier version of the twisted generalized feedback shift-register generator, and has been superseded by the development of MT19937. However, it is\nstill an acceptable generator in its own right. It has a period of 2^800 and uses 33 words of storage per generator.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"vax","","This is the VAX generator MTH$RANDOM. Its sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"transputer","","This is the random number generator from the INMOS Transputer Development system. Its sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"randu","","This is the IBM RANDU generator. Its sequence is",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"minstd","","This is Park and Miller’s “minimal standard” MINSTD generator, a simple linear congruence which takes care to avoid the major pitfalls of such algorithms. Its sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"uni","","This is a reimplementation of the 16-bit SLATEC random number generator RUNIF. A generalization of the generator to 32 bits is provided by gsl_rng_uni32.\nThe original source code is available from NETLIB.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"uni32","","This is a reimplementation of the 16-bit SLATEC random number generator RUNIF. A generalization of the generator to 32 bits is provided by gsl_rng_uni32.\nThe original source code is available from NETLIB.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"slatec","","This is the SLATEC random number generator RAND. It is ancient. The original source code is available from NETLIB.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"zuf","","This is the ZUFALL lagged Fibonacci series generator of Peterson. Its sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"knuthran2","","This is a second-order multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., page 108. Its sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"knuthran2002","","This is a second-order multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6. Knuth provides\nits C code. The updated routine gsl_rng_knuthran2002 is from the revised 9th printing and corrects some weaknesses in the earlier version,\nwhich is implemented as gsl_rng_knuthran.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"knuthran","","This is a second-order multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6. Knuth provides\nits C code. The updated routine gsl_rng_knuthran2002 is from the revised 9th printing and corrects some weaknesses in the earlier version,\nwhich is implemented as gsl_rng_knuthran.",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"borosh13","","This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"fishman18","","This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"fishman20","","This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"lecuyer21","","This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"waterman14","","This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"fishman2x","","This is the L’Ecuyer–Fishman random number generator. It is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., page 108. Its sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[5,"coveyou","","This is the Coveyou random number generator. It is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., Section 3.2.2. Its sequence is,",null,{"inputs":[],"output":{"name":"rngtype"}}],[11,"new","rgsl::types::rng","This function returns a pointer to a newly-created instance of a random number generator of type T. For example, the following code creates an instance of the Tausworthe generator,",77,{"inputs":[{"name":"rngtype"}],"output":{"name":"option"}}],[11,"set","","This function initializes (or ‘seeds’) the random number generator. If the generator is seeded with the same value of s on two different runs, the same stream of random numbers will be generated by successive calls to the routines below.\nIf different values of s &gt;= 1 are supplied, then the generated streams of random numbers should be completely different. If the seed s is zero then the standard seed from the original implementation is used instead.\nFor example, the original Fortran source code for the ranlux generator used a seed of 314159265, and so choosing s equal to zero reproduces this when using gsl_rng_ranlux.",77,null],[11,"get","","This function returns a random integer from the generator r. The minimum and maximum values depend on the algorithm used, but all integers in the range [min,max] are equally likely.\nThe values of min and max can be determined using the auxiliary functions gsl_rng_max (r) and gsl_rng_min (r).",77,null],[11,"uniform","","This function returns a double precision floating point number uniformly distributed in the range [0,1). The range includes 0.0 but excludes 1.0.\nThe value is typically obtained by dividing the result of gsl_rng_get(r) by gsl_rng_max(r) + 1.0 in double precision.\nSome generators compute this ratio internally so that they can provide floating point numbers with more than 32 bits of randomness (the maximum number of bits that can be portably represented in a single unsigned long int).",77,null],[11,"uniform_pos","","This function returns a positive double precision floating point number uniformly distributed in the range (0,1), excluding both 0.0 and 1.0.\nThe number is obtained by sampling the generator with the algorithm of gsl_rng_uniform until a non-zero value is obtained.\nYou can use this function if you need to avoid a singularity at 0.0.",77,null],[11,"uniform_int","","This function returns a random integer from 0 to n-1 inclusive by scaling down and/or discarding samples from the generator r.\nAll integers in the range [0,n-1] are produced with equal probability. For generators with a non-zero minimum value an offset is applied so that zero is returned with the correct probability.",77,null],[11,"get_name","","This function returns a pointer to the name of the generator. For example,",77,null],[11,"max","","This function returns the largest value that the get function can return.",77,null],[11,"min","","This function returns the smallest value that gsl_rng_get can return. Usually this value is zero.\nThere are some generators with algorithms that cannot return zero, and for these generators the minimum value is 1.",77,null],[11,"state","","This function returns a pointer to the state of generator r. You can use this information to access the state directly. For example, the following code will write the state of a generator to a stream,",77,null],[11,"copy","","This function copies the random number generator src into the pre-existing generator dest, making dest into an exact copy of src. The two generators must be of the same type.",77,null],[11,"size","","This function returns the size of the state of generator r. You can use this information to access the state directly. For example, the following code will write the state of a generator to a stream,",77,null],[11,"default_seed","","Equivalent to DefaultRngSeed",77,{"inputs":[],"output":{"name":"usize"}}],[11,"clone","","This function returns a pointer to a newly created generator which is an exact copy of the generator r.",77,null],[11,"drop","","",77,null],[11,"clone","","",78,null],[11,"name","","wrapper for name element",78,null],[11,"max","","wrapper for max element",78,null],[11,"min","","wrapper for min element",78,null],[11,"size","","wrapper for size element",78,null],[11,"types_setup","","This function returns a pointer to an array of all the available generator types, terminated by a null pointer.\nThe function should be called once at the start of the program, if needed. The following code fragment shows how to iterate over the array of generator types to print the names of the available algorithms,",78,{"inputs":[],"output":{"name":"vec"}}],[11,"env_setup","","This function reads the environment variables GSL_RNG_TYPE and GSL_RNG_SEED and uses their values to set the corresponding library variables gsl_rng_default and gsl_rng_default_seed. These global variables are defined as follows,",78,{"inputs":[],"output":{"name":"option"}}],[0,"vector","rgsl::types","#Vectors",null,null],[3,"VectorView","rgsl::types::vector","",null,null],[3,"VectorF32","","",null,null],[3,"VectorF64","","",null,null],[5,"wrap","","",null,null],[11,"from_vector","","These functions return a vector view of a subvector of another vector v. The start of the new vector is offset by offset elements\nfrom the start of the original vector. The new vector has n elements. Mathematically, the i-th element of the new vector v’ is given by,",79,{"inputs":[{"name":"vectorf64"},{"name":"usize"},{"name":"usize"}],"output":{"name":"vectorview"}}],[11,"from_vector_with_stride","","These functions return a vector view of a subvector of another vector v with an additional stride argument. The subvector is formed\nin the same way as for gsl_vector_subvector but the new vector has n elements with a step-size of stride from one element to the\nnext in the original vector. Mathematically, the i-th element of the new vector v’ is given by,",79,{"inputs":[{"name":"vectorf64"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"vectorview"}}],[11,"from_array","","These functions return a vector view of an array. The start of the new vector is given by base and has n elements. Mathematically,\nthe i-th element of the new vector v’ is given by,",79,null],[11,"from_array_with_stride","","These functions return a vector view of an array base with an additional stride argument. The subvector is formed in the same way as\nfor gsl_vector_view_array but the new vector has n elements with a step-size of stride from one element to the next in the original\narray. Mathematically, the i-th element of the new vector v’ is given by,",79,null],[11,"vector","","",79,null],[11,"new","","create a new VectorF32 with all elements set to zero",80,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_slice","","",80,null],[11,"len","","",80,null],[11,"get","","This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.",80,null],[11,"set","","This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.",80,null],[11,"set_all","","This function sets all the elements of the vector v to the value x.",80,null],[11,"set_zero","","This function sets all the elements of the vector v to zero.",80,null],[11,"set_basis","","This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.",80,null],[11,"copy_from","","This function copies the elements of the other vector into the self vector. The two vectors must have the same length.",80,null],[11,"copy_to","","This function copies the elements of the self vector into the other vector. The two vectors must have the same length.",80,null],[11,"swap","","This function exchanges the elements of the vectors by copying. The two vectors must have the same length.",80,null],[11,"swap_elements","","This function exchanges the i-th and j-th elements of the vector v in-place.",80,null],[11,"reverse","","This function reverses the order of the elements of the vector v.",80,null],[11,"add","","This function adds the elements of the other vector to the elements of the self vector.\nThe result a_i &lt;- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.",80,null],[11,"sub","","This function subtracts the elements of the self vector from the elements of the other vector.\nThe result a_i &lt;- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.",80,null],[11,"mul","","This function multiplies the elements of the self vector a by the elements of the other vector.\nThe result a_i &lt;- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.",80,null],[11,"div","","This function divides the elements of the self vector by the elements of the other vector.\nThe result a_i &lt;- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.",80,null],[11,"scale","","This function multiplies the elements of the self vector by the constant factor x. The result a_i &lt;- a_i is stored in self.",80,null],[11,"add_constant","","This function adds the constant value x to the elements of the self vector. The result a_i &lt;- a_i + x is stored in self.",80,null],[11,"max","","This function returns the maximum value in the self vector.",80,null],[11,"min","","This function returns the minimum value in the self vector.",80,null],[11,"minmax","","This function returns the minimum and maximum values in the self vector, storing them in min_out and max_out.",80,null],[11,"max_index","","This function returns the index of the maximum value in the self vector.\nWhen there are several equal maximum elements then the lowest index is returned.",80,null],[11,"min_index","","This function returns the index of the minimum value in the self vector.\nWhen there are several equal minimum elements then the lowest index is returned.",80,null],[11,"minmax_index","","This function returns the indices of the minimum and maximum values in the self vector, storing them in imin and imax.\nWhen there are several equal minimum or maximum elements then the lowest indices are returned.",80,null],[11,"is_null","","This function returns true if all the elements of the self vector are equal to 0.",80,null],[11,"is_pos","","This function returns true if all the elements of the self vector are stricly positive.",80,null],[11,"is_neg","","This function returns true if all the elements of the self vector are stricly negative.",80,null],[11,"is_non_neg","","This function returns true if all the elements of the self vector are stricly non-negative.",80,null],[11,"equal","","",80,null],[11,"clone","","",80,null],[11,"drop","","",80,null],[11,"fmt","","",80,null],[11,"new","","create a new VectorF64 with all elements set to zero",81,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_slice","","",81,null],[11,"len","","",81,null],[11,"get","","This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.",81,null],[11,"set","","This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.",81,null],[11,"set_all","","This function sets all the elements of the vector v to the value x.",81,null],[11,"set_zero","","This function sets all the elements of the vector v to zero.",81,null],[11,"set_basis","","This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.",81,null],[11,"copy_from","","This function copies the elements of the other vector into the self vector. The two vectors must have the same length.",81,null],[11,"copy_to","","This function copies the elements of the self vector into the other vector. The two vectors must have the same length.",81,null],[11,"swap","","This function exchanges the elements of the vectors by copying. The two vectors must have the same length.",81,null],[11,"swap_elements","","This function exchanges the i-th and j-th elements of the vector v in-place.",81,null],[11,"reverse","","This function reverses the order of the elements of the vector v.",81,null],[11,"add","","This function adds the elements of the other vector to the elements of the self vector.\nThe result a_i &lt;- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.",81,null],[11,"sub","","This function subtracts the elements of the self vector from the elements of the other vector.\nThe result a_i &lt;- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.",81,null],[11,"mul","","This function multiplies the elements of the self vector a by the elements of the other vector.\nThe result a_i &lt;- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.",81,null],[11,"div","","This function divides the elements of the self vector by the elements of the other vector.\nThe result a_i &lt;- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.",81,null],[11,"scale","","This function multiplies the elements of the self vector by the constant factor x. The result a_i &lt;- a_i is stored in self.",81,null],[11,"add_constant","","This function adds the constant value x to the elements of the self vector. The result a_i &lt;- a_i + x is stored in self.",81,null],[11,"max","","This function returns the maximum value in the self vector.",81,null],[11,"min","","This function returns the minimum value in the self vector.",81,null],[11,"minmax","","This function returns the minimum and maximum values in the self vector, storing them in min_out and max_out.",81,null],[11,"max_index","","This function returns the index of the maximum value in the self vector.\nWhen there are several equal maximum elements then the lowest index is returned.",81,null],[11,"min_index","","This function returns the index of the minimum value in the self vector.\nWhen there are several equal minimum elements then the lowest index is returned.",81,null],[11,"minmax_index","","This function returns the indices of the minimum and maximum values in the self vector, storing them in imin and imax.\nWhen there are several equal minimum or maximum elements then the lowest indices are returned.",81,null],[11,"is_null","","This function returns true if all the elements of the self vector are equal to 0.",81,null],[11,"is_pos","","This function returns true if all the elements of the self vector are stricly positive.",81,null],[11,"is_neg","","This function returns true if all the elements of the self vector are stricly negative.",81,null],[11,"is_non_neg","","This function returns true if all the elements of the self vector are stricly non-negative.",81,null],[11,"equal","","",81,null],[11,"clone","","",81,null],[11,"drop","","",81,null],[11,"fmt","","",81,null],[0,"vector_complex","rgsl::types","",null,null],[3,"VectorComplexF64","rgsl::types::vector_complex","",null,null],[3,"VectorComplexF32","","",null,null],[11,"new","","create a new VectorComplexF64 with all elements set to zero",82,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_slice","","",82,null],[11,"len","","",82,null],[11,"get","","This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.",82,null],[11,"set","","This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.",82,null],[11,"set_all","","This function sets all the elements of the vector v to the value x.",82,null],[11,"set_zero","","This function sets all the elements of the vector v to zero.",82,null],[11,"set_basis","","This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.",82,null],[11,"copy_from","","This function copies the elements of the other vector into the self vector. The two vectors must have the same length.",82,null],[11,"copy_to","","This function copies the elements of the self vector into the other vector. The two vectors must have the same length.",82,null],[11,"swap","","This function exchanges the elements of the vectors by copying. The two vectors must have the same length.",82,null],[11,"swap_elements","","This function exchanges the i-th and j-th elements of the vector v in-place.",82,null],[11,"reverse","","This function reverses the order of the elements of the vector v.",82,null],[11,"add","","This function adds the elements of the other vector to the elements of the self vector.\nThe result a_i &lt;- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.",82,null],[11,"sub","","This function subtracts the elements of the self vector from the elements of the other vector.\nThe result a_i &lt;- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.",82,null],[11,"mul","","This function multiplies the elements of the self vector a by the elements of the other vector.\nThe result a_i &lt;- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.",82,null],[11,"div","","This function divides the elements of the self vector by the elements of the other vector.\nThe result a_i &lt;- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.",82,null],[11,"scale","","This function multiplies the elements of the self vector by the constant factor x. The result a_i &lt;- a_i is stored in self.",82,null],[11,"add_constant","","This function adds the constant value x to the elements of the self vector. The result a_i &lt;- a_i + x is stored in self.",82,null],[11,"is_null","","This function returns true if all the elements of the self vector are equal to 0.",82,null],[11,"is_pos","","This function returns true if all the elements of the self vector are stricly positive.",82,null],[11,"is_neg","","This function returns true if all the elements of the self vector are stricly negative.",82,null],[11,"is_non_neg","","This function returns true if all the elements of the self vector are stricly non-negative.",82,null],[11,"equal","","",82,null],[11,"clone","","",82,null],[11,"drop","","",82,null],[11,"fmt","","",82,null],[11,"new","","create a new VectorComplexF32 with all elements set to zero",83,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_slice","","",83,null],[11,"len","","",83,null],[11,"get","","This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.",83,null],[11,"set","","This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.",83,null],[11,"set_all","","This function sets all the elements of the vector v to the value x.",83,null],[11,"set_zero","","This function sets all the elements of the vector v to zero.",83,null],[11,"set_basis","","This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.",83,null],[11,"copy_from","","This function copies the elements of the other vector into the self vector. The two vectors must have the same length.",83,null],[11,"copy_to","","This function copies the elements of the self vector into the other vector. The two vectors must have the same length.",83,null],[11,"swap","","This function exchanges the elements of the vectors by copying. The two vectors must have the same length.",83,null],[11,"swap_elements","","This function exchanges the i-th and j-th elements of the vector v in-place.",83,null],[11,"reverse","","This function reverses the order of the elements of the vector v.",83,null],[11,"add","","This function adds the elements of the other vector to the elements of the self vector.\nThe result a_i &lt;- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.",83,null],[11,"sub","","This function subtracts the elements of the self vector from the elements of the other vector.\nThe result a_i &lt;- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.",83,null],[11,"mul","","This function multiplies the elements of the self vector a by the elements of the other vector.\nThe result a_i &lt;- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.",83,null],[11,"div","","This function divides the elements of the self vector by the elements of the other vector.\nThe result a_i &lt;- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.",83,null],[11,"scale","","This function multiplies the elements of the self vector by the constant factor x. The result a_i &lt;- a_i is stored in self.",83,null],[11,"add_constant","","This function adds the constant value x to the elements of the self vector. The result a_i &lt;- a_i + x is stored in self.",83,null],[11,"is_null","","This function returns true if all the elements of the self vector are equal to 0.",83,null],[11,"is_pos","","This function returns true if all the elements of the self vector are stricly positive.",83,null],[11,"is_neg","","This function returns true if all the elements of the self vector are stricly negative.",83,null],[11,"is_non_neg","","This function returns true if all the elements of the self vector are stricly non-negative.",83,null],[11,"equal","","",83,null],[11,"clone","","",83,null],[11,"drop","","",83,null],[11,"fmt","","",83,null],[0,"wavelet_transforms","rgsl::types","#Wavelet Transforms",null,null],[3,"Wavelet","rgsl::types::wavelet_transforms","The Wavelet structure contains the filter coefficients defining the wavelet and any associated offset parameters.",null,null],[3,"WaveletType","","The centered forms of the wavelets align the coefficients of the various sub-bands on edges. Thus the resulting visualization of the\ncoefficients of the wavelet transform in the phase plane is easier to understand.",null,null],[3,"WaveletWorkspace","","The WaveletWorkspace structure contains scratch space of the same size as the input data and is used to hold intermediate results\nduring the transform.",null,null],[11,"new","","This function allocates and initializes a wavelet object of type T. The parameter k selects the specific member of the wavelet\nfamily. A null pointer is returned if insufficient memory is available or if a unsupported member is selected.",84,{"inputs":[{"name":"wavelettype"},{"name":"usize"}],"output":{"name":"option"}}],[11,"name","","This function returns a pointer to the name of the wavelet family for w.",84,null],[11,"drop","","",84,null],[11,"clone","","",85,null],[11,"daubechies","","This is the Daubechies wavelet family of maximum phase with k/2 vanishing moments. The implemented wavelets are k=4, 6, …, 20, with\nk even.",85,{"inputs":[],"output":{"name":"wavelettype"}}],[11,"daubechies_centered","","This is the Daubechies wavelet family of maximum phase with k/2 vanishing moments. The implemented wavelets are k=4, 6, …, 20, with\nk even.",85,{"inputs":[],"output":{"name":"wavelettype"}}],[11,"haar","","This is the Haar wavelet. The only valid choice of k for the Haar wavelet is k=2.",85,{"inputs":[],"output":{"name":"wavelettype"}}],[11,"haar_centered","","This is the Haar wavelet. The only valid choice of k for the Haar wavelet is k=2.",85,{"inputs":[],"output":{"name":"wavelettype"}}],[11,"bspline","","This is the biorthogonal B-spline wavelet family of order (i,j). The implemented values of k = 100*i + j are 103, 105, 202, 204,\n206, 208, 301, 303, 305 307, 309.",85,{"inputs":[],"output":{"name":"wavelettype"}}],[11,"bspline_centered","","This is the biorthogonal B-spline wavelet family of order (i,j). The implemented values of k = 100*i + j are 103, 105, 202, 204,\n206, 208, 301, 303, 305 307, 309.",85,{"inputs":[],"output":{"name":"wavelettype"}}],[11,"new","","This function allocates a workspace for the discrete wavelet transform. To perform a one-dimensional transform on n elements, a\nworkspace of size n must be provided. For two-dimensional transforms of n-by-n matrices it is sufficient to allocate a workspace\nof size n, since the transform operates on individual rows and columns. A null pointer is returned if insufficient memory is\navailable.",86,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"drop","","",86,null],[0,"airy","rgsl","",null,null],[5,"Ai","rgsl::airy","This routine computes the Airy function Ai(x) with an accuracy specified by mode.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"Ai_e","","This routine computes the Airy function Ai(x) with an accuracy specified by mode.",null,null],[5,"Bi","","This routine computes the Airy function Bi(x) with an accuracy specified by mode.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"Bi_e","","This routine computes the Airy function Bi(x) with an accuracy specified by mode.",null,null],[5,"Ai_scaled","","This routine computes a scaled version of the Airy function S_A(x) Ai(x). For x&gt;0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"Ai_scaled_e","","This routine computes a scaled version of the Airy function S_A(x) Ai(x). For x&gt;0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.",null,null],[5,"Bi_scaled","","This routine computes a scaled version of the Airy function S_B(x) Bi(x). For x&gt;0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"Bi_scaled_e","","This routine computes a scaled version of the Airy function S_B(x) Bi(x). For x&gt;0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.",null,null],[5,"Ai_deriv","","This routine computes the Airy function derivative Ai&#39;(x) with an accuracy specified by mode.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"Ai_deriv_e","","This routine computes the Airy function derivative Ai&#39;(x) with an accuracy specified by mode.",null,null],[5,"Bi_deriv","","This routine computes the Airy function derivative Bi&#39;(x) with an accuracy specified by mode.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"Bi_deriv_e","","This routine computes the Airy function derivative Bi&#39;(x) with an accuracy specified by mode.",null,null],[5,"Ai_deriv_scaled","","This routine computes the scaled Airy function derivative S_A(x) Ai&#39;(x). For x&gt;0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"Ai_deriv_scaled_e","","This routine computes the scaled Airy function derivative S_A(x) Ai&#39;(x). For x&gt;0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x&lt;0.",null,null],[5,"Bi_deriv_scaled","","This routine computes the scaled Airy function derivative S_B(x) Bi&#39;(x). For x&gt;0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"Bi_deriv_scaled_e","","This routine computes the scaled Airy function derivative S_B(x) Bi&#39;(x). For x&gt;0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x&lt;0.",null,null],[5,"zero_Ai","","This routine computes the location of the s-th zero of the Airy function Ai(x).",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"zero_Ai_e","","This routine computes the location of the s-th zero of the Airy function Ai(x).",null,null],[5,"zero_Bi","","This routine computes the location of the s-th zero of the Airy function Bi(x).",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"zero_Bi_e","","This routine computes the location of the s-th zero of the Airy function Bi(x).",null,null],[5,"zero_Ai_deriv","","This routine computes the location of the s-th zero of the Airy function derivative Ai&#39;(x).",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"zero_Ai_deriv_e","","This routine computes the location of the s-th zero of the Airy function derivative Ai&#39;(x).",null,null],[5,"zero_Bi_deriv","","This routine computes the location of the s-th zero of the Airy function derivative Bi&#39;(x).",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"zero_Bi_deriv_e","","This routine computes the location of the s-th zero of the Airy function derivative Bi&#39;(x).",null,null],[0,"bessel","rgsl","",null,null],[5,"I0","rgsl::bessel","This routine computes the regular modified cylindrical Bessel function of zeroth order, I_0(x)",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"I0_e","","This routine computes the regular modified cylindrical Bessel function of zeroth order, I_0(x)",null,null],[5,"I1","","This routine computes the regular modified cylindrical Bessel function of first order, I_1(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"I1_e","","This routine computes the regular modified cylindrical Bessel function of first order, I_1(x).",null,null],[5,"In","","This routine computes the regular modified cylindrical Bessel function of order n, I_n(x).",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"In_e","","This routine computes the regular modified cylindrical Bessel function of order n, I_n(x).",null,null],[5,"In_array","","This routine computes the values of the regular modified cylindrical Bessel functions I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\nThe start of the range nmin must be positive or zero.\nThe values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"I0_scaled","","This routine computes the scaled regular modified cylindrical Bessel function of zeroth order \\exp(-|x|) I_0(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"I0_scaled_e","","This routine computes the scaled regular modified cylindrical Bessel function of zeroth order \\exp(-|x|) I_0(x).",null,null],[5,"I1_scaled","","This routine computes the scaled regular modified cylindrical Bessel function of first order \\exp(-|x|) I_1(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"I1_scaled_e","","This routine computes the scaled regular modified cylindrical Bessel function of first order \\exp(-|x|) I_1(x).",null,null],[5,"In_scaled","","This routine computes the scaled regular modified cylindrical Bessel function of order n, \\exp(-|x|) I_n(x)",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"In_scaled_e","","This routine computes the scaled regular modified cylindrical Bessel function of order n, \\exp(-|x|) I_n(x)",null,null],[5,"In_scaled_array","","This routine computes the values of the scaled regular cylindrical Bessel functions \\exp(-|x|) I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\nThe start of the range nmin must be positive or zero.\nThe values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"i0_scaled","","This routine computes the scaled regular modified spherical Bessel function of zeroth order, \\exp(-|x|) i_0(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"i0_scaled_e","","This routine computes the scaled regular modified spherical Bessel function of zeroth order, \\exp(-|x|) i_0(x).",null,null],[5,"i1_scaled","","This routine computes the scaled regular modified spherical Bessel function of first order, \\exp(-|x|) i_1(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"i1_scaled_e","","This routine computes the scaled regular modified spherical Bessel function of first order, \\exp(-|x|) i_1(x).",null,null],[5,"i2_scaled","","This routine computes the scaled regular modified spherical Bessel function of second order, \\exp(-|x|) i_2(x)",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"i2_scaled_e","","This routine computes the scaled regular modified spherical Bessel function of second order, \\exp(-|x|) i_2(x)",null,null],[5,"il_scaled","","This routine computes the scaled regular modified spherical Bessel function of order l, \\exp(-|x|) i_l(x)",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"il_scaled_e","","This routine computes the scaled regular modified spherical Bessel function of order l, \\exp(-|x|) i_l(x)",null,null],[5,"il_scaled_array","","This routine computes the values of the scaled regular modified cylindrical Bessel functions \\exp(-|x|) i_l(x) for l from 0 to lmax inclusive for lmax &gt;= 0, storing the results in the array result_array. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"Inu","","This routine computes the regular modified Bessel function of fractional order \\nu, I_\\nu(x) for x&gt;0, \\nu&gt;0.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Inu_e","","This routine computes the regular modified Bessel function of fractional order \\nu, I_\\nu(x) for x&gt;0, \\nu&gt;0.",null,null],[5,"Inu_scaled","","This routine computes the scaled regular modified Bessel function of fractional order \\nu, \\exp(-|x|)I_\\nu(x) for x&gt;0, \\nu&gt;0.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Inu_scaled_e","","This routine computes the scaled regular modified Bessel function of fractional order \\nu, \\exp(-|x|)I_\\nu(x) for x&gt;0, \\nu&gt;0.",null,null],[5,"J0","","This routine computes the regular cylindrical Bessel function of zeroth order, J_0(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"J0_e","","This routine computes the regular cylindrical Bessel function of zeroth order, J_0(x).",null,null],[5,"J1","","This routine computes the regular cylindrical Bessel function of first order, J_1(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"J1_e","","This routine computes the regular cylindrical Bessel function of first order, J_1(x).",null,null],[5,"Jn","","This routine computes the regular cylindrical Bessel function of order n, J_n(x).",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Jn_e","","This routine computes the regular cylindrical Bessel function of order n, J_n(x).",null,null],[5,"Jn_array","","This routine computes the values of the regular cylindrical Bessel functions J_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\nThe values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"j0","","This routine computes the regular spherical Bessel function of zeroth order, j_0(x) = \\sin(x)/x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"j0_e","","This routine computes the regular spherical Bessel function of zeroth order, j_0(x) = \\sin(x)/x.",null,null],[5,"j1","","This routine computes the regular spherical Bessel function of first order, j_1(x) = (\\sin(x)/x - \\cos(x))/x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"j1_e","","This routine computes the regular spherical Bessel function of first order, j_1(x) = (\\sin(x)/x - \\cos(x))/x.",null,null],[5,"j2","","This routine computes the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\\sin(x) - 3\\cos(x)/x)/x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"j2_e","","This routine computes the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\\sin(x) - 3\\cos(x)/x)/x.",null,null],[5,"jl","","This routine computes the regular spherical Bessel function of order l, j_l(x), for l &gt;= 0 and x &gt;= 0.",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"jl_e","","This routine computes the regular spherical Bessel function of order l, j_l(x), for l &gt;= 0 and x &gt;= 0.",null,null],[5,"jl_array","","This routine computes the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive for lmax &gt;= 0 and x &gt;= 0, storing the results in the array result_array.\nThe values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"jl_steed_array","","This routine uses Steed’s method to compute the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive for lmax &gt;= 0 and x &gt;= 0, storing the results in the array result_array.\nThe Steed/Barnett algorithm is described in Comp. Phys. Comm. 21, 297 (1981). Steed’s method is more stable than the recurrence used in the other functions but is also slower.",null,null],[5,"Jnu","","This routine computes the regular cylindrical Bessel function of fractional order \\nu, J_\\nu(x).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Jnu_e","","This routine computes the regular cylindrical Bessel function of fractional order \\nu, J_\\nu(x).",null,null],[5,"sequence_Jnu","","This function computes the regular cylindrical Bessel function of fractional order \\nu, J_\\nu(x), evaluated at a series of x values. The array v of length size contains the x values.\nThey are assumed to be strictly ordered and positive. The array is over-written with the values of J_\\nu(x_i).",null,null],[5,"K0","","This routine computes the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x &gt; 0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"K0_e","","This routine computes the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x &gt; 0.",null,null],[5,"K1","","This routine computes the irregular modified cylindrical Bessel function of first order, K_1(x), for x &gt; 0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"K1_e","","This routine computes the irregular modified cylindrical Bessel function of first order, K_1(x), for x &gt; 0.",null,null],[5,"Kn","","This routine computes the irregular modified cylindrical Bessel function of order n, K_n(x), for x &gt; 0.",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Kn_e","","This routine computes the irregular modified cylindrical Bessel function of order n, K_n(x), for x &gt; 0.",null,null],[5,"Kn_array","","This routine computes the values of the irregular modified cylindrical Bessel functions K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\nThe start of the range nmin must be positive or zero. The domain of the function is x&gt;0.\nThe values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"K0_scaled","","This routine computes the scaled irregular modified cylindrical Bessel function of zeroth order \\exp(x) K_0(x) for x&gt;0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"K0_scaled_e","","This routine computes the scaled irregular modified cylindrical Bessel function of zeroth order \\exp(x) K_0(x) for x&gt;0.",null,null],[5,"K1_scaled","","This routine computes the scaled irregular modified cylindrical Bessel function of first order \\exp(x) K_1(x) for x&gt;0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"K1_scaled_e","","This routine computes the scaled irregular modified cylindrical Bessel function of first order \\exp(x) K_1(x) for x&gt;0.",null,null],[5,"Kn_scaled","","This routine computes the scaled irregular modified cylindrical Bessel function of order n, \\exp(x) K_n(x), for x&gt;0.",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Kn_scaled_e","","This routine computes the scaled irregular modified cylindrical Bessel function of order n, \\exp(x) K_n(x), for x&gt;0.",null,null],[5,"Kn_scaled_array","","This routine computes the values of the scaled irregular cylindrical Bessel functions \\exp(x) K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\nThe start of the range nmin must be positive or zero. The domain of the function is x&gt;0.\nThe values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"k0_scaled","","The irregular modified spherical Bessel functions k_l(x) are related to the irregular modified Bessel functions of fractional order, k_l(x) = \\sqrt{\\pi/(2x)} K_{l+1/2}(x).\nThis routine computes the scaled irregular modified spherical Bessel function of zeroth order, \\exp(x) k_0(x), for x&gt;0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"k0_scaled_e","","The irregular modified spherical Bessel functions k_l(x) are related to the irregular modified Bessel functions of fractional order, k_l(x) = \\sqrt{\\pi/(2x)} K_{l+1/2}(x).\nThis routine computes the scaled irregular modified spherical Bessel function of zeroth order, \\exp(x) k_0(x), for x&gt;0.",null,null],[5,"k1_scaled","","This routine computes the scaled irregular modified spherical Bessel function of first order, \\exp(x) k_1(x), for x&gt;0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"k1_scaled_e","","This routine computes the scaled irregular modified spherical Bessel function of first order, \\exp(x) k_1(x), for x&gt;0.",null,null],[5,"k2_scaled","","This routine computes the scaled irregular modified spherical Bessel function of second order, \\exp(x) k_2(x), for x&gt;0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"k2_scaled_e","","This routine computes the scaled irregular modified spherical Bessel function of second order, \\exp(x) k_2(x), for x&gt;0.",null,null],[5,"kl_scaled","","This routine computes the scaled irregular modified spherical Bessel function of order l, \\exp(x) k_l(x), for x&gt;0.",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"kl_scaled_e","","This routine computes the scaled irregular modified spherical Bessel function of order l, \\exp(x) k_l(x), for x&gt;0.",null,null],[5,"kl_scaled_array","","This routine computes the values of the scaled irregular modified spherical Bessel functions \\exp(x) k_l(x) for l from 0 to lmax inclusive for lmax &gt;= 0 and x&gt;0, storing the results in the array result_array.\nThe values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"Knu","","This routine computes the irregular modified Bessel function of fractional order \\nu, K_\\nu(x) for x&gt;0, \\nu&gt;0.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Knu_e","","This routine computes the irregular modified Bessel function of fractional order \\nu, K_\\nu(x) for x&gt;0, \\nu&gt;0.",null,null],[5,"lnKnu","","This routine computes the logarithm of the irregular modified Bessel function of fractional order \\nu, \\ln(K_\\nu(x)) for x&gt;0, \\nu&gt;0.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"lnKnu_e","","This routine computes the logarithm of the irregular modified Bessel function of fractional order \\nu, \\ln(K_\\nu(x)) for x&gt;0, \\nu&gt;0.",null,null],[5,"Knu_scaled","","This routine computes the scaled irregular modified Bessel function of fractional order \\nu, \\exp(+|x|) K_\\nu(x) for x&gt;0, \\nu&gt;0.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Knu_scaled_e","","This routine computes the scaled irregular modified Bessel function of fractional order \\nu, \\exp(+|x|) K_\\nu(x) for x&gt;0, \\nu&gt;0.",null,null],[5,"Y0","","This routine computes the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x&gt;0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"Y0_e","","This routine computes the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x&gt;0.",null,null],[5,"Y1","","This routine computes the irregular cylindrical Bessel function of first order, Y_1(x), for x&gt;0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"Y1_e","","This routine computes the irregular cylindrical Bessel function of first order, Y_1(x), for x&gt;0.",null,null],[5,"Yn","","This routine computes the irregular cylindrical Bessel function of order n, Y_n(x), for x&gt;0.",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Yn_e","","This routine computes the irregular cylindrical Bessel function of order n, Y_n(x), for x&gt;0.",null,null],[5,"Yn_array","","This routine computes the values of the irregular cylindrical Bessel functions Y_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\nThe domain of the function is x&gt;0.\nThe values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"y0","","This routine computes the irregular spherical Bessel function of zeroth order, y_0(x) = -\\cos(x)/x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"y0_e","","This routine computes the irregular spherical Bessel function of zeroth order, y_0(x) = -\\cos(x)/x.",null,null],[5,"y1","","This routine computes the irregular spherical Bessel function of first order, y_1(x) = -(\\cos(x)/x + \\sin(x))/x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"y1_e","","This routine computes the irregular spherical Bessel function of first order, y_1(x) = -(\\cos(x)/x + \\sin(x))/x.",null,null],[5,"y2","","This routine computes the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\\cos(x) - (3/x^2)\\sin(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"y2_e","","This routine computes the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\\cos(x) - (3/x^2)\\sin(x).",null,null],[5,"yl","","This routine computes the irregular spherical Bessel function of order l, y_l(x), for l &gt;= 0.",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"yl_e","","This routine computes the irregular spherical Bessel function of order l, y_l(x), for l &gt;= 0.",null,null],[5,"yl_array","","This routine computes the values of the irregular spherical Bessel functions y_l(x) for l from 0 to lmax inclusive for lmax &gt;= 0, storing the results in the array result_array.\nThe values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.",null,null],[5,"Ynu","","This routine computes the irregular cylindrical Bessel function of fractional order \\nu, Y_\\nu(x).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"Ynu_e","","This routine computes the irregular cylindrical Bessel function of fractional order \\nu, Y_\\nu(x).",null,null],[5,"zero_J0","","This routine computes the location of the s-th positive zero of the Bessel function J_0(x).",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"zero_J0_e","","This routine computes the location of the s-th positive zero of the Bessel function J_0(x).",null,null],[5,"zero_J1","","This routine computes the location of the s-th positive zero of the Bessel function J_1(x).",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"zero_J1_e","","This routine computes the location of the s-th positive zero of the Bessel function J_1(x).",null,null],[5,"zero_Jnu","","This routine computes the location of the s-th positive zero of the Bessel function J_\\nu(x).\nThe current implementation does not support negative values of nu.",null,{"inputs":[{"name":"f64"},{"name":"u32"}],"output":{"name":"f64"}}],[5,"zero_Jnu_e","","This routine computes the location of the s-th positive zero of the Bessel function J_\\nu(x).\nThe current implementation does not support negative values of nu.",null,null],[0,"blas","rgsl","",null,null],[0,"level1","rgsl::blas","",null,null],[5,"sdsdot","rgsl::blas::level1","This function computes the sum \\alpha + x^T y for the vectors x and y, returning the result in result.",null,{"inputs":[{"name":"f32"},{"name":"vectorf32"},{"name":"vectorf32"},{"name":"f32"}],"output":{"name":"value"}}],[5,"sdot","","This function computes the scalar product x^T y for the vectors x and y, returning the result in result.",null,{"inputs":[{"name":"vectorf32"},{"name":"vectorf32"},{"name":"f32"}],"output":{"name":"value"}}],[5,"dsdot","","This function computes the scalar product x^T y for the vectors x and y, returning the result in result.",null,{"inputs":[{"name":"vectorf32"},{"name":"vectorf32"},{"name":"f64"}],"output":{"name":"value"}}],[5,"ddot","","This function computes the scalar product x^T y for the vectors x and y, returning the result in result.",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"},{"name":"f64"}],"output":{"name":"value"}}],[5,"cdotu","","This function computes the complex scalar product x^T y for the vectors x and y, returning the result in dotu.",null,{"inputs":[{"name":"vectorcomplexf32"},{"name":"vectorcomplexf32"},{"name":"complexf32"}],"output":{"name":"value"}}],[5,"zdotu","","This function computes the complex scalar product x^T y for the vectors x and y, returning the result in dotu.",null,{"inputs":[{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"},{"name":"complexf64"}],"output":{"name":"value"}}],[5,"cdotc","","This function computes the complex conjugate scalar product x^H y for the vectors x and y, returning the result in dotc.",null,{"inputs":[{"name":"vectorcomplexf32"},{"name":"vectorcomplexf32"},{"name":"complexf32"}],"output":{"name":"value"}}],[5,"zdotc","","This function computes the complex conjugate scalar product x^H y for the vectors x and y, returning the result in dotc.",null,{"inputs":[{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"},{"name":"complexf64"}],"output":{"name":"value"}}],[5,"snrm2","","This function computes the Euclidean norm ||x||_2 = \\sqrt {\\sum x_i^2} of the vector x.",null,{"inputs":[{"name":"vectorf32"}],"output":{"name":"f32"}}],[5,"dnrm2","","This function computes the Euclidean norm ||x||_2 = \\sqrt {\\sum x_i^2} of the vector x.",null,{"inputs":[{"name":"vectorf64"}],"output":{"name":"f64"}}],[5,"scnrm2","","This function computes the Euclidean norm of the complex vector x,",null,{"inputs":[{"name":"vectorcomplexf32"}],"output":{"name":"f32"}}],[5,"dznrm2","","This function computes the Euclidean norm of the complex vector x,",null,{"inputs":[{"name":"vectorcomplexf64"}],"output":{"name":"f64"}}],[5,"sasum","","This function computes the absolute sum \\sum |x_i| of the elements of the vector x.",null,{"inputs":[{"name":"vectorf32"}],"output":{"name":"f32"}}],[5,"dasum","","This function computes the absolute sum \\sum |x_i| of the elements of the vector x.",null,{"inputs":[{"name":"vectorf64"}],"output":{"name":"f64"}}],[5,"scasum","","This function computes the sum of the magnitudes of the real and imaginary parts of the complex vector x, \\sum |\\Re(x_i)| + |\\Im(x_i)|.",null,{"inputs":[{"name":"vectorcomplexf32"}],"output":{"name":"f32"}}],[5,"dzasum","","This function computes the sum of the magnitudes of the real and imaginary parts of the complex vector x, \\sum |\\Re(x_i)| + |\\Im(x_i)|.",null,{"inputs":[{"name":"vectorcomplexf64"}],"output":{"name":"f64"}}],[5,"isamax","","This function returns the index of the largest element of the vector x.\nThe largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors.\nIf the largest value occurs several times then the index of the first occurrence is returned.",null,{"inputs":[{"name":"vectorf32"}],"output":{"name":"u32"}}],[5,"idamax","","This function returns the index of the largest element of the vector x.\nThe largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors.\nIf the largest value occurs several times then the index of the first occurrence is returned.",null,{"inputs":[{"name":"vectorf64"}],"output":{"name":"u32"}}],[5,"icamax","","This function returns the index of the largest element of the vector x.\nThe largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors.\nIf the largest value occurs several times then the index of the first occurrence is returned.",null,{"inputs":[{"name":"vectorcomplexf32"}],"output":{"name":"u32"}}],[5,"izamax","","This function returns the index of the largest element of the vector x.\nThe largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors.\nIf the largest value occurs several times then the index of the first occurrence is returned.",null,{"inputs":[{"name":"vectorcomplexf64"}],"output":{"name":"u32"}}],[5,"sswap","","This function exchanges the elements of the vectors x and y.",null,{"inputs":[{"name":"vectorf32"},{"name":"vectorf32"}],"output":{"name":"value"}}],[5,"dswap","","This function exchanges the elements of the vectors x and y.",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"cswap","","This function exchanges the elements of the vectors x and y.",null,{"inputs":[{"name":"vectorcomplexf32"},{"name":"vectorcomplexf32"}],"output":{"name":"value"}}],[5,"zswap","","This function exchanges the elements of the vectors x and y.",null,{"inputs":[{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"scopy","","This function copy the elements of the vector x into the vector y.",null,{"inputs":[{"name":"vectorf32"},{"name":"vectorf32"}],"output":{"name":"value"}}],[5,"dcopy","","This function copy the elements of the vector x into the vector y.",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"ccopy","","This function copy the elements of the vector x into the vector y.",null,{"inputs":[{"name":"vectorcomplexf32"},{"name":"vectorcomplexf32"}],"output":{"name":"value"}}],[5,"zcopy","","This function copy the elements of the vector x into the vector y.",null,{"inputs":[{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"saxpy","","This function computes the sum y = \\alpha x + y for the vectors x and y.",null,{"inputs":[{"name":"f32"},{"name":"vectorf32"},{"name":"vectorf32"}],"output":{"name":"value"}}],[5,"daxpy","","This function computes the sum y = \\alpha x + y for the vectors x and y.",null,{"inputs":[{"name":"f64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"caxpy","","This function computes the sum y = \\alpha x + y for the vectors x and y.",null,{"inputs":[{"name":"complexf32"},{"name":"vectorcomplexf32"},{"name":"vectorcomplexf32"}],"output":{"name":"value"}}],[5,"zaxpy","","This function computes the sum y = \\alpha x + y for the vectors x and y.",null,{"inputs":[{"name":"complexf64"},{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"sscal","","This function rescales the vector x by the multiplicative factor alpha.",null,{"inputs":[{"name":"f32"},{"name":"vectorf32"}],"output":null}],[5,"dscal","","This function rescales the vector x by the multiplicative factor alpha.",null,{"inputs":[{"name":"f64"},{"name":"vectorf64"}],"output":null}],[5,"cscal","","This function rescales the vector x by the multiplicative factor alpha.",null,{"inputs":[{"name":"complexf32"},{"name":"vectorcomplexf32"}],"output":null}],[5,"zscal","","This function rescales the vector x by the multiplicative factor alpha.",null,{"inputs":[{"name":"complexf64"},{"name":"vectorcomplexf64"}],"output":null}],[5,"csscal","","This function rescales the vector x by the multiplicative factor alpha.",null,{"inputs":[{"name":"f32"},{"name":"vectorcomplexf32"}],"output":null}],[5,"zdscal","","This function rescales the vector x by the multiplicative factor alpha.",null,{"inputs":[{"name":"f64"},{"name":"vectorcomplexf64"}],"output":null}],[5,"srotg","","This function computes a Givens rotation (c,s) which zeroes the vector (a,b),",null,null],[5,"drotg","","This function computes a Givens rotation (c,s) which zeroes the vector (a,b),",null,null],[5,"srot","","This function applies a Givens rotation (x&#39;, y&#39;) = (c x + s y, -s x + c y) to the vectors x, y.",null,{"inputs":[{"name":"vectorf32"},{"name":"vectorf32"},{"name":"f32"},{"name":"f32"}],"output":{"name":"value"}}],[5,"drot","","This function applies a Givens rotation (x&#39;, y&#39;) = (c x + s y, -s x + c y) to the vectors x, y.",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[5,"srotmg","","This function computes a modified Givens transformation.\nThe modified Givens transformation is defined in the original Level-1 BLAS specification, given in the references.",null,null],[5,"drotmg","","This function computes a modified Givens transformation.\nThe modified Givens transformation is defined in the original Level-1 BLAS specification, given in the references.",null,null],[5,"srotm","","This function applies a modified Givens transformation.",null,null],[5,"drotm","","This function applies a modified Givens transformation.",null,null],[0,"level2","rgsl::blas","",null,null],[5,"sgemv","rgsl::blas::level2","This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.",null,{"inputs":[{"name":"transpose"},{"name":"f32"},{"name":"matrixf32"},{"name":"vectorf32"},{"name":"f32"},{"name":"vectorf32"}],"output":{"name":"value"}}],[5,"dgemv","","This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.",null,{"inputs":[{"name":"transpose"},{"name":"f64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"f64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"cgemv","","This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.",null,{"inputs":[{"name":"transpose"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"vectorcomplexf32"},{"name":"complexf32"},{"name":"vectorcomplexf32"}],"output":{"name":"value"}}],[5,"zgemv","","This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.",null,{"inputs":[{"name":"transpose"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"vectorcomplexf64"},{"name":"complexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"strmv","","This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\nWhen Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\nIf Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"matrixf32"},{"name":"vectorf32"}],"output":{"name":"value"}}],[5,"dtrmv","","This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\nWhen Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\nIf Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"ctrmv","","This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\nWhen Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\nIf Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"matrixcomplexf32"},{"name":"vectorcomplexf32"}],"output":{"name":"value"}}],[5,"ztrmv","","This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\nWhen Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\nIf Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"matrixcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"strsv","","This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\nWhen Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\nIf Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"matrixf32"},{"name":"vectorf32"}],"output":{"name":"value"}}],[5,"dtrsv","","This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\nWhen Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\nIf Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"ctrsv","","This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\nWhen Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\nIf Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"matrixcomplexf32"},{"name":"vectorcomplexf32"}],"output":{"name":"value"}}],[5,"ztrsv","","This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\nWhen Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\nIf Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"matrixcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"ssymv","","These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the symmetric matrix A.\nSince the matrix A is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"uplo"},{"name":"f32"},{"name":"matrixf32"},{"name":"vectorf32"},{"name":"f32"},{"name":"vectorf32"}],"output":{"name":"value"}}],[5,"dsymv","","These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the symmetric matrix A.\nSince the matrix A is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"uplo"},{"name":"f64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"f64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"chemv","","These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the hermitian matrix A.\nSince the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\nThe imaginary elements of the diagonal are automatically assumed to be zero and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"vectorcomplexf32"},{"name":"complexf32"},{"name":"vectorcomplexf32"}],"output":{"name":"value"}}],[5,"zhemv","","These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the hermitian matrix A.\nSince the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\nThe imaginary elements of the diagonal are automatically assumed to be zero and are not referenced.",null,{"inputs":[{"name":"uplo"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"vectorcomplexf64"},{"name":"complexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"sger","","This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.",null,{"inputs":[{"name":"f32"},{"name":"vectorf32"},{"name":"vectorf32"},{"name":"matrixf32"}],"output":{"name":"value"}}],[5,"dger","","This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.",null,{"inputs":[{"name":"f64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"cgeru","","This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.",null,{"inputs":[{"name":"complexf32"},{"name":"vectorcomplexf32"},{"name":"vectorcomplexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zgeru","","This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.",null,{"inputs":[{"name":"complexf64"},{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"cgerc","","This function computes the conjugate rank-1 update A = \\alpha x y^H + A of the matrix A.",null,{"inputs":[{"name":"complexf32"},{"name":"vectorcomplexf32"},{"name":"vectorcomplexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zgerc","","This function computes the conjugate rank-1 update A = \\alpha x y^H + A of the matrix A.",null,{"inputs":[{"name":"complexf64"},{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"ssyr","","This function computes the symmetric rank-1 update A = \\alpha x x^T + A of the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"uplo"},{"name":"f32"},{"name":"vectorf32"},{"name":"matrixf32"}],"output":{"name":"value"}}],[5,"dsyr","","This function computes the symmetric rank-1 update A = \\alpha x x^T + A of the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"uplo"},{"name":"f64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"cher","","These functions compute the hermitian rank-1 update A = \\alpha x x^H + A of the hermitian matrix A.\nSince the matrix A is hermitian only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"uplo"},{"name":"f32"},{"name":"vectorcomplexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zher","","These functions compute the hermitian rank-1 update A = \\alpha x x^H + A of the hermitian matrix A.\nSince the matrix A is hermitian only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"uplo"},{"name":"f64"},{"name":"vectorcomplexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"ssyr2","","These functions compute the symmetric rank-2 update A = \\alpha x y^T + \\alpha y x^T + A of the symmetric matrix A.\nSince the matrix A is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"uplo"},{"name":"f32"},{"name":"vectorf32"},{"name":"vectorf32"},{"name":"matrixf32"}],"output":{"name":"value"}}],[5,"dsyr2","","These functions compute the symmetric rank-2 update A = \\alpha x y^T + \\alpha y x^T + A of the symmetric matrix A.\nSince the matrix A is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"uplo"},{"name":"f64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"cher2","","These functions compute the hermitian rank-2 update A = \\alpha x y^H + \\alpha^* y x^H + A of the hermitian matrix A.\nSince the matrix A is hermitian only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"uplo"},{"name":"complexf32"},{"name":"vectorcomplexf32"},{"name":"vectorcomplexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zher2","","These functions compute the hermitian rank-2 update A = \\alpha x y^H + \\alpha^* y x^H + A of the hermitian matrix A.\nSince the matrix A is hermitian only its upper half or lower half need to be stored.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"uplo"},{"name":"complexf64"},{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[0,"level3","rgsl::blas","",null,null],[5,"sgemm","rgsl::blas::level3","This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.",null,{"inputs":[{"name":"transpose"},{"name":"transpose"},{"name":"f32"},{"name":"matrixf32"},{"name":"matrixf32"},{"name":"f32"},{"name":"matrixf32"}],"output":{"name":"value"}}],[5,"dgemm","","This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.",null,{"inputs":[{"name":"transpose"},{"name":"transpose"},{"name":"f64"},{"name":"matrixf64"},{"name":"matrixf64"},{"name":"f64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"cgemm","","This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.",null,{"inputs":[{"name":"transpose"},{"name":"transpose"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"matrixcomplexf32"},{"name":"complexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zgemm","","This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.",null,{"inputs":[{"name":"transpose"},{"name":"transpose"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"matrixcomplexf64"},{"name":"complexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"ssymm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"f32"},{"name":"matrixf32"},{"name":"matrixf32"},{"name":"f32"},{"name":"matrixf32"}],"output":{"name":"value"}}],[5,"dsymm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"f64"},{"name":"matrixf64"},{"name":"matrixf64"},{"name":"f64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"csymm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"matrixcomplexf32"},{"name":"complexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zsymm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"matrixcomplexf64"},{"name":"complexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"chemm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is Left and C = \\alpha B A + \\beta C for Side is Right, where the matrix A is hermitian.\nWhen Uplo is Upper then the upper triangle and diagonal of A are used, and when Uplo is Lower then the lower triangle and diagonal of A are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"matrixcomplexf32"},{"name":"complexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zhemm","","This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is hermitian.\nWhen Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"matrixcomplexf64"},{"name":"complexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"strmm","","This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight.\nThe matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\nWhen Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\nIf Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"f32"},{"name":"matrixf32"},{"name":"matrixf32"}],"output":{"name":"value"}}],[5,"dtrmm","","This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight.\nThe matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\nWhen Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\nIf Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"f64"},{"name":"matrixf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"ctrmm","","This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight.\nThe matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\nWhen Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\nIf Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"ztrmm","","This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight.\nThe matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\nWhen Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\nIf Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"strsm","","This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right.\nThe matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\nWhen Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\nIf Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"f32"},{"name":"matrixf32"},{"name":"matrixf32"}],"output":{"name":"value"}}],[5,"dtrsm","","This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right.\nThe matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\nWhen Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\nIf Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"f64"},{"name":"matrixf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"ctrsm","","This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right.\nThe matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\nWhen Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\nIf Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"ztrsm","","This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right.\nThe matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\nWhen Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\nIf Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.",null,{"inputs":[{"name":"side"},{"name":"uplo"},{"name":"transpose"},{"name":"diag"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"ssyrk","","This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans.\nSince the matrix C is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"f32"},{"name":"matrixf32"},{"name":"f32"},{"name":"matrixf32"}],"output":{"name":"value"}}],[5,"dsyrk","","This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans.\nSince the matrix C is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"f64"},{"name":"matrixf64"},{"name":"f64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"csyrk","","This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans.\nSince the matrix C is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"complexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zsyrk","","This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans.\nSince the matrix C is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"complexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"cherk","","These functions compute a rank-k update of the hermitian matrix C, C = \\alpha A A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H A + \\beta C when Trans is ConjTrans.\nSince the matrix C is hermitian only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"f32"},{"name":"matrixcomplexf32"},{"name":"f32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zherk","","These functions compute a rank-k update of the hermitian matrix C, C = \\alpha A A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H A + \\beta C when Trans is ConjTrans.\nSince the matrix C is hermitian only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"f64"},{"name":"matrixcomplexf64"},{"name":"f64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"ssyr2k","","This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans.\nSince the matrix C is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"f32"},{"name":"matrixf32"},{"name":"matrixf32"},{"name":"f32"},{"name":"matrixf32"}],"output":{"name":"value"}}],[5,"dsyr2k","","This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans.\nSince the matrix C is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"f64"},{"name":"matrixf64"},{"name":"matrixf64"},{"name":"f64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"csyr2k","","This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans.\nSince the matrix C is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"matrixcomplexf32"},{"name":"complexf32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zsyr2k","","This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans.\nSince the matrix C is symmetric only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"matrixcomplexf64"},{"name":"complexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"cher2k","","This function computes a rank-2k update of the hermitian matrix C, C = \\alpha A B^H + \\alpha^* B A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H B + \\alpha^* B^H A + \\beta C when Trans is ConjTrans.\nSince the matrix C is hermitian only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"complexf32"},{"name":"matrixcomplexf32"},{"name":"matrixcomplexf32"},{"name":"f32"},{"name":"matrixcomplexf32"}],"output":{"name":"value"}}],[5,"zher2k","","This function computes a rank-2k update of the hermitian matrix C, C = \\alpha A B^H + \\alpha^* B A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H B + \\alpha^* B^H A + \\beta C when Trans is ConjTrans.\nSince the matrix C is hermitian only its upper half or lower half need to be stored.\nWhen Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\nThe imaginary elements of the diagonal are automatically set to zero.",null,{"inputs":[{"name":"uplo"},{"name":"transpose"},{"name":"complexf64"},{"name":"matrixcomplexf64"},{"name":"matrixcomplexf64"},{"name":"f64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[0,"cblas","rgsl","",null,null],[3,"Index","rgsl::cblas","",null,null],[12,"0","","",87,null],[4,"Order","","Indicates whether a matrix is in Row Major or Column Major order.\nRow major order is the native order for C programs, while Column major order is native for Fortran.",null,null],[13,"RowMajor","","",88,null],[13,"ColMajoyr","","",88,null],[4,"Side","","Used to indicate the order of a matrix-matrix multiply.",null,null],[13,"Left","","Means __A__ __B__",89,null],[13,"Right","","Means __B__ __A__",89,null],[4,"Transpose","","Used to represent transpose operations on a matrix.",null,null],[13,"NoTrans","","Represents __X__",90,null],[13,"Trans","","Represents __X^T__",90,null],[13,"ConjTrans","","Represents __X^H__",90,null],[4,"Uplo","","Used to indicate which part of a symmetric matrix to use.",null,null],[13,"Upper","","Means user the upper triagle of the matrix.",91,null],[13,"Lower","","Means use the lower triange of the matrix.",91,null],[4,"Diag","","",null,null],[13,"NonUnit","","",92,null],[13,"Unit","","",92,null],[0,"level1","","",null,null],[5,"sdsdot","rgsl::cblas::level1","",null,null],[5,"dsdot","","",null,null],[5,"sdot","","",null,null],[5,"ddot","","",null,null],[5,"cdotu_sub","","",null,null],[5,"cdotc_sub","","",null,null],[5,"zdotu_sub","","",null,null],[5,"zdotc_sub","","",null,null],[5,"snrm2","","",null,null],[5,"sasum","","",null,null],[5,"dnrm2","","",null,null],[5,"dasum","","",null,null],[5,"scnrm2","","",null,null],[5,"scasum","","",null,null],[5,"dznrm2","","",null,null],[5,"dzasum","","",null,null],[5,"isamax","","",null,null],[5,"idamax","","",null,null],[5,"icamax","","",null,null],[5,"izamax","","",null,null],[5,"sswap","","",null,null],[5,"scopy","","",null,null],[5,"saxpy","","",null,null],[5,"dswap","","",null,null],[5,"dcopy","","",null,null],[5,"daxpy","","",null,null],[5,"cswap","","",null,null],[5,"ccopy","","",null,null],[5,"caxpy","","",null,null],[5,"zswap","","",null,null],[5,"zcopy","","",null,null],[5,"zaxpy","","",null,null],[5,"srotg","","",null,null],[5,"srotmg","","",null,null],[5,"srot","","",null,null],[5,"srotm","","",null,null],[5,"drotg","","",null,null],[5,"drotmg","","",null,null],[5,"drot","","",null,null],[5,"drotm","","",null,null],[5,"sscal","","Multiple each element of a matrix/vector by a constant.",null,null],[5,"dscal","","Multiple each element of a matrix/vector by a constant.",null,null],[5,"cscal","","Multiple each element of a matrix/vector by a constant.",null,null],[5,"zscal","","Multiple each element of a matrix/vector by a constant.",null,null],[5,"csscal","","Multiple each element of a matrix/vector by a constant.",null,null],[5,"zdscal","","Multiple each element of a matrix/vector by a constant.",null,null],[0,"level2","rgsl::cblas","",null,null],[5,"sgemv","rgsl::cblas::level2","Multiplies a matrix and a vector.",null,null],[5,"sgbmv","","",null,null],[5,"strmv","","",null,null],[5,"stbmv","","",null,null],[5,"stpmv","","",null,null],[5,"strsv","","",null,null],[5,"stbsv","","",null,null],[5,"stpsv","","",null,null],[5,"dgemv","","",null,null],[5,"dgbmv","","",null,null],[5,"dtrmv","","",null,null],[5,"dtbmv","","",null,null],[5,"dtpmv","","",null,null],[5,"dtrsv","","",null,null],[5,"dtbsv","","",null,null],[5,"dtpsv","","",null,null],[5,"cgemv","","",null,null],[5,"cgbmv","","",null,null],[5,"ctrmv","","",null,null],[5,"ctbmv","","",null,null],[5,"ctpmv","","",null,null],[5,"ctrsv","","",null,null],[5,"ctbsv","","",null,null],[5,"ctpsv","","",null,null],[5,"zgemv","","",null,null],[5,"zgbmv","","",null,null],[5,"ztrmv","","",null,null],[5,"ztbmv","","",null,null],[5,"ztpmv","","",null,null],[5,"ztrsv","","",null,null],[5,"ztbsv","","",null,null],[5,"ztpsv","","",null,null],[5,"ssymv","","",null,null],[5,"ssbmv","","",null,null],[5,"sspmv","","",null,null],[5,"sger","","",null,null],[5,"ssyr","","",null,null],[5,"sspr","","",null,null],[5,"ssyr2","","",null,null],[5,"sspr2","","",null,null],[5,"dsymv","","",null,null],[5,"dsbmv","","",null,null],[5,"dspmv","","",null,null],[5,"dger","","",null,null],[5,"dsyr","","",null,null],[5,"dspr","","",null,null],[5,"dsyr2","","",null,null],[5,"dspr2","","",null,null],[5,"csymv","","",null,null],[5,"csbmv","","",null,null],[5,"cspmv","","",null,null],[5,"cgeru","","",null,null],[5,"cgerc","","",null,null],[5,"cher","","",null,null],[5,"chpr","","",null,null],[5,"cher2","","",null,null],[5,"chpr2","","",null,null],[5,"zsymv","","",null,null],[5,"zsbmv","","",null,null],[5,"zspmv","","",null,null],[5,"zgeru","","",null,null],[5,"zgerc","","",null,null],[5,"zher","","",null,null],[5,"zhpr","","",null,null],[5,"zher2","","",null,null],[5,"zhpr2","","",null,null],[0,"level3","rgsl::cblas","",null,null],[5,"sgemm","rgsl::cblas::level3","General ::types::Matrix-MatrixF64 multiplication for single precision float.",null,null],[5,"ssymm","","Symmetric ::types::Matrix-MatrixF64 multiplication for single precision float.",null,null],[5,"ssyrk","","",null,null],[5,"ssyr2k","","",null,null],[5,"strmm","","",null,null],[5,"strsm","","",null,null],[5,"dgemm","","",null,null],[5,"dsymm","","",null,null],[5,"dsyrk","","",null,null],[5,"dsyr2k","","",null,null],[5,"dtrmm","","",null,null],[5,"dtrsm","","",null,null],[5,"cgemm","","",null,null],[5,"csymm","","",null,null],[5,"csyrk","","",null,null],[5,"csyr2k","","",null,null],[5,"ctrmm","","",null,null],[5,"ctrsm","","",null,null],[5,"zgemm","","",null,null],[5,"zsymm","","",null,null],[5,"zsyrk","","",null,null],[5,"zsyr2k","","",null,null],[5,"ztrmm","","",null,null],[5,"ztrsm","","",null,null],[5,"chemm","","",null,null],[5,"cherk","","",null,null],[5,"cher2k","","",null,null],[5,"zhemm","","",null,null],[5,"zherk","","",null,null],[5,"zher2k","","",null,null],[11,"clone","rgsl::cblas","",87,null],[11,"clone","","",88,null],[11,"fmt","","",88,null],[11,"partial_cmp","","",88,null],[11,"eq","","",88,null],[11,"clone","","",89,null],[11,"fmt","","",89,null],[11,"partial_cmp","","",89,null],[11,"eq","","",89,null],[11,"clone","","",90,null],[11,"fmt","","",90,null],[11,"partial_cmp","","",90,null],[11,"eq","","",90,null],[11,"clone","","",91,null],[11,"fmt","","",91,null],[11,"partial_cmp","","",91,null],[11,"eq","","",91,null],[11,"clone","","",92,null],[11,"fmt","","",92,null],[11,"partial_cmp","","",92,null],[11,"eq","","",92,null],[0,"clausen","rgsl","The Clausen function is defined by the following integral,",null,null],[5,"clausen","rgsl::clausen","This routine computes the Clausen integral Cl_2(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"clausen_e","","This routine computes the Clausen integral Cl_2(x).",null,null],[0,"coulomb","rgsl","",null,null],[5,"hydrogenicR_1","rgsl::coulomb","This routine computes the lowest-order normalized hydrogenic bound state radial wavefunction R_1 := 2Z \\sqrt{Z} \\exp(-Z r).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hydrogenicR_1_e","","This routine computes the lowest-order normalized hydrogenic bound state radial wavefunction R_1 := 2Z \\sqrt{Z} \\exp(-Z r).",null,null],[5,"hydrogenicR","","This routine computes the n-th normalized hydrogenic bound state radial wavefunction,",null,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hydrogenicR_e","","This routine computes the n-th normalized hydrogenic bound state radial wavefunction,",null,null],[5,"wave_FG_e","","This function computes the Coulomb wave functions F_L(\\eta,x), G_{L-k}(\\eta,x) and their derivatives F&#39;_L(\\eta,x), G&#39;_{L-k}(\\eta,x) with respect to x. The parameters are restricted to L, L-k &gt; -1/2, x &gt; 0 and integer k. Note that L itself is not restricted to being an integer. The results are stored in the parameters F, G for the function values and Fp, Gp for the derivative values.\nIf an overflow occurs, GSL_EOVRFLW is returned and scaling exponents are stored in the modifiable parameters exp_F, exp_G.",null,null],[5,"wave_F_array","","This function computes the Coulomb wave function F_L(\\eta,x) for L = Lmin \\dots Lmin + kmax, storing the results in fc_array.\nIn the case of overflow the exponent is stored in F_exponent.",null,null],[5,"wave_FG_array","","This function computes the functions F_L(\\eta,x), G_L(\\eta,x) for L = Lmin \\dots Lmin + kmax storing the results in fc_array and gc_array.\nIn the case of overflow the exponents are stored in F_exponent and G_exponent.",null,null],[5,"wave_FGp_array","","This function computes the functions F_L(\\eta,x), G_L(\\eta,x) and their derivatives F&#39;_L(\\eta,x), G&#39;_L(\\eta,x) for L = Lmin \\dots Lmin + kmax storing the results in fc_array, gc_array, fcp_array and gcp_array.\nIn the case of overflow the exponents are stored in F_exponent and G_exponent.",null,null],[5,"wave_sphF_array","","This function computes the Coulomb wave function divided by the argument F_L(\\eta, x)/x for L = Lmin \\dots Lmin + kmax, storing the results in fc_array.\nIn the case of overflow the exponent is stored in F_exponent. This function reduces to spherical Bessel functions in the limit \\eta \\to 0.",null,null],[5,"CL_e","","This function computes the Coulomb wave function normalization constant C_L(\\eta) for L &gt; -1.",null,null],[5,"CL_array","","This function computes the Coulomb wave function normalization constant C_L(\\eta) for L = Lmin \\dots Lmin + kmax, Lmin &gt; -1.",null,null],[0,"coupling_coefficients","rgsl","The Wigner 3-j, 6-j and 9-j symbols give the coupling coefficients for combined angular momentum vectors.\nSince the arguments of the standard coupling coefficient functions are integer or half-integer, the arguments of the following functions\nare, by convention, integers equal to twice the actual spin value.",null,null],[5,"_3j","rgsl::coupling_coefficients","This routine computes the Wigner 3-j coefficient,",null,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"}],"output":{"name":"f64"}}],[5,"_3j_e","","This routine computes the Wigner 3-j coefficient,",null,null],[5,"_6j","","This routine computes the Wigner 6-j coefficient,",null,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"}],"output":{"name":"f64"}}],[5,"_6j_e","","This routine computes the Wigner 6-j coefficient,",null,null],[5,"_9j","","This routine computes the Wigner 9-j coefficient,",null,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"},{"name":"i32"}],"output":{"name":"f64"}}],[5,"_9j_e","","This routine computes the Wigner 9-j coefficient,",null,null],[0,"dawson","rgsl","The Dawson integral is defined by \\exp(-x^2) \\int_0^x dt \\exp(t^2).\nA table of Dawson’s integral can be found in Abramowitz &amp; Stegun, Table 7.5.",null,null],[5,"dawson","rgsl::dawson","This routine computes the value of Dawson’s integral for x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"dawson_e","","This routine computes the value of Dawson’s integral for x.",null,null],[0,"debye","rgsl","The Debye functions D_n(x) are defined by the following integral,",null,null],[5,"_1","rgsl::debye","This routine computes the first-order Debye function D_1(x) = (1/x) \\int_0^x dt (t/(e^t - 1)).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"_1_e","","This routine computes the first-order Debye function D_1(x) = (1/x) \\int_0^x dt (t/(e^t - 1)).",null,null],[5,"_2","","This routine computes the second-order Debye function D_2(x) = (2/x^2) \\int_0^x dt (t^2/(e^t - 1)).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"_2_e","","This routine computes the second-order Debye function D_2(x) = (2/x^2) \\int_0^x dt (t^2/(e^t - 1)).",null,null],[5,"_3","","This routine computes the third-order Debye function D_3(x) = (3/x^3) \\int_0^x dt (t^3/(e^t - 1)).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"_3_e","","This routine computes the third-order Debye function D_3(x) = (3/x^3) \\int_0^x dt (t^3/(e^t - 1)).",null,null],[5,"_4","","This routine computes the fourth-order Debye function D_4(x) = (4/x^4) \\int_0^x dt (t^4/(e^t - 1)).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"_4_e","","This routine computes the fourth-order Debye function D_4(x) = (4/x^4) \\int_0^x dt (t^4/(e^t - 1)).",null,null],[5,"_5","","This routine computes the fifth-order Debye function D_5(x) = (5/x^5) \\int_0^x dt (t^5/(e^t - 1)).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"_5_e","","This routine computes the fifth-order Debye function D_5(x) = (5/x^5) \\int_0^x dt (t^5/(e^t - 1)).",null,null],[5,"_6","","This routine computes the sixth-order Debye function D_6(x) = (6/x^6) \\int_0^x dt (t^6/(e^t - 1)).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"_6_e","","This routine computes the sixth-order Debye function D_6(x) = (6/x^6) \\int_0^x dt (t^6/(e^t - 1)).",null,null],[0,"dilogarithm","rgsl","",null,null],[5,"dilog","rgsl::dilogarithm","These routines compute the dilogarithm for a real argument. In Lewin’s notation this is Li_2(x), the real part of the dilogarithm of a real x.\nIt is defined by the integral representation Li_2(x) = - \\Re \\int_0^x ds \\log(1-s) / s. Note that \\Im(Li_2(x)) = 0 for x &lt;= 1, and -\\pi\\log(x) for x &gt; 1.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"dilog_e","","These routines compute the dilogarithm for a real argument. In Lewin’s notation this is Li_2(x), the real part of the dilogarithm of a real x.\nIt is defined by the integral representation Li_2(x) = - \\Re \\int_0^x ds \\log(1-s) / s. Note that \\Im(Li_2(x)) = 0 for x &lt;= 1, and -\\pi\\log(x) for x &gt; 1.",null,null],[5,"complex_dilog_e","","This function computes the full complex-valued dilogarithm for the complex argument z = r \\exp(i \\theta).\nThe real and imaginary parts of the result are returned in result_re, result_im.",null,null],[0,"eigen","rgsl","##References and Further Reading",null,null],[5,"symmv_sort","rgsl::eigen","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding real eigenvectors stored in the columns\nof the matrix evec into ascending or descending order according to the value of the parameter sort_type",null,{"inputs":[{"name":"vectorf64"},{"name":"matrixf64"},{"name":"eigensort"}],"output":{"name":"value"}}],[5,"hermv_sort","","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding complex eigenvectors stored in the columns\nof the matrix evec into ascending or descending order according to the value of the parameter sort_type.",null,{"inputs":[{"name":"vectorf64"},{"name":"matrixcomplexf64"},{"name":"eigensort"}],"output":{"name":"value"}}],[5,"nonsymmv_sort","","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding complex eigenvectors stored in the columns\nof the matrix evec into ascending or descending order according to the value of the parameter sort_type. Only EigenSort::AbsAsc and\nEigenSort::AbsDesc are supported due to the eigenvalues being complex.",null,{"inputs":[{"name":"vectorcomplexf64"},{"name":"matrixcomplexf64"},{"name":"eigensort"}],"output":{"name":"value"}}],[5,"gensymmv_sort","","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding real eigenvectors stored in the columns\nof the matrix evec into ascending or descending order according to the value of the parameter sort_type.",null,{"inputs":[{"name":"vectorf64"},{"name":"matrixf64"},{"name":"eigensort"}],"output":{"name":"value"}}],[5,"genhermv_sort","","This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding complex eigenvectors stored in the\ncolumns of the matrix evec into ascending or descending order according to the value of the parameter sort_type.",null,{"inputs":[{"name":"vectorf64"},{"name":"matrixcomplexf64"},{"name":"eigensort"}],"output":{"name":"value"}}],[5,"genv_sort","","This function simultaneously sorts the eigenvalues stored in the vectors (alpha, beta) and the corresponding complex eigenvectors stored\nin the columns of the matrix evec into ascending or descending order according to the value of the parameter sort_type. Only\nEigenSort::AbsAsc and EigenSort::AbsDesc are supported due to the eigenvalues being complex.",null,{"inputs":[{"name":"vectorcomplexf64"},{"name":"vectorf64"},{"name":"matrixcomplexf64"},{"name":"eigensort"}],"output":{"name":"value"}}],[0,"elementary","rgsl","",null,null],[8,"Elementary","rgsl::elementary","",null,null],[10,"log1p","","This function computes the value of __log(1+x)__ in a way that is accurate for small x. It provides an alternative to the BSD math function log1p(x).",93,null],[10,"expm1","","This function computes the value of __exp(x)-1__ in a way that is accurate for small x. It provides an alternative to the BSD math function expm1(x).",93,null],[10,"hypot","","This function computes the value of __sqrt{x^2 + y^2}__ in a way that avoids overflow. It provides an alternative to the BSD math function hypot(x,y).",93,null],[10,"hypot3","","This function computes the value of __sqrt{x^2 + y^2 + z^2}__ in a way that avoids overflow.",93,null],[10,"acosh","","This function computes the value of __arccosh(x)__. It provides an alternative to the standard math function acosh(x).",93,null],[10,"asinh","","This function computes the value of __arcsinh(x)__. It provides an alternative to the standard math function asinh(x).",93,null],[10,"atanh","","This function computes the value of __arctanh(x)__. It provides an alternative to the standard math function atanh(x).",93,null],[10,"ldexp","","This function computes the value of __x * 2^e__. It provides an alternative to the standard math function ldexp(x,e).",93,null],[10,"frexp","","This function splits the number x into its normalized fraction f and exponent e, such that x = f * 2^e and 0.5 &lt;= f &lt; 1. The function returns f and stores the exponent in e.\nIf x is zero, both f and e are set to zero. This function provides an alternative to the standard math function frexp(x, e).",93,null],[0,"elementary_operations","rgsl","",null,null],[5,"multiply_e","rgsl::elementary_operations","This function multiplies x and y storing the product and its associated error in result.",null,null],[5,"multiply_err_e","","This function multiplies x and y with associated absolute errors dx and dy.\nThe product xy +/- xy \\sqrt((dx/x)^2 +(dy/y)^2) is stored in result.",null,null],[0,"elliptic","rgsl","Further information about the elliptic integrals can be found in Abramowitz &amp; Stegun, Chapter 17.",null,null],[0,"legendre","rgsl::elliptic","The Legendre forms of elliptic integrals F(\\phi,k), E(\\phi,k) and \\Pi(\\phi,k,n) are defined by,",null,null],[0,"complete","rgsl::elliptic::legendre","",null,null],[5,"ellint_Kcomp","rgsl::elliptic::legendre::complete","This routine computes the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameter m = k^2.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_Kcomp_e","","This routine computes the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameter m = k^2.",null,null],[5,"ellint_Ecomp","","This routine computes the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameter m = k^2.",null,{"inputs":[{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_Ecomp_e","","This routine computes the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameter m = k^2.",null,null],[5,"ellint_Pcomp","","This routine computes the complete elliptic integral \\Pi(k,n) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_Pcomp_e","","This routine computes the complete elliptic integral \\Pi(k,n) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.",null,null],[0,"incomplete","rgsl::elliptic::legendre","",null,null],[5,"ellint_F","rgsl::elliptic::legendre::incomplete","This routine computes the incomplete elliptic integral F(\\phi,k) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameter m = k^2.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_F_e","","This routine computes the incomplete elliptic integral F(\\phi,k) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameter m = k^2.",null,null],[5,"ellint_E","","This routine computes the incomplete elliptic integral E(\\phi,k) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameter m = k^2.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_E_e","","This routine computes the incomplete elliptic integral E(\\phi,k) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameter m = k^2.",null,null],[5,"ellint_P","","This routine computes the incomplete elliptic integral \\Pi(\\phi,k,n) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_P_e","","This routine computes the incomplete elliptic integral \\Pi(\\phi,k,n) to the accuracy specified by the mode variable mode.\nNote that Abramowitz &amp; Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.",null,null],[5,"ellint_D","","This routine computes the incomplete elliptic integral D(\\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_D_e","","This routine computes the incomplete elliptic integral D(\\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,",null,null],[0,"carlson","rgsl::elliptic","The Carlson symmetric forms of elliptical integrals RC(x,y), RD(x,y,z), RF(x,y,z) and RJ(x,y,z,p) are defined by,",null,null],[5,"ellint_RC","rgsl::elliptic::carlson","This routine computes the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_RC_e","","This routine computes the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.",null,null],[5,"ellint_RD","","This routine computes the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_RD_e","","This routine computes the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.",null,null],[5,"ellint_RF","","This routine computes the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_RF_e","","This routine computes the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.",null,null],[5,"ellint_RJ","","This routine computes the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"mode"}],"output":{"name":"f64"}}],[5,"ellint_RJ_e","","This routine computes the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.",null,null],[0,"error","rgsl","The error function is described in Abramowitz &amp; Stegun, Chapter 7.",null,null],[5,"erf","rgsl::error","This routine computes the error function erf(x), where erf(x) = (2/\\sqrt(\\pi)) \\int_0^x dt \\exp(-t^2).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"erf_e","","This routine computes the error function erf(x), where erf(x) = (2/\\sqrt(\\pi)) \\int_0^x dt \\exp(-t^2).",null,null],[5,"erfc","","This routine computes the complementary error function erfc(x) = 1 - erf(x) = (2/\\sqrt(\\pi)) \\int_x^\\infty \\exp(-t^2).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"erfc_e","","This routine computes the complementary error function erfc(x) = 1 - erf(x) = (2/\\sqrt(\\pi)) \\int_x^\\infty \\exp(-t^2).",null,null],[5,"log_erfc","","This routine computes the logarithm of the complementary error function \\log(\\erfc(x)).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"log_erfc_e","","This routine computes the logarithm of the complementary error function \\log(\\erfc(x)).",null,null],[5,"erf_Z","","This routine computes the Gaussian probability density function Z(x) = (1/\\sqrt{2\\pi}) \\exp(-x^2/2).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"erf_Z_e","","This routine computes the Gaussian probability density function Z(x) = (1/\\sqrt{2\\pi}) \\exp(-x^2/2).",null,null],[5,"erf_Q","","This routine computes the upper tail of the Gaussian probability function Q(x) = (1/\\sqrt{2\\pi}) \\int_x^\\infty dt \\exp(-t^2/2).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"erf_Q_e","","This routine computes the upper tail of the Gaussian probability function Q(x) = (1/\\sqrt{2\\pi}) \\int_x^\\infty dt \\exp(-t^2/2).",null,null],[5,"hazard","","This routine computes the hazard function for the normal distribution.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"hazard_e","","This routine computes the hazard function for the normal distribution.",null,null],[5,"str_error","","",null,{"inputs":[{"name":"value"}],"output":{"name":"str"}}],[0,"exponential","rgsl","",null,null],[5,"exp","rgsl::exponential","This routine provides an exponential function \\exp(x) using GSL semantics and error checking.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"exp_e","","This routine provides an exponential function \\exp(x) using GSL semantics and error checking.",null,null],[5,"exp_e10_e","","This function computes the exponential \\exp(x) using the gsl_sf_result_e10 type to return a result with extended range.\nThis function may be useful if the value of \\exp(x) would overflow the numeric range of double.",null,null],[5,"exp_mult","","This routine exponentiates x and multiply by the factor y to return the product y \\exp(x).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exp_mult_e","","This routine exponentiates x and multiply by the factor y to return the product y \\exp(x).",null,null],[5,"exp_mult_e10_e","","This function computes the exponential \\exp(x) using the gsl_sf_result_e10 type to return a result with extended range.\nThis function may be useful if the value of \\exp(x) would overflow the numeric range of double.",null,null],[5,"expm1","","This routine computes the quantity \\exp(x)-1 using an algorithm that is accurate for small x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"expm1_e","","This routine computes the quantity \\exp(x)-1 using an algorithm that is accurate for small x.",null,null],[5,"exprel","","This routine computes the quantity (\\exp(x)-1)/x using an algorithm that is accurate for small x.\nFor small x the algorithm is based on the expansion (\\exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + \\dots.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"exprel_e","","This routine computes the quantity (\\exp(x)-1)/x using an algorithm that is accurate for small x.\nFor small x the algorithm is based on the expansion (\\exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + \\dots.",null,null],[5,"exprel_2","","This routine computes the quantity 2(\\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.\nFor small x the algorithm is based on the expansion 2(\\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \\dots.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"exprel_2_e","","This routine computes the quantity 2(\\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.\nFor small x the algorithm is based on the expansion 2(\\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \\dots.",null,null],[5,"exprel_n","","This routine computes the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.\nThe N-relative exponential is given by:",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"exprel_n_e","","This routine computes the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.\nThe N-relative exponential is given by:",null,null],[5,"exp_err_e","","This function exponentiates x with an associated absolute error dx.",null,null],[5,"exp_err_e10_e","","This function exponentiates a quantity x with an associated absolute error dx using the ::types::ResultE10 type to return a result with extended range.",null,null],[5,"exp_mult_err_e","","This routine computes the product y \\exp(x) for the quantities x, y with associated absolute errors dx, dy.",null,null],[5,"exp_mult_err_e10_e","","This routine computes the product y \\exp(x) for the quantities x, y with associated absolute errors dx, dy using the gsl_sf_result_e10 type to return a result with extended range.",null,null],[0,"exponential_integrals","rgsl","",null,null],[5,"E1","rgsl::exponential_integrals","This routine computes the exponential integral E_1(x),",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"E1_e","","This routine computes the exponential integral E_1(x),",null,null],[5,"E2","","This routine computes the second-order exponential integral E_2(x),",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"E2_e","","This routine computes the second-order exponential integral E_2(x),",null,null],[5,"En","","This routine computes the exponential integral E_n(x) of order n,",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"En_e","","This routine computes the exponential integral E_n(x) of order n,",null,null],[5,"Ei","","This routine computes the exponential integral Ei(x),",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"Ei_e","","This routine computes the exponential integral Ei(x),",null,null],[5,"Shi","","This routine computes the integral Shi(x) = \\int_0^x dt \\sinh(t)/t.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"Shi_e","","This routine computes the integral Shi(x) = \\int_0^x dt \\sinh(t)/t.",null,null],[5,"Chi","","This routine computes the integral Chi(x) := \\Re[ \\gamma_E + \\log(x) + \\int_0^x dt (\\cosh(t)-1)/t] , where \\gamma_E is the Euler constant (available as the macro M_EULER).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"Chi_e","","This routine computes the integral Chi(x) := \\Re[ \\gamma_E + \\log(x) + \\int_0^x dt (\\cosh(t)-1)/t] , where \\gamma_E is the Euler constant (available as the macro M_EULER).",null,null],[5,"_3","","This routine computes the third-order exponential integral Ei_3(x) = \\int_0^xdt \\exp(-t^3) for x &gt;= 0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"_3_e","","This routine computes the third-order exponential integral Ei_3(x) = \\int_0^xdt \\exp(-t^3) for x &gt;= 0.",null,null],[5,"Si","","This routine computes the Sine integral Si(x) = \\int_0^x dt \\sin(t)/t.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"Si_e","","This routine computes the Sine integral Si(x) = \\int_0^x dt \\sin(t)/t.",null,null],[5,"Ci","","This routine computes the Cosine integral Ci(x) = -\\int_x^\\infty dt \\cos(t)/t for x &gt; 0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"Ci_e","","This routine computes the Cosine integral Ci(x) = -\\int_x^\\infty dt \\cos(t)/t for x &gt; 0.",null,null],[5,"atanint","","This routine computes the Arctangent integral, which is defined as AtanInt(x) = \\int_0^x dt \\arctan(t)/t.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"atanint_e","","This routine computes the Arctangent integral, which is defined as AtanInt(x) = \\int_0^x dt \\arctan(t)/t.",null,null],[0,"fermi_dirac","rgsl","",null,null],[0,"complete_integrals","rgsl::fermi_dirac","The complete Fermi-Dirac integral F_j(x) is given by,",null,null],[5,"fermi_dirac_m1","rgsl::fermi_dirac::complete_integrals","This routine computes the complete Fermi-Dirac integral with an index of -1.\nThis integral is given by F_{-1}(x) = e^x / (1 + e^x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"fermi_dirac_m1_e","","This routine computes the complete Fermi-Dirac integral with an index of -1.\nThis integral is given by F_{-1}(x) = e^x / (1 + e^x).",null,null],[5,"fermi_dirac_0","","This routine computes the complete Fermi-Dirac integral with an index of 0.\nThis integral is given by F_0(x) = \\ln(1 + e^x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"fermi_dirac_0_e","","This routine computes the complete Fermi-Dirac integral with an index of 0.\nThis integral is given by F_0(x) = \\ln(1 + e^x).",null,null],[5,"fermi_dirac_1","","This routine computes the complete Fermi-Dirac integral with an index of 1, F_1(x) = \\int_0^\\infty dt (t /(\\exp(t-x)+1)).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"fermi_dirac_1_e","","This routine computes the complete Fermi-Dirac integral with an index of 1, F_1(x) = \\int_0^\\infty dt (t /(\\exp(t-x)+1)).",null,null],[5,"fermi_dirac_2","","This routine computes the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \\int_0^\\infty dt (t^2 /(\\exp(t-x)+1)).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"fermi_dirac_2_e","","This routine computes the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \\int_0^\\infty dt (t^2 /(\\exp(t-x)+1)).",null,null],[5,"fermi_dirac_int","","This routine computes the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\\Gamma(j+1)) \\int_0^\\infty dt (t^j /(\\exp(t-x)+1)).",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"fermi_dirac_int_e","","This routine computes the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\\Gamma(j+1)) \\int_0^\\infty dt (t^j /(\\exp(t-x)+1)).",null,null],[5,"fermi_dirac_mhalf","","This routine computes the complete Fermi-Dirac integral F_{-1/2}(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"fermi_dirac_mhalf_e","","This routine computes the complete Fermi-Dirac integral F_{-1/2}(x).",null,null],[5,"fermi_dirac_half","","This routine computes the complete Fermi-Dirac integral F_{1/2}(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"fermi_dirac_half_e","","This routine computes the complete Fermi-Dirac integral F_{1/2}(x).",null,null],[5,"fermi_dirac_3half","","This routine computes the complete Fermi-Dirac integral F_{3/2}(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"fermi_dirac_3half_e","","This routine computes the complete Fermi-Dirac integral F_{3/2}(x).",null,null],[0,"incomplete_integrals","rgsl::fermi_dirac","The incomplete Fermi-Dirac integral F_j(x,b) is given by,",null,null],[5,"fermi_dirac_inc_0","rgsl::fermi_dirac::incomplete_integrals","This routine computes the incomplete Fermi-Dirac integral with an index of zero, F_0(x,b) = \\ln(1 + e^{b-x}) - (b-x).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"fermi_dirac_inc_0_e","","This routine computes the incomplete Fermi-Dirac integral with an index of zero, F_0(x,b) = \\ln(1 + e^{b-x}) - (b-x).",null,null],[0,"fft","rgsl","#Fast Fourier Transforms (FFTs)",null,null],[0,"radix2","rgsl::fft","These functions compute forward, backward and inverse FFTs of length n with stride stride, on the packed complex array data using an in-place radix-2\ndecimation-in-time algorithm. The length of the transform is restricted to powers of two. For the transform version of the function\nthe sign argument can be either forward (-1) or backward (+1).",null,null],[5,"forward","rgsl::fft::radix2","",null,null],[5,"transform","","",null,null],[5,"backward","","",null,null],[5,"inverse","","",null,null],[5,"dif_forward","","This is decimation-in-frequency version of the radix-2 FFT function.",null,null],[5,"dif_transform","","This is decimation-in-frequency version of the radix-2 FFT function.",null,null],[5,"dif_backward","","This is decimation-in-frequency version of the radix-2 FFT function.",null,null],[5,"dif_inverse","","This is decimation-in-frequency version of the radix-2 FFT function.",null,null],[0,"mixed_radix","rgsl::fft","These functions compute forward, backward and inverse FFTs of length n with stride stride, on the packed complex array data, using a\nmixed radix decimation-in-frequency algorithm. There is no restriction on the length n. Efficient modules are provided for subtransforms\nof length 2, 3, 4, 5, 6 and 7. Any remaining factors are computed with a slow, O(n^2), general-n module. The caller must supply a\nwavetable containing the trigonometric lookup tables and a workspace work. For the transform version of the function the sign argument\ncan be either forward (-1) or backward (+1).",null,null],[5,"forward","rgsl::fft::mixed_radix","",null,null],[5,"transform","","",null,null],[5,"backward","","",null,null],[5,"inverse","","",null,null],[0,"real_radix2","rgsl::fft","This section describes radix-2 FFT algorithms for real data. They use the Cooley-Tukey algorithm to compute in-place FFTs for lengths which\nare a power of 2.",null,null],[5,"transform","rgsl::fft::real_radix2","This function computes an in-place radix-2 FFT of length n and stride stride on the real array data. The output is a half-complex sequence,\nwhich is stored in-place. The arrangement of the half-complex terms uses the following scheme: for k &lt; n/2 the real part of the k-th term\nis stored in location k, and the corresponding imaginary part is stored in location n-k. Terms with k &gt; n/2 can be reconstructed using the\nsymmetry z_k = z^*_{n-k}. The terms for k=0 and k=n/2 are both purely real, and count as a special case. Their real parts are stored in\nlocations 0 and n/2 respectively, while their imaginary parts which are zero are not stored.",null,null],[5,"inverse","","This function computes the inverse or backwards in-place radix-2 FFT of length n and stride stride on the half-complex sequence data\nstored according the output scheme used by gsl_fft_real_radix2. The result is a real array stored in natural order.",null,null],[5,"backward","","This function computes the inverse or backwards in-place radix-2 FFT of length n and stride stride on the half-complex sequence data\nstored according the output scheme used by gsl_fft_real_radix2. The result is a real array stored in natural order.",null,null],[5,"unpack","","This function converts halfcomplex_coefficient, an array of half-complex coefficients as returned by gsl_fft_real_radix2_transform,\ninto an ordinary complex array, complex_coefficient. It fills in the complex array using the symmetry z_k = z_{n-k}^* to reconstruct\nthe redundant elements. The algorithm for the conversion is,",null,null],[0,"fit","rgsl","Linear Regression",null,null],[5,"linear","rgsl::fit","This function computes the best-fit linear regression coefficients (c0,c1) of the model Y = c_0 + c_1 X for the dataset (x, y), two vectors of length n with strides xstride and ystride.\nThe errors on y are assumed unknown so the variance-covariance matrix for the parameters (c0, c1) is estimated from the scatter of the points around the best-fit line and returned via the parameters (cov00, cov01, cov11).\nThe sum of squares of the residuals from the best-fit line is returned in sumsq. Note: the correlation coefficient of the data can be computed using gsl_stats_correlation (see [`Correlation`](http://www.gnu.org/software/gsl/manual/html_node/Correlation.html#Correlation)), it does not depend on the fit.",null,null],[5,"wlinear","","This function computes the best-fit linear regression coefficients (c0,c1) of the model Y = c_0 + c_1 X for the weighted dataset (x, y), two vectors of length n with strides xstride and ystride.\nThe vector w, of length n and stride wstride, specifies the weight of each datapoint.\nThe weight is the reciprocal of the variance for each datapoint in y.",null,null],[5,"linear_est","","This function uses the best-fit linear regression coefficients c0, c1 and their covariance cov00, cov01, cov11 to compute the fitted function y and its standard deviation y_err for the model Y = c_0 + c_1 X at the point x.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[5,"mul","","This function computes the best-fit linear regression coefficient c1 of the model Y = c_1 X for the datasets (x, y), two vectors of length n with strides xstride and ystride.\nThe errors on y are assumed unknown so the variance of the parameter c1 is estimated from the scatter of the points around the best-fit line and returned via the parameter cov11.\nThe sum of squares of the residuals from the best-fit line is returned in sumsq.",null,null],[5,"wmul","","This function computes the best-fit linear regression coefficient c1 of the model Y = c_1 X for the weighted datasets (x, y), two vectors of length n with strides xstride and ystride.\nThe vector w, of length n and stride wstride, specifies the weight of each datapoint.\nThe weight is the reciprocal of the variance for each datapoint in y.",null,null],[5,"mul_est","","This function uses the best-fit linear regression coefficient c1 and its covariance cov11 to compute the fitted function y and its standard deviation y_err for the model Y = c_1 X at the point x.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[0,"gamma_beta","rgsl","This following routines compute the gamma and beta functions in their full and incomplete forms, as well as various kinds of factorials.",null,null],[0,"gamma","rgsl::gamma_beta","The Gamma function is defined by the following integral,",null,null],[5,"gamma","rgsl::gamma_beta::gamma","These routines compute the Gamma function \\Gamma(x), subject to x not being a negative integer or zero. The function is computed using the real Lanczos method.\nThe maximum value of x such that \\Gamma(x) is not considered an overflow is given by the macro GSL_SF_GAMMA_XMAX and is 171.0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_e","","This routine provides an exponential function \\exp(x) using GSL semantics and error checking.",null,null],[5,"lngamma","","This routine computes the Gamma function \\Gamma(x), subject to x not being a negative integer or zero.\nThe function is computed using the real Lanczos method. The maximum value of x such that \\Gamma(x) is not considered an overflow is given by the macro GSL_SF_GAMMA_XMAX and is 171.0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"lngamma_e","","This routine computes the Gamma function \\Gamma(x), subject to x not being a negative integer or zero.\nThe function is computed using the real Lanczos method. The maximum value of x such that \\Gamma(x) is not considered an overflow is given by the macro GSL_SF_GAMMA_XMAX and is 171.0.",null,null],[5,"lngamma_sgn_e","","This routine computes the sign of the gamma function and the logarithm of its magnitude, subject to x not being a negative integer or zero.\nThe function is computed using the real Lanczos method.\nThe value of the gamma function and its error can be reconstructed using the relation \\Gamma(x) = sgn * \\exp(result\\_lg), taking into account the two components of result_lg.",null,null],[5,"gammastar","","This routine computes the regulated Gamma Function \\Gamma^*(x) for x &gt; 0. The regulated gamma function is given by,",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"gammastar_e","","This routine computes the regulated Gamma Function \\Gamma^*(x) for x &gt; 0. The regulated gamma function is given by,",null,null],[5,"gammainv","","This routine computes the reciprocal of the gamma function, 1/\\Gamma(x) using the real Lanczos method.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"gammainv_e","","This routine computes the reciprocal of the gamma function, 1/\\Gamma(x) using the real Lanczos method.",null,null],[5,"lngamma_complex_e","","This routine computes \\log(\\Gamma(z)) for complex z=z_r+i z_i and z not a negative integer or zero, using the complex Lanczos method.\nThe returned parameters are lnr = \\log|\\Gamma(z)| and arg = \\arg(\\Gamma(z)) in (-\\pi,\\pi]. Note that the phase part (arg) is not well-determined when |z| is very large, due to inevitable roundoff in restricting to (-\\pi,\\pi].\nThis will result in a GSL_ELOSS error when it occurs. The absolute value part (lnr), however, never suffers from loss of precision.",null,null],[0,"factorials","rgsl::gamma_beta","Although factorials can be computed from the Gamma function, using the relation n! = \\Gamma(n+1) for non-negative integer n, it is usually more\nefficient to call the functions in this section, particularly for small values of n, whose factorial values are maintained in hardcoded tables.",null,null],[5,"fact","rgsl::gamma_beta::factorials","This routine computes the factorial n!. The factorial is related to the Gamma function by n! = \\Gamma(n+1).\nThe maximum value of n such that n! is not considered an overflow is given by the macro SF_FACT_NMAX and is 170.",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"fact_e","","This routine computes the factorial n!. The factorial is related to the Gamma function by n! = \\Gamma(n+1).\nThe maximum value of n such that n! is not considered an overflow is given by the macro SF_FACT_NMAX and is 170.",null,null],[5,"doublefact","","This routine computes the double factorial n!! = n(n-2)(n-4) \\dots.\nThe maximum value of n such that n!! is not considered an overflow is given by the macro SF_DOUBLEFACT_NMAX and is 297.",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"doublefact_e","","This routine computes the double factorial n!! = n(n-2)(n-4) \\dots.\nThe maximum value of n such that n!! is not considered an overflow is given by the macro SF_DOUBLEFACT_NMAX and is 297.",null,null],[5,"lnfact","","This routine computes the logarithm of the factorial of n, \\log(n!).\nThe algorithm is faster than computing \\ln(\\Gamma(n+1)) via gsl_sf_lngamma for n &lt; 170, but defers for larger n.",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"lnfact_e","","This routine computes the logarithm of the factorial of n, \\log(n!).\nThe algorithm is faster than computing \\ln(\\Gamma(n+1)) via gsl_sf_lngamma for n &lt; 170, but defers for larger n.",null,null],[5,"lndoublefact","","This routine computes the logarithm of the double factorial of n, \\log(n!!).",null,{"inputs":[{"name":"u32"}],"output":{"name":"f64"}}],[5,"lndoublefact_e","","This routine computes the logarithm of the double factorial of n, \\log(n!!).",null,null],[5,"choose","","This routine computes the combinatorial factor n choose m = n!/(m!(n-m)!)",null,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"f64"}}],[5,"choose_e","","This routine computes the combinatorial factor n choose m = n!/(m!(n-m)!)",null,null],[5,"lnchoose","","This routine computes the logarithm of n choose m. This is equivalent to the sum \\log(n!) - \\log(m!) - \\log((n-m)!).",null,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"f64"}}],[5,"lnchoose_e","","This routine computes the logarithm of n choose m. This is equivalent to the sum \\log(n!) - \\log(m!) - \\log((n-m)!).",null,null],[5,"taylorcoeff","","This routine computes the Taylor coefficient x^n / n! for x &gt;= 0, n &gt;= 0.",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"taylorcoeff_e","","This routine computes the Taylor coefficient x^n / n! for x &gt;= 0, n &gt;= 0.",null,null],[0,"pochhammer_symbol","rgsl::gamma_beta","",null,null],[5,"poch","rgsl::gamma_beta::pochhammer_symbol","This routine computes the Pochhammer symbol (a)_x = \\Gamma(a + x)/\\Gamma(a).\nThe Pochhammer symbol is also known as the Apell symbol and sometimes written as (a,x).\nWhen a and a+x are negative integers or zero, the limiting value of the ratio is returned.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"poch_e","","This routine computes the Pochhammer symbol (a)_x = \\Gamma(a + x)/\\Gamma(a).\nThe Pochhammer symbol is also known as the Apell symbol and sometimes written as (a,x).\nWhen a and a+x are negative integers or zero, the limiting value of the ratio is returned.",null,null],[5,"lnpoch","","This routine computes the logarithm of the Pochhammer symbol, \\log((a)_x) = \\log(\\Gamma(a + x)/\\Gamma(a)).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"lnpoch_e","","This routine computes the logarithm of the Pochhammer symbol, \\log((a)_x) = \\log(\\Gamma(a + x)/\\Gamma(a)).",null,null],[5,"lnpoch_sgn_e","","These routines compute the sign of the Pochhammer symbol and the logarithm of its magnitude.\nThe computed parameters are result = \\log(|(a)_x|) with a corresponding error term, and sgn = \\sgn((a)_x) where (a)_x = \\Gamma(a + x)/\\Gamma(a).",null,null],[5,"pochrel","","This routine computes the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \\Gamma(a + x)/\\Gamma(a).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"pochrel_e","","This routine computes the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \\Gamma(a + x)/\\Gamma(a).",null,null],[0,"beta","rgsl::gamma_beta","",null,null],[5,"beta","rgsl::gamma_beta::beta","This routine computes the Beta Function, B(a,b) = \\Gamma(a)\\Gamma(b)/\\Gamma(a+b) subject to a and b not being negative integers.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"beta_e","","This routine computes the Beta Function, B(a,b) = \\Gamma(a)\\Gamma(b)/\\Gamma(a+b) subject to a and b not being negative integers.",null,null],[5,"lnbeta","","This routine computes the logarithm of the Beta Function, \\log(B(a,b)) subject to a and b not being negative integers.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"lnbeta_e","","This routine computes the logarithm of the Beta Function, \\log(B(a,b)) subject to a and b not being negative integers.",null,null],[0,"incomplete_gamma","rgsl::gamma_beta","",null,null],[5,"gamma_inc","rgsl::gamma_beta::incomplete_gamma","This routine computes the unnormalized incomplete Gamma Function \\Gamma(a,x) = \\int_x^\\infty dt t^{a-1} \\exp(-t) for a real and x &gt;= 0.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_inc_e","","This routine computes the unnormalized incomplete Gamma Function \\Gamma(a,x) = \\int_x^\\infty dt t^{a-1} \\exp(-t) for a real and x &gt;= 0.",null,null],[5,"gamma_inc_Q","","This routine computes the normalized incomplete Gamma Function Q(a,x) = 1/\\Gamma(a) \\int_x^\\infty dt t^{a-1} \\exp(-t) for a &gt; 0, x &gt;= 0.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_inc_Q_e","","This routine computes the normalized incomplete Gamma Function Q(a,x) = 1/\\Gamma(a) \\int_x^\\infty dt t^{a-1} \\exp(-t) for a &gt; 0, x &gt;= 0.",null,null],[5,"gamma_inc_P","","This routine computes the complementary normalized incomplete Gamma Function P(a,x) = 1 - Q(a,x) = 1/\\Gamma(a) \\int_0^x dt t^{a-1} \\exp(-t) for a &gt; 0, x &gt;= 0.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gamma_inc_P_e","","This routine computes the complementary normalized incomplete Gamma Function P(a,x) = 1 - Q(a,x) = 1/\\Gamma(a) \\int_0^x dt t^{a-1} \\exp(-t) for a &gt; 0, x &gt;= 0.",null,null],[0,"incomplete_beta","rgsl::gamma_beta","",null,null],[5,"beta_inc","rgsl::gamma_beta::incomplete_beta","This routine computes the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where B_x(a,b) = \\int_0^x t^{a-1} (1-t)^{b-1} dt for 0 &lt;= x &lt;= 1.\nFor a &gt; 0, b &gt; 0 the value is computed using a continued fraction expansion.\nFor all other values it is computed using the relation I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"beta_inc_e","","This routine computes the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where B_x(a,b) = \\int_0^x t^{a-1} (1-t)^{b-1} dt for 0 &lt;= x &lt;= 1.\nFor a &gt; 0, b &gt; 0 the value is computed using a continued fraction expansion.\nFor all other values it is computed using the relation I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).",null,null],[0,"gegenbauer","rgsl","The Gegenbauer polynomials are defined in Abramowitz &amp; Stegun, Chapter 22, where they are known as Ultraspherical polynomials.",null,null],[5,"gegenpoly_1","rgsl::gegenbauer","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gegenpoly_2","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gegenpoly_3","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gegenpoly_1_e","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",null,null],[5,"gegenpoly_2_e","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",null,null],[5,"gegenpoly_3_e","","This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.",null,null],[5,"gegenpoly_n","","This function evaluates the Gegenbauer polynomial C^{(\\lambda)}_n(x) for a specific value of n, lambda, x subject to \\lambda &gt; -1/2, n &gt;= 0.",null,{"inputs":[{"name":"i32"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"gegenpoly_n_e","","This function evaluates the Gegenbauer polynomial C^{(\\lambda)}_n(x) for a specific value of n, lambda, x subject to \\lambda &gt; -1/2, n &gt;= 0.",null,null],[5,"gegenpoly_array","","This function computes an array of Gegenbauer polynomials C^{(\\lambda)}_n(x) for n = 0, 1, 2, \\dots, nmax, subject to \\lambda &gt; -1/2, nmax &gt;= 0.",null,null],[0,"hypergeometric","rgsl","Hypergeometric functions are described in Abramowitz &amp; Stegun, Chapters 13 and 15.",null,null],[5,"hyperg_0F1","rgsl::hypergeometric","This routine computes the hypergeometric function 0F1(c,x).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_0F1_e","","This routine computes the hypergeometric function 0F1(c,x).",null,null],[5,"hyperg_1F1_int","","This routine computes the confluent hypergeometric function 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.",null,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_1F1_int_e","","This routine computes the confluent hypergeometric function 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.",null,null],[5,"hyperg_1F1","","This routine computes the confluent hypergeometric function 1F1(a,b,x) = M(a,b,x) for general parameters a, b.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_1F1_e","","This routine computes the confluent hypergeometric function 1F1(a,b,x) = M(a,b,x) for general parameters a, b.",null,null],[5,"hyperg_1F1_U_int","","This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n.",null,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_1F1_U_int_e","","This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n.",null,null],[5,"hyperg_1F1_U_int_e10_e","","This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n using the\n[`ResultE10]`(types/result/struct.ResultE10.html) type to return a result with extended range.",null,null],[5,"hyperg_U","","This routine computes the confluent hypergeometric function U(a,b,x).",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_U_e","","This routine computes the confluent hypergeometric function U(a,b,x).",null,null],[5,"hyperg_U_e10_e","","This routine computes the confluent hypergeometric function U(a,b,x) using the\n[`ResultE10]`(types/result/struct.ResultE10.html) type to return a result with extended range.",null,null],[5,"hyperg_2F1","","This routine computes the Gauss hypergeometric function 2F1(a,b,c,x) = F(a,b,c,x) for |x| &lt; 1.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_2F1_e","","This routine computes the Gauss hypergeometric function 2F1(a,b,c,x) = F(a,b,c,x) for |x| &lt; 1.",null,null],[5,"hyperg_2F1_conj","","This routine computes the Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for |x| &lt; 1.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_2F1_conj_e","","This routine computes the Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for |x| &lt; 1.",null,null],[5,"hyperg_2F1_renorm","","This routine computes the renormalized Gauss hypergeometric function 2F1(a,b,c,x) / \\Gamma(c) for |x| &lt; 1.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_2F1_renorm_e","","This routine computes the renormalized Gauss hypergeometric function 2F1(a,b,c,x) / \\Gamma(c) for |x| &lt; 1.",null,null],[5,"hyperg_2F1_conj_renorm","","This routine computes the renormalized Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) / \\Gamma(c) for |x| &lt; 1.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_2F1_conj_renorm_e","","This routine computes the renormalized Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) / \\Gamma(c) for |x| &lt; 1.",null,null],[5,"hyperg_2F0","","This routine computes the hypergeometric function 2F0(a,b,x). The series representation is a divergent hypergeometric series.\nHowever, for x &lt; 0 we have 2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hyperg_2F0_e","","This routine computes the hypergeometric function 2F0(a,b,x). The series representation is a divergent hypergeometric series.\nHowever, for x &lt; 0 we have 2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)",null,null],[0,"integration","rgsl","##Introduction",null,null],[5,"qng","rgsl::integration","This function applies the Gauss-Kronrod 10-point, 21-point, 43-point and 87-point integration rules in succession until an estimate of the\nintegral of f over (a,b) is achieved within the desired absolute and relative error limits, eps_abs and eps_rel. The function returns the final\napproximation, result, an estimate of the absolute error, abserr and the number of function evaluations used, neval. The Gauss-Kronrod rules\nare designed in such a way that each rule uses all the results of its predecessors, in order to minimize the total number of function\nevaluations.",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"usize"}],"output":{"name":"value"}}],[5,"qk15","","Gauss quadrature weights and kronrod quadrature abscissae and weights as evaluated with 80 decimal digit arithmetic by L. W.\nFullerton, Bell Labs, Nov. 1981.",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"qk21","","",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"qk31","","",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"qk41","","",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"qk51","","",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"qk61","","",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":null}],[5,"qk","","",null,null],[5,"qawf","","This function attempts to compute a Fourier integral of the function f over the semi-infinite interval [a,+\\infty).",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"usize"},{"name":"integrationworkspace"},{"name":"integrationworkspace"},{"name":"integrationqawotable"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[0,"interpolation","rgsl","",null,null],[5,"bsearch","rgsl::interpolation","This function returns the index i of the array x_array such that x_array[i] &lt;= x &lt; x_array[i+1]. The index is searched for in the\nrange [index_lo,index_hi].",null,null],[5,"eval","","This function returns the interpolated value of y for a given point x, using the interpolation object interp, data arrays xa and ya and\nthe accelerator acc. When x is outside the range of xa, the error code ::Dom is returned with a value of rgsl::NAN for y.",null,null],[5,"eval_e","","This function returns the interpolated value of y for a given point x, using the interpolation object interp, data arrays xa and ya and\nthe accelerator acc. When x is outside the range of xa, the error code ::Dom is returned with a value of rgsl::NAN for y.",null,null],[5,"eval_deriv","","This function returns the derivative d of an interpolated function for a given point x, using the interpolation object interp, data\narrays xa and ya and the accelerator acc.",null,null],[5,"eval_deriv_e","","This function returns the derivative d of an interpolated function for a given point x, using the interpolation object interp, data\narrays xa and ya and the accelerator acc.",null,null],[5,"eval_deriv2","","This function returns the second derivative d2 of an interpolated function for a given point x, using the interpolation object interp,\ndata arrays xa and ya and the accelerator acc.",null,null],[5,"eval_deriv2_e","","This function returns the second derivative d2 of an interpolated function for a given point x, using the interpolation object interp,\ndata arrays xa and ya and the accelerator acc.",null,null],[5,"eval_integ","","This function returns the numerical integral result of an interpolated function over the range [a, b], using the interpolation object\ninterp, data arrays xa and ya and the accelerator acc.",null,null],[5,"eval_integ_e","","This function returns the numerical integral result of an interpolated function over the range [a, b], using the interpolation object\ninterp, data arrays xa and ya and the accelerator acc.",null,null],[0,"jacobian_elliptic","rgsl","The Jacobian Elliptic functions are defined in Abramowitz &amp; Stegun, Chapter 16.",null,null],[5,"elljac_e","rgsl::jacobian_elliptic","This function computes the Jacobian elliptic functions sn(u|m), cn(u|m), dn(u|m) by descending Landen transformations.",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[0,"laguerre","rgsl","The generalized Laguerre polynomials are defined in terms of confluent hypergeometric functions as L^a_n(x) = ((a+1)_n / n!) 1F1(-n,a+1,x), and are sometimes referred to as the associated Laguerre polynomials.\nThey are related to the plain Laguerre polynomials L_n(x) by L^0_n(x) = L_n(x) and L^k_n(x) = (-1)^k (d^k/dx^k) L_(n+k)(x). For more information see Abramowitz &amp; Stegun, Chapter 22.",null,null],[5,"laguerre_1","rgsl::laguerre","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"laguerre_2","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"laguerre_3","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"laguerre_1_e","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",null,null],[5,"laguerre_2_e","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",null,null],[5,"laguerre_3_e","","This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.",null,null],[5,"laguerre_n","","the generalized Laguerre polynomials L^a_n(x) for a &gt; -1, n &gt;= 0.",null,{"inputs":[{"name":"i32"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"laguerre_n_e","","the generalized Laguerre polynomials L^a_n(x) for a &gt; -1, n &gt;= 0.",null,null],[0,"lambert_w","rgsl","Lambert’s W functions, W(x), are defined to be solutions of the equation W(x) \\exp(W(x)) = x. This function has multiple branches for x &lt; 0; however, it has only two real-valued branches.\nWe define W_0(x) to be the principal branch, where W &gt; -1 for x &lt; 0, and W_{-1}(x) to be the other real branch, where W &lt; -1 for x &lt; 0.",null,null],[5,"lambert_W0","rgsl::lambert_w","This computes the principal branch of the Lambert W function, W_0(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"lambert_W0_e","","This computes the principal branch of the Lambert W function, W_0(x).",null,null],[5,"lambert_Wm1","","This computes the secondary real-valued branch of the Lambert W function, W_{-1}(x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"lambert_Wm1_e","","This computes the secondary real-valued branch of the Lambert W function, W_{-1}(x).",null,null],[0,"legendre","rgsl","The Legendre Functions and Legendre Polynomials are described in Abramowitz &amp; Stegun, Chapter 8.",null,null],[0,"polynomials","rgsl::legendre","",null,null],[5,"legendre_P1","rgsl::legendre::polynomials","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_P2","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_P3","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_P1_e","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",null,null],[5,"legendre_P2_e","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",null,null],[5,"legendre_P3_e","","This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.",null,null],[5,"legendre_Pl","","This function evaluates the Legendre polynomial P_l(x) for a specific value of l, x subject to l &gt;= 0, |x| &lt;= 1",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_Pl_e","","This function evaluates the Legendre polynomial P_l(x) for a specific value of l, x subject to l &gt;= 0, |x| &lt;= 1",null,null],[5,"legendre_Pl_array","","This function computes arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \\dots, lmax, |x| &lt;= 1",null,null],[5,"legendre_Pl_deriv_array","","This function computes arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \\dots, lmax, |x| &lt;= 1",null,null],[5,"legendre_Q0","","This function computes the Legendre function Q_0(x) for x &gt; -1, x != 1",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_Q0_e","","This function computes the Legendre function Q_0(x) for x &gt; -1, x != 1",null,null],[5,"legendre_Q1","","This function computes the Legendre function Q_0(x) for x &gt; -1, x != 1.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_Q1_e","","This function computes the Legendre function Q_0(x) for x &gt; -1, x != 1.",null,null],[5,"legendre_Ql","","This function computes the Legendre function Q_l(x) for x &gt; -1, x != 1 and l &gt;= 0.",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_Ql_e","","This function computes the Legendre function Q_l(x) for x &gt; -1, x != 1 and l &gt;= 0.",null,null],[0,"associated_polynomials","rgsl::legendre","The following functions compute the associated Legendre Polynomials P_l^m(x).\nNote that this function grows combinatorially with l and can overflow for l larger than about 150.\nThere is no trouble for small m, but overflow occurs when m and l are both large.\nRather than allow overflows, these functions refuse to calculate P_l^m(x) and return [`OvrFlw`](enums/type.Value.html) when they can sense that l and m are too big.",null,null],[5,"legendre_Plm","rgsl::legendre::associated_polynomials","This routine computes the associated Legendre polynomial P_l^m(x) for m &gt;= 0, l &gt;= m, |x| &lt;= 1.",null,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_Plm_e","","This routine computes the associated Legendre polynomial P_l^m(x) for m &gt;= 0, l &gt;= m, |x| &lt;= 1.",null,null],[5,"legendre_Plm_array","","This function computes arrays of Legendre polynomials P_l^m(x) and derivatives dP_l^m(x)/dx, for m &gt;= 0, l = |m|, ..., lmax, |x| &lt;= 1.",null,null],[5,"legendre_Plm_deriv_array","","This function computes arrays of Legendre polynomials P_l^m(x) and derivatives dP_l^m(x)/dx, for m &gt;= 0, l = |m|, ..., lmax, |x| &lt;= 1.",null,null],[5,"legendre_sphPlm","","This routine computes the normalized associated Legendre polynomial \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x) suitable for use in spherical harmonics.\nThe parameters must satisfy m &gt;= 0, l &gt;= m, |x| &lt;= 1.\nThis routine avoids the overflows that occur for the standard normalization of P_l^m(x).",null,{"inputs":[{"name":"i32"},{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_sphPlm_e","","This routine computes the normalized associated Legendre polynomial \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x) suitable for use in spherical harmonics.\nThe parameters must satisfy m &gt;= 0, l &gt;= m, |x| &lt;= 1.\nThis routine avoids the overflows that occur for the standard normalization of P_l^m(x).",null,null],[5,"legendre_sphPlm_array","","This function computes arrays of normalized associated Legendre functions \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x), and derivatives, for m &gt;= 0, l = |m|, ..., lmax, |x| &lt;= 1.0",null,null],[5,"legendre_sphPlm_deriv_array","","This function computes arrays of normalized associated Legendre functions \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x), and derivatives, for m &gt;= 0, l = |m|, ..., lmax, |x| &lt;= 1.0",null,null],[5,"legendre_array_size","","This function returns the size of result_array[] needed for the array versions of P_l^m(x), lmax - m + 1.",null,{"inputs":[{"name":"i32"},{"name":"i32"}],"output":{"name":"value"}}],[0,"conical","rgsl::legendre","The Conical Functions P^\\mu_{-(1/2)+i\\lambda}(x) and Q^\\mu_{-(1/2)+i\\lambda} are described in Abramowitz &amp; Stegun, Section 8.12.",null,null],[5,"half","rgsl::legendre::conical","This routine computes the irregular Spherical Conical Function P^{1/2}_{-1/2 + i \\lambda}(x) for x &gt; -1.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"half_e","","This routine computes the irregular Spherical Conical Function P^{1/2}_{-1/2 + i \\lambda}(x) for x &gt; -1.",null,null],[5,"mhalf","","This routine computes the regular Spherical Conical Function P^{-1/2}_{-1/2 + i \\lambda}(x) for x &gt; -1.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"mhalf_e","","This routine computes the regular Spherical Conical Function P^{-1/2}_{-1/2 + i \\lambda}(x) for x &gt; -1.",null,null],[5,"_0","","This routine computes the conical function P^0_{-1/2 + i \\lambda}(x) for x &gt; -1.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"_0_e","","This routine computes the conical function P^0_{-1/2 + i \\lambda}(x) for x &gt; -1.",null,null],[5,"_1","","This routine computes the conical function P^1_{-1/2 + i \\lambda}(x) for x &gt; -1.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"_1_e","","This routine computes the conical function P^1_{-1/2 + i \\lambda}(x) for x &gt; -1.",null,null],[5,"sph_reg","","This routine computes the Regular Spherical Conical Function P^{-1/2-l}_{-1/2 + i \\lambda}(x) for x &gt; -1, l &gt;= -1.",null,{"inputs":[{"name":"i32"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"sph_reg_e","","This routine computes the Regular Spherical Conical Function P^{-1/2-l}_{-1/2 + i \\lambda}(x) for x &gt; -1, l &gt;= -1.",null,null],[5,"cyl_reg","","This routine computes the Regular Cylindrical Conical Function P^{-m}_{-1/2 + i \\lambda}(x) for x &gt; -1, m &gt;= -1.",null,{"inputs":[{"name":"i32"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"cyl_reg_e","","This routine computes the Regular Cylindrical Conical Function P^{-m}_{-1/2 + i \\lambda}(x) for x &gt; -1, m &gt;= -1.",null,null],[0,"radial","rgsl::legendre","The following spherical functions are specializations of Legendre functions which give the regular eigenfunctions of the Laplacian on a 3-dimensional hyperbolic space H3d.\nOf particular interest is the flat limit, \\lambda \\to \\infty, \\eta \\to 0, \\lambda\\eta fixed.",null,null],[5,"legendre_H3d_0","rgsl::legendre::radial","This routine computes the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_0(\\lambda,\\eta) := \\sin(\\lambda\\eta)/(\\lambda\\sinh(\\eta)) for \\eta &gt;= 0.\nIn the flat limit this takes the form L^{H3d}_0(\\lambda,\\eta) = j_0(\\lambda\\eta).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_H3d_0_e","","This routine computes the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_0(\\lambda,\\eta) := \\sin(\\lambda\\eta)/(\\lambda\\sinh(\\eta)) for \\eta &gt;= 0.\nIn the flat limit this takes the form L^{H3d}_0(\\lambda,\\eta) = j_0(\\lambda\\eta).",null,null],[5,"legendre_H3d_1","","This routine computes the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_1(\\lambda,\\eta) := 1/\\sqrt{\\lambda^2 + 1} \\sin(\\lambda \\eta)/(\\lambda \\sinh(\\eta))\n(\\coth(\\eta) - \\lambda \\cot(\\lambda\\eta)) for \\eta &gt;= 0.\nIn the flat limit this takes the form L^{H3d}_1(\\lambda,\\eta) = j_1(\\lambda\\eta).",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_H3d_1_e","","This routine computes the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_1(\\lambda,\\eta) := 1/\\sqrt{\\lambda^2 + 1} \\sin(\\lambda \\eta)/(\\lambda \\sinh(\\eta))\n(\\coth(\\eta) - \\lambda \\cot(\\lambda\\eta)) for \\eta &gt;= 0.\nIn the flat limit this takes the form L^{H3d}_1(\\lambda,\\eta) = j_1(\\lambda\\eta).",null,null],[5,"legendre_H3d","","This routine computes the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space \\eta &gt;= 0, l &gt;= 0. In the flat limit this takes the form L^{H3d}_l(\\lambda,\\eta) = j_l(\\lambda\\eta).",null,{"inputs":[{"name":"i32"},{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"legendre_H3d_e","","This routine computes the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space \\eta &gt;= 0, l &gt;= 0. In the flat limit this takes the form L^{H3d}_l(\\lambda,\\eta) = j_l(\\lambda\\eta).",null,null],[5,"legendre_H3d_array","","This function computes an array of radial eigenfunctions L^{H3d}_l(\\lambda, \\eta) for 0 &lt;= l &lt;= lmax.",null,null],[0,"linear_algebra","rgsl","#Linear Algebra",null,null],[5,"LU_decomp","rgsl::linear_algebra","Factorise a general N x N matrix A into,",null,{"inputs":[{"name":"matrixf64"},{"name":"permutation"},{"name":"i32"}],"output":{"name":"value"}}],[5,"complex_LU_decomp","","Factorise a general N x N complex matrix A into,",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"permutation"},{"name":"i32"}],"output":{"name":"value"}}],[5,"LU_solve","","This function solves the square system A x = b using the LU decomposition of A into (LU, p) given by LU_decomp or LU_decomp as input.",null,{"inputs":[{"name":"matrixf64"},{"name":"permutation"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"complex_LU_solve","","This function solves the square system A x = b using the LU decomposition of A into (LU, p) given by LU_decomp or LU_decomp as input.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"permutation"},{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"LU_svx","","This function solves the square system A x = b in-place using the precomputed LU decomposition of A into (LU,p). On input x should contain\nthe right-hand side b, which is replaced by the solution on output.",null,{"inputs":[{"name":"matrixf64"},{"name":"permutation"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"complex_LU_svx","","This function solves the square system A x = b in-place using the precomputed LU decomposition of A into (LU,p). On input x should contain\nthe right-hand side b, which is replaced by the solution on output.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"permutation"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"LU_refine","","This function applies an iterative improvement to x, the solution of A x = b, from the precomputed LU decomposition of A into (LU,p). The\ninitial residual r = A x - b is also computed and stored in residual.",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"permutation"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"complex_LU_refine","","This function applies an iterative improvement to x, the solution of A x = b, from the precomputed LU decomposition of A into (LU,p). The\ninitial residual r = A x - b is also computed and stored in residual.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"matrixcomplexf64"},{"name":"permutation"},{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"LU_invert","","This function computes the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse\nis computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse\nwhenever possible, as the linear solver functions can obtain the same result more efficiently and reliably (consult any introductory\ntextbook on numerical linear algebra for details).",null,{"inputs":[{"name":"matrixf64"},{"name":"permutation"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"complex_LU_invert","","This function computes the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse\nis computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse\nwhenever possible, as the linear solver functions can obtain the same result more efficiently and reliably (consult any introductory\ntextbook on numerical linear algebra for details).",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"permutation"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"LU_det","","This function computes the determinant of a matrix A from its LU decomposition, LU. The determinant is computed as the product of the\ndiagonal elements of U and the sign of the row permutation signum.",null,{"inputs":[{"name":"matrixf64"},{"name":"i32"}],"output":{"name":"f64"}}],[5,"complex_LU_det","","This function computes the determinant of a matrix A from its LU decomposition, LU. The determinant is computed as the product of the\ndiagonal elements of U and the sign of the row permutation signum.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"i32"}],"output":{"name":"complexf64"}}],[5,"LU_lndet","","These functions compute the logarithm of the absolute value of the determinant of a matrix A, \\ln|\\det(A)|, from its LU decomposition,\nLU. This function may be useful if the direct computation of the determinant would overflow or underflow.",null,{"inputs":[{"name":"matrixf64"}],"output":{"name":"f64"}}],[5,"complex_LU_lndet","","These functions compute the logarithm of the absolute value of the determinant of a matrix A, \\ln|\\det(A)|, from its LU decomposition,\nLU. This function may be useful if the direct computation of the determinant would overflow or underflow.",null,{"inputs":[{"name":"matrixcomplexf64"}],"output":{"name":"f64"}}],[5,"LU_sgndet","","This function computes the sign or phase factor of the determinant of a matrix A, \\det(A)/|\\det(A)|, from its LU decomposition, LU.",null,{"inputs":[{"name":"matrixf64"},{"name":"i32"}],"output":{"name":"f64"}}],[5,"complex_LU_sgndet","","This function computes the sign or phase factor of the determinant of a matrix A, \\det(A)/|\\det(A)|, from its LU decomposition, LU.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"i32"}],"output":{"name":"complexf64"}}],[5,"QR_decomp","","This function factorizes the M-by-N matrix A into the QR decomposition A = Q R. On output the diagonal and upper triangular part of the\ninput matrix contain the matrix R. The vector tau and the columns of the lower triangular part of the matrix A contain the Householder\ncoefficients and Householder vectors which encode the orthogonal matrix Q. The vector tau must be of length k=\\min(M,N). The matrix Q\nis related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I - \\tau_i v_i v_i^T and v_i is the Householder vector v_i =\n(0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by LAPACK.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QR_solve","","This function solves the square system A x = b using the QR decomposition of A held in (QR, tau) which must have been computed previously\nwith gsl_linalg_QR_decomp. The least-squares solution for rectangular systems can be found using QR_lssolve.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QR_svx","","This function solves the square system A x = b in-place using the QR decomposition of A held in (QR,tau) which must have been computed\npreviously by gsl_linalg_QR_decomp. On input x should contain the right-hand side b, which is replaced by the solution on output.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QR_lssolve","","This function finds the least squares solution to the overdetermined system A x = b where the matrix A has more rows than columns. The\nleast squares solution minimizes the Euclidean norm of the residual, ||Ax - b||.The routine requires as input the QR decomposition of\nA into (QR, tau) given by gsl_linalg_QR_decomp. The solution is returned in x. The residual is computed as a by-product and stored in\nresidual.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QR_QTvec","","This function applies the matrix Q^T encoded in the decomposition (QR,tau) to the vector v, storing the result Q^T v in v. The matrix\nmultiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QR_Qvec","","This function applies the matrix Q encoded in the decomposition (QR,tau) to the vector v, storing the result Q v in v. The matrix\nmultiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QR_QTmat","","This function applies the matrix Q^T encoded in the decomposition (QR,tau) to the matrix A, storing the result Q^T A in A. The matrix\nmultiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"QR_Rsolve","","This function solves the triangular system R x = b for x. It may be useful if the product b&#39; = Q^T b has already been computed using\ngsl_linalg_QR_QTvec.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QR_Rsvx","","This function solves the triangular system R x = b for x in-place. On input x should contain the right-hand side b and is replaced by\nthe solution on output. This function may be useful if the product b&#39; = Q^T b has already been computed using gsl_linalg_QR_QTvec.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QR_unpack","","This function unpacks the encoded QR decomposition (QR,tau) into the matrices Q and R, where Q is M-by-M and R is M-by-N.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"matrixf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"QR_QRsolve","","This function solves the system R x = Q^T b for x. It can be used when the QR decomposition of a matrix is available in unpacked\nform as (Q, R).",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QR_update","","This function performs a rank-1 update w v^T of the QR decomposition (Q, R). The update is given by Q&#39;R&#39; = Q (R + w v^T) where the\noutput matrices Q&#39; and R&#39; are also orthogonal and right triangular. Note that w is destroyed by the update.",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"R_solve","","This function solves the triangular system R x = b for the N-by-N matrix R.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"R_svx","","This function solves the triangular system R x = b in-place. On input x should contain the right-hand side b, which is replaced by\nthe solution on output.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QRPT_decomp","","This function factorizes the M-by-N matrix A into the QRP^T decomposition A = Q R P^T. On output the diagonal and upper triangular part\nof the input matrix contain the matrix R. The permutation matrix P is stored in the permutation p. The sign of the permutation is given\nby signum. It has the value (-1)^n, where n is the number of interchanges in the permutation. The vector tau and the columns of the lower\ntriangular part of the matrix A contain the Householder coefficients and vectors which encode the orthogonal matrix Q. The vector tau must\nbe of length k=\\min(M,N). The matrix Q is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I - \\tau_i v_i v_i^T and v_i is\nthe Householder vector v_i = (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by LAPACK. The vector norm is\na workspace of length N used for column pivoting.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"permutation"},{"name":"i32"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QRPT_decomp2","","This function factorizes the matrix A into the decomposition A = Q R P^T without modifying A itself and storing the output in the separate\nmatrices q and r.",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"permutation"},{"name":"i32"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QRPT_solve","","This function solves the square system A x = b using the QRP^T decomposition of A held in (QR, tau, p) which must have been computed previously\nby QRPT_decomp.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"permutation"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QRPT_svx","","This function solves the square system A x = b in-place using the QRP^T decomposition of A held in (QR,tau,p). On input x should contain the\nright-hand side b, which is replaced by the solution on output.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"permutation"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QRPT_QRsolve","","This function solves the square system R P^T x = Q^T b for x. It can be used when the QR decomposition of a matrix is available in unpacked\nform as (Q, R).",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"permutation"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QRPT_update","","This function performs a rank-1 update w v^T of the QRP^T decomposition (Q, R, p). The update is given by Q&#39;R&#39; = Q (R + w v^T P) where the\noutput matrices Q&#39; and R&#39; are also orthogonal and right triangular. Note that w is destroyed by the update. The permutation p is not changed.",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"permutation"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QRPT_Rsolve","","This function solves the triangular system R P^T x = b for the N-by-N matrix R contained in QR.",null,{"inputs":[{"name":"matrixf64"},{"name":"permutation"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"QRPT_Rsvx","","This function solves the triangular system R P^T x = b in-place for the N-by-N matrix R contained in QR. On input x should contain the\nright-hand side b, which is replaced by the solution on output.",null,{"inputs":[{"name":"matrixf64"},{"name":"permutation"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"SV_decomp","","This function factorizes the M-by-N matrix A into the singular value decomposition A = U S V^T for M &gt;= N. On output the matrix A is replaced\nby U. The diagonal elements of the singular value matrix S are stored in the vector S. The singular values are non-negative and form a\nnon-increasing sequence from S_1 to S_N. The matrix V contains the elements of V in untransposed form. To form the product U S V^T it is\nnecessary to take the transpose of V. A workspace of length N is required in work.",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"SV_decomp_mod","","This function computes the SVD using the modified Golub-Reinsch algorithm, which is faster for M&gt;&gt;N. It requires the vector work of length\nN and the N-by-N matrix X as additional working space.",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"SV_decomp_jacobi","","This function computes the SVD of the M-by-N matrix A using one-sided Jacobi orthogonalization for M &gt;= N. The Jacobi method can compute\nsingular values to higher relative accuracy than Golub-Reinsch algorithms (see references for details).",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"SV_solve","","This function solves the system A x = b using the singular value decomposition (U, S, V) of A which must have been computed previously\nwith gsl_linalg_SV_decomp.",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"SV_leverage","","This function computes the statistical leverage values h_i of a matrix A using its singular value decomposition (U, S, V) previously computed\nwith gsl_linalg_SV_decomp. h_i are the diagonal values of the matrix A (A^T A)^{-1} A^T and depend only on the matrix U which is the input to\nthis function.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"cholesky_decomp","","This function factorizes the symmetric, positive-definite square matrix A into the Cholesky decomposition A = L L^T (or A = L L^H for\nthe complex case). On input, the values from the diagonal and lower-triangular part of the matrix A are used (the upper triangular part\nis ignored). On output the diagonal and lower triangular part of the input matrix A contain the matrix L, while the upper triangular part\nof the input matrix is overwritten with L^T (the diagonal terms being identical for both L and L^T). If the matrix is not positive-definite\nthen the decomposition will fail, returning the error code ::Dom.",null,{"inputs":[{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"complex_cholesky_decomp","","This function factorizes the symmetric, positive-definite square matrix A into the Cholesky decomposition A = L L^T (or A = L L^H for\nthe complex case). On input, the values from the diagonal and lower-triangular part of the matrix A are used (the upper triangular part\nis ignored). On output the diagonal and lower triangular part of the input matrix A contain the matrix L, while the upper triangular part\nof the input matrix is overwritten with L^T (the diagonal terms being identical for both L and L^T). If the matrix is not positive-definite\nthen the decomposition will fail, returning the error code ::Dom.",null,{"inputs":[{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"cholesky_solve","","This function solves the system A x = b using the Cholesky decomposition of A held in the matrix cholesky which must have been previously\ncomputed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"complex_cholesky_solve","","This function solves the system A x = b using the Cholesky decomposition of A held in the matrix cholesky which must have been previously\ncomputed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"vectorcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"cholesky_svx","","This function solves the system A x = b in-place using the Cholesky decomposition of A held in the matrix cholesky which must have been\npreviously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On input x should contain the right-hand side\nb, which is replaced by the solution on output.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"complex_cholesky_svx","","This function solves the system A x = b in-place using the Cholesky decomposition of A held in the matrix cholesky which must have been\npreviously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On input x should contain the right-hand side\nb, which is replaced by the solution on output.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"cholesky_invert","","This function computes the inverse of a matrix from its Cholesky decomposition cholesky, which must have been previously computed by\ngsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On output, the inverse is stored in-place in cholesky.",null,{"inputs":[{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"complex_cholesky_invert","","This function computes the inverse of a matrix from its Cholesky decomposition cholesky, which must have been previously computed by\ngsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On output, the inverse is stored in-place in cholesky.",null,{"inputs":[{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"symmtd_decomp","","This function factorizes the symmetric square matrix A into the symmetric tridiagonal decomposition Q T Q^T. On output the diagonal and\nsubdiagonal part of the input matrix A contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains\nthe Householder vectors which, together with the Householder coefficients tau, encode the orthogonal matrix Q. This storage scheme is\nthe same as used by LAPACK. The upper triangular part of A is not referenced.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"symmtd_unpack","","This function unpacks the encoded symmetric tridiagonal decomposition (A, tau) obtained from gsl_linalg_symmtd_decomp into the orthogonal\nmatrix Q, the vector of diagonal elements diag and the vector of subdiagonal elements subdiag.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"symmtd_unpack_T","","This function unpacks the diagonal and subdiagonal of the encoded symmetric tridiagonal decomposition (A, tau) obtained from\ngsl_linalg_symmtd_decomp into the vectors diag and subdiag.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"hermtd_decomp","","This function factorizes the hermitian matrix A into the symmetric tridiagonal decomposition U T U^T. On output the real parts of the\ndiagonal and subdiagonal part of the input matrix A contain the tridiagonal matrix T. The remaining lower triangular part of the input\nmatrix contains the Householder vectors which, together with the Householder coefficients tau, encode the unitary matrix U. This storage\nscheme is the same as used by LAPACK. The upper triangular part of A and imaginary parts of the diagonal are not referenced.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"vectorcomplexf64"}],"output":{"name":"value"}}],[5,"hermtd_unpack","","This function unpacks the encoded tridiagonal decomposition (A, tau) obtained from gsl_linalg_hermtd_decomp into the unitary matrix U,\nthe real vector of diagonal elements diag and the real vector of subdiagonal elements subdiag.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"vectorcomplexf64"},{"name":"matrixcomplexf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"hermtd_unpack_T","","This function unpacks the diagonal and subdiagonal of the encoded tridiagonal decomposition (A, tau) obtained from the\ngsl_linalg_hermtd_decomp into the real vectors diag and subdiag.",null,{"inputs":[{"name":"matrixcomplexf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"hessenberg_decomp","","This function computes the Hessenberg decomposition of the matrix A by applying the similarity transformation H = U^T A U. On output, H\nis stored in the upper portion of A. The information required to construct the matrix U is stored in the lower triangular portion of A.\nU is a product of N - 2 Householder matrices. The Householder vectors are stored in the lower portion of A (below the subdiagonal) and\nthe Householder coefficients are stored in the vector tau. tau must be of length N.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"hessenberg_unpack","","This function constructs the orthogonal matrix U from the information stored in the Hessenberg matrix H along with the vector tau. H and\ntau are outputs from gsl_linalg_hessenberg_decomp.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"hessenberg_unpack_accum","","This function is similar to gsl_linalg_hessenberg_unpack, except it accumulates the matrix U into V, so that V&#39; = VU. The matrix V must\nbe initialized prior to calling this function. Setting V to the identity matrix provides the same result as gsl_linalg_hessenberg_unpack.\nIf H is order N, then V must have N columns but may have any number of rows.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"hessenberg_set_zero","","This function sets the lower triangular portion of H, below the subdiagonal, to zero. It is useful for clearing out the Householder\nvectors after calling gsl_linalg_hessenberg_decomp.",null,{"inputs":[{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"hesstri_decomp","","This function computes the Hessenberg-Triangular decomposition of the matrix pair (A, B). On output, H is stored in A, and R is stored\nin B. If U and V are provided (they may be null), the similarity transformations are stored in them. Additional workspace of length N\nis needed in work.",null,{"inputs":[{"name":"matrixf64"},{"name":"matrixf64"},{"name":"matrixf64"},{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"bidiag_decomp","","This function factorizes the M-by-N matrix A into bidiagonal form U B V^T. The diagonal and superdiagonal of the matrix B are stored in\nthe diagonal and superdiagonal of A. The orthogonal matrices U and V are stored as compressed Householder vectors in the remaining elements\nof A. The Householder coefficients are stored in the vectors tau_U and tau_V. The length of tau_U must equal the number of elements in\nthe diagonal of A and the length of tau_V should be one element shorter.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"bidiag_unpack","","This function unpacks the bidiagonal decomposition of A produced by gsl_linalg_bidiag_decomp, (A, tau_U, tau_V) into the separate orthogonal\nmatrices U, V and the diagonal vector diag and superdiagonal superdiag. Note that U is stored as a compact M-by-N orthogonal matrix satisfying\nU^T U = I for efficiency.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"bidiag_unpack2","","This function unpacks the bidiagonal decomposition of A produced by gsl_linalg_bidiag_decomp, (A, tau_U, tau_V) into the separate orthogonal\nmatrices U, V and the diagonal vector diag and superdiagonal superdiag. The matrix U is stored in-place in A.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"bidiag_unpack_B","","This function unpacks the diagonal and superdiagonal of the bidiagonal decomposition of A from gsl_linalg_bidiag_decomp, into the diagonal\nvector diag and superdiagonal vector superdiag.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"householder_transform","","This function prepares a Householder transformation P = I - \\tau v v^T which can be used to zero all the elements of the input vector except\nthe first. On output the transformation is stored in the vector v and the scalar \\tau is returned.",null,{"inputs":[{"name":"vectorf64"}],"output":{"name":"f64"}}],[5,"complex_householder_transform","","This function prepares a Householder transformation P = I - \\tau v v^T which can be used to zero all the elements of the input vector except\nthe first. On output the transformation is stored in the vector v and the scalar \\tau is returned.",null,{"inputs":[{"name":"vectorcomplexf64"}],"output":{"name":"complexf64"}}],[5,"householder_hm","","This function applies the Householder matrix P defined by the scalar tau and the vector v to the left-hand side of the matrix A. On output\nthe result P A is stored in A.",null,{"inputs":[{"name":"f64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"complex_householder_hm","","This function applies the Householder matrix P defined by the scalar tau and the vector v to the left-hand side of the matrix A. On output\nthe result P A is stored in A.",null,{"inputs":[{"name":"complexf64"},{"name":"vectorcomplexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"householder_mh","","This function applies the Householder matrix P defined by the scalar tau and the vector v to the right-hand side of the matrix A. On output\nthe result A P is stored in A.",null,{"inputs":[{"name":"f64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"complex_householder_mh","","This function applies the Householder matrix P defined by the scalar tau and the vector v to the right-hand side of the matrix A. On output\nthe result A P is stored in A.",null,{"inputs":[{"name":"complexf64"},{"name":"vectorcomplexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"householder_hv","","This function applies the Householder transformation P defined by the scalar tau and the vector v to the vector w. On output the result P\nw is stored in w.",null,{"inputs":[{"name":"f64"},{"name":"vectorf64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"complex_householder_hv","","This function applies the Householder transformation P defined by the scalar tau and the vector v to the vector w. On output the result P\nw is stored in w.",null,{"inputs":[{"name":"complexf64"},{"name":"vectorcomplexf64"},{"name":"matrixcomplexf64"}],"output":{"name":"value"}}],[5,"HH_solve","","This function solves the system A x = b directly using Householder transformations. On output the solution is stored in x and b is not\nmodified. The matrix A is destroyed by the Householder transformations.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"HH_svx","","This function solves the system A x = b in-place using Householder transformations. On input x should contain the right-hand side b,\nwhich is replaced by the solution on output. The matrix A is destroyed by the Householder transformations.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"solve_tridiag","","This function solves the general N-by-N system A x = b where A is tridiagonal (N &gt;= 2). The super-diagonal and sub-diagonal vectors\ne and f must be one element shorter than the diagonal vector diag. The form of A for the 4-by-4 case is shown below,",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"solve_symm_tridiag","","This function solves the general N-by-N system A x = b where A is symmetric tridiagonal (N &gt;= 2). The off-diagonal vector e must be one\nelement shorter than the diagonal vector diag. The form of A for the 4-by-4 case is shown below,",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"solve_cyc_tridiag","","This function solves the general N-by-N system A x = b where A is cyclic tridiagonal (N &gt;= 3). The cyclic super-diagonal and sub-diagonal\nvectors e and f must have the same number of elements as the diagonal vector diag. The form of A for the 4-by-4 case is shown below,",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"solve_symm_cyc_tridiag","","This function solves the general N-by-N system A x = b where A is symmetric cyclic tridiagonal (N &gt;= 3). The cyclic off-diagonal vector\ne must have the same number of elements as the diagonal vector diag. The form of A for the 4-by-4 case is shown below,",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[5,"balance_matrix","","This function replaces the matrix A with its balanced counterpart and stores the diagonal elements of the similarity transformation into\nthe vector D.",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[0,"logarithm","rgsl","Information on the properties of the Logarithm function can be found in Abramowitz &amp; Stegun, Chapter 4.",null,null],[5,"log","rgsl::logarithm","This routine computes the logarithm of x, \\log(x), for x &gt; 0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"log_e","","This routine computes the logarithm of x, \\log(x), for x &gt; 0.",null,null],[5,"log_abs","","This routine computes the logarithm of the magnitude of x, \\log(|x|), for x \\ne 0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"log_abs_e","","This routine computes the logarithm of the magnitude of x, \\log(|x|), for x \\ne 0.",null,null],[5,"complex_log_e","","This routine computes the complex logarithm of z = z_r + i z_i.\nThe results are returned as lnr, theta such that \\exp(lnr + i \\theta) = z_r + i z_i, where \\theta lies in the range [-\\pi,\\pi].",null,null],[5,"log_1plusx","","This routine computes \\log(1 + x) for x &gt; -1 using an algorithm that is accurate for small x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"log_1plusx_e","","This routine computes \\log(1 + x) for x &gt; -1 using an algorithm that is accurate for small x.",null,null],[5,"log_1plusx_mx","","This routine computes \\log(1 + x) - x for x &gt; -1 using an algorithm that is accurate for small x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"log_1plusx_mx_e","","This routine computes \\log(1 + x) - x for x &gt; -1 using an algorithm that is accurate for small x.",null,null],[0,"minimizer","rgsl","",null,null],[5,"test_interval","rgsl::minimizer","This function tests for the convergence of the interval [x_lower, x_upper] with absolute error epsabs and relative error epsrel. The\ntest returns ::Value::Success if the following condition is achieved,",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[0,"multifit","rgsl","",null,null],[5,"covar","rgsl::multifit","Compute the covariance matrix cov = inv (J^T J) by QRP^T decomposition of J",null,{"inputs":[{"name":"matrixf64"},{"name":"f64"},{"name":"matrixf64"}],"output":{"name":"value"}}],[5,"test_delta","","",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[5,"gradient","","",null,{"inputs":[{"name":"matrixf64"},{"name":"vectorf64"},{"name":"vectorf64"}],"output":{"name":"value"}}],[0,"numerical_differentiation","rgsl","#Numerical Differentiation",null,null],[5,"deriv_central","rgsl::numerical_differentiation","This function computes the numerical derivative of the function f at the point x using an adaptive central difference algorithm with a step-size\nof h. The derivative is returned in result and an estimate of its absolute error is returned in abserr.",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[5,"deriv_forward","","This function computes the numerical derivative of the function f at the point x using an adaptive forward difference algorithm with a step-size\nof h. The function is evaluated only at points greater than x, and never at x itself. The derivative is returned in result and an estimate\nof its absolute error is returned in abserr. This function should be used if f(x) has a discontinuity at x, or is undefined for values less\nthan x.",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[5,"deriv_backward","","This function computes the numerical derivative of the function f at the point x using an adaptive backward difference algorithm with a\nstep-size of h. The function is evaluated only at points less than x, and never at x itself. The derivative is returned in result and an\nestimate of its absolute error is returned in abserr. This function should be used if f(x) has a discontinuity at x, or is undefined for\nvalues greater than x.",null,{"inputs":[{"name":"function"},{"name":"t"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"value"}}],[0,"physical_constant","rgsl","Physical Constants",null,null],[7,"MKSA_SPEED_OF_LIGHT","rgsl::physical_constant","The speed of light in vacuum, c. m / s",null,null],[7,"MKSA_VACUUM_PERMEABILITY","","The permeability of free space, \\mu_0. This constant is defined in the MKSA system only. kg m / A^2 s^2",null,null],[7,"MKSA_VACUUM_PERMITTIVITY","","The permittivity of free space, \\epsilon_0. This constant is defined in the MKSA system only. A^2 s^4 / kg m^3",null,null],[7,"MKSA_PLANCKS_CONSTANT_H","","Planck’s constant, h. kg m^2 / s",null,null],[7,"MKSA_PLANCKS_CONSTANT_HBAR","","Planck’s constant divided by 2\\pi, \\hbar. kg m^2 / s",null,null],[7,"NUM_AVOGADRO","","Avogadro’s number, N_a. 1 / mol",null,null],[7,"MKSA_FARADAY","","The molar charge of 1 Faraday. A s / mol",null,null],[7,"MKSA_BOLTZMANN","","The Boltzmann constant, k. kg m^2 / K s^2",null,null],[7,"MKSA_MOLAR_GAS","","The molar gas constant, R_0. kg m^2 / K mol s^2",null,null],[7,"MKSA_STANDARD_GAS_VOLUME","","The standard gas volume, V_0. m^3 / mol",null,null],[7,"MKSA_STEFAN_BOLTZMANN_CONSTANT","","The Stefan-Boltzmann radiation constant, \\sigma. kg / K^4 s^3",null,null],[7,"MKSA_GAUSS","","The magnetic field of 1 Gauss. kg / A s^2",null,null],[7,"MKSA_ASTRONOMICAL_UNIT","","The length of 1 astronomical unit (mean earth-sun distance), au. m",null,null],[7,"MKSA_GRAVITATIONAL_CONSTANT","","The gravitational constant, G. m^3 / kg s^2",null,null],[7,"MKSA_LIGHT_YEAR","","The distance of 1 light-year, ly. m",null,null],[7,"MKSA_PARSEC","","The distance of 1 parsec, pc. m",null,null],[7,"MKSA_GRAV_ACCEL","","The standard gravitational acceleration on Earth, g. m / s^2",null,null],[7,"MKSA_SOLAR_MASS","","The mass of the Sun. kg",null,null],[7,"MKSA_ELECTRON_CHARGE","","The charge of the electron, e. A s",null,null],[7,"MKSA_ELECTRON_VOLT","","The energy of 1 electron volt, eV. kg m^2 / s^2",null,null],[7,"MKSA_UNIFIED_ATOMIC_MASS","","The unified atomic mass, amu. kg",null,null],[7,"MKSA_MASS_ELECTRON","","The mass of the electron, m_e. kg",null,null],[7,"MKSA_MASS_MUON","","The mass of the muon, m_\\mu. kg",null,null],[7,"MKSA_MASS_PROTON","","The mass of the proton, m_p. kg",null,null],[7,"MKSA_MASS_NEUTRON","","The mass of the neutron, m_n. kg",null,null],[7,"NUM_FINE_STRUCTURE","","The electromagnetic fine structure constant \\alpha. 1",null,null],[7,"MKSA_RYDBERG","","The Rydberg constant, Ry, in units of energy. This is related to the Rydberg inverse wavelength R_\\infty by Ry = h c R_\\infty. kg m^2 / s^2",null,null],[7,"MKSA_BOHR_RADIUS","","The Bohr radius, a_0. m",null,null],[7,"MKSA_ANGSTROM","","The length of 1 angstrom. m",null,null],[7,"MKSA_BARN","","The area of 1 barn. m^2",null,null],[7,"MKSA_BOHR_MAGNETON","","The Bohr Magneton, \\mu_B. A m^2",null,null],[7,"MKSA_NUCLEAR_MAGNETON","","The Nuclear Magneton, \\mu_N. A m^2",null,null],[7,"MKSA_ELECTRON_MAGNETIC_MOMENT","","The absolute value of the magnetic moment of the electron, \\mu_e. The physical magnetic moment of the electron is negative. A m^2",null,null],[7,"MKSA_PROTON_MAGNETIC_MOMENT","","The magnetic moment of the proton, \\mu_p. A m^2",null,null],[7,"MKSA_THOMSON_CROSS_SECTION","","The Thomson cross section, \\sigma_T. m^2",null,null],[7,"MKSA_DEBYE","","The electric dipole moment of 1 Debye, D. A s^2 / m^2",null,null],[7,"MKSA_MINUTE","","The number of seconds in 1 minute. s",null,null],[7,"MKSA_HOUR","","The number of seconds in 1 hour. s",null,null],[7,"MKSA_DAY","","The number of seconds in 1 day. s",null,null],[7,"MKSA_WEEK","","The number of seconds in 1 week. s",null,null],[7,"MKSA_INCH","","The length of 1 inch. m",null,null],[7,"MKSA_FOOT","","The length of 1 foot. m",null,null],[7,"MKSA_YARD","","The length of 1 yard. m",null,null],[7,"MKSA_MILE","","The length of 1 mile. m",null,null],[7,"MKSA_MIL","","The length of 1 mil (1/1000th of an inch). m",null,null],[7,"MKSA_KILOMETERS_PER_HOUR","","The speed of 1 kilometer per hour. m / s",null,null],[7,"MKSA_MILES_PER_HOUR","","The speed of 1 mile per hour. m / s",null,null],[7,"MKSA_NAUTICAL_MILE","","The length of 1 nautical mile. m",null,null],[7,"MKSA_FATHOM","","The length of 1 fathom. m",null,null],[7,"MKSA_KNOT","","The speed of 1 knot. m / s",null,null],[7,"MKSA_POINT","","The length of 1 printer’s point (1/72 inch). m",null,null],[7,"MKSA_TEXPOINT","","The length of 1 TeX point (1/72.27 inch). m",null,null],[7,"MKSA_MICRON","","The length of 1 micron. m",null,null],[7,"MKSA_HECTARE","","The area of 1 hectare. m^2",null,null],[7,"MKSA_ACRE","","The area of 1 acre. m^2",null,null],[7,"MKSA_LITER","","The volume of 1 liter. m^3",null,null],[7,"MKSA_US_GALLON","","The volume of 1 US gallon. m^3",null,null],[7,"MKSA_CANADIAN_GALLON","","The volume of 1 Canadian gallon. m^3",null,null],[7,"MKSA_UK_GALLON","","The volume of 1 UK gallon. m^3",null,null],[7,"MKSA_QUART","","The volume of 1 quart. m^3",null,null],[7,"MKSA_PINT","","The volume of 1 pint. m^3",null,null],[7,"MKSA_CUP","","m^3",null,null],[7,"MKSA_POUND_MASS","","The mass of 1 pound. kg",null,null],[7,"MKSA_OUNCE_MASS","","The mass of 1 ounce. kg",null,null],[7,"MKSA_TON","","The mass of 1 ton. kg",null,null],[7,"MKSA_METRIC_TON","","The mass of 1 metric ton (1000 kg). kg",null,null],[7,"MKSA_UK_TON","","The mass of 1 UK ton. kg",null,null],[7,"MKSA_TROY_OUNCE","","The mass of 1 troy ounce. kg",null,null],[7,"MKSA_CARAT","","The mass of 1 carat. kg",null,null],[7,"MKSA_GRAM_FORCE","","The force of 1 gram weight. kg m / s^2",null,null],[7,"MKSA_POUND_FORCE","","The force of 1 pound weight. kg m / s^2",null,null],[7,"MKSA_KILOPOUND_FORCE","","The force of 1 kilopound weight. kg m / s^2",null,null],[7,"MKSA_POUNDAL","","The force of 1 poundal. kg m / s^2",null,null],[7,"MKSA_CALORIE","","The energy of 1 calorie. kg m^2 / s^2",null,null],[7,"MKSA_BTU","","The energy of 1 British Thermal Unit, btu. kg m^2 / s^2",null,null],[7,"MKSA_THERM","","The energy of 1 Therm. kg m^2 / s^2",null,null],[7,"MKSA_HORSEPOWER","","The power of 1 horsepower. kg m^2 / s^3",null,null],[7,"MKSA_BAR","","The pressure of 1 bar. kg / m s^2",null,null],[7,"MKSA_STD_ATMOSPHERE","","The pressure of 1 standard atmosphere. kg / m s^2",null,null],[7,"MKSA_TORR","","The pressure of 1 torr. kg / m s^2",null,null],[7,"MKSA_METER_OF_MERCURY","","The pressure of 1 meter of mercury. kg / m s^2",null,null],[7,"MKSA_INCH_OF_MERCURY","","The pressure of 1 inch of mercury. kg / m s^2",null,null],[7,"MKSA_INCH_OF_WATER","","The pressure of 1 inch of water. kg / m s^2",null,null],[7,"MKSA_PSI","","The pressure of 1 pound per square inch. kg / m s^2",null,null],[7,"MKSA_POISE","","The dynamic viscosity of 1 poise. kg m^-1 s^-1",null,null],[7,"MKSA_STOKES","","The kinematic viscosity of 1 stokes. m^2 / s",null,null],[7,"MKSA_STILB","","The luminance of 1 stilb. cd / m^2",null,null],[7,"MKSA_LUMEN","","The luminous flux of 1 lumen. cd sr",null,null],[7,"MKSA_LUX","","The illuminance of 1 lux. cd sr / m^2",null,null],[7,"MKSA_PHOT","","The illuminance of 1 phot. cd sr / m^2",null,null],[7,"MKSA_FOOTCANDLE","","The illuminance of 1 footcandle. cd sr / m^2",null,null],[7,"MKSA_LAMBERT","","The luminance of 1 lambert. cd sr / m^2",null,null],[7,"MKSA_FOOTLAMBERT","","The luminance of 1 footlambert. cd sr / m^2",null,null],[7,"MKSA_CURIE","","The activity of 1 curie. 1 / s",null,null],[7,"MKSA_ROENTGEN","","The exposure of 1 roentgen. A s / kg",null,null],[7,"MKSA_RAD","","The absorbed dose of 1 rad. m^2 / s^2",null,null],[7,"MKSA_NEWTON","","The SI unit of force, 1 Newton. kg m / s^2",null,null],[7,"MKSA_DYNE","","The force of 1 Dyne = 10^-5 Newton. kg m / s^2",null,null],[7,"MKSA_JOULE","","The SI unit of energy, 1 Joule. kg m^2 / s^2",null,null],[7,"MKSA_ERG","","The energy 1 erg = 10^-7 Joule. kg m^2 / s^2",null,null],[7,"NUM_YOTTA","","10^24",null,null],[7,"NUM_ZETTA","","10^21",null,null],[7,"NUM_EXA","","10^18",null,null],[7,"NUM_PETA","","10^15",null,null],[7,"NUM_TERA","","10^12",null,null],[7,"NUM_GIGA","","10^9",null,null],[7,"NUM_MEGA","","10^6",null,null],[7,"NUM_KILO","","10^3",null,null],[7,"NUM_MILLI","","10^-3",null,null],[7,"NUM_MICRO","","10^-6",null,null],[7,"NUM_NANO","","10^-9",null,null],[7,"NUM_PICO","","10^-12",null,null],[7,"NUM_FEMTO","","10^-15",null,null],[7,"NUM_ATTO","","10^-18",null,null],[7,"NUM_ZEPTO","","10^-21",null,null],[7,"NUM_YOCTO","","10^-24",null,null],[0,"polynomials","rgsl","#Polynomials",null,null],[0,"evaluation","rgsl::polynomials","The functions described here evaluate the polynomial P(x) = c[0] + c[1] x + c[2] x^2 + \\dots + c[len-1] x^{len-1} using Horner’s method\nfor stability.",null,null],[5,"poly_eval","rgsl::polynomials::evaluation","This function evaluates a polynomial with real coefficients for the real variable x.",null,null],[5,"poly_complex_eval","","This function evaluates a polynomial with real coefficients for the complex variable z.",null,null],[5,"complex_poly_complex_eval","","This function evaluates a polynomial with complex coefficients for the complex variable z.",null,null],[5,"poly_eval_derivs","","This function evaluates a polynomial and its derivatives storing the results in the array res of size lenres. The output array contains\nthe values of d^k P/d x^k for the specified value of x starting with k = 0.",null,null],[0,"divided_difference_representation","rgsl::polynomials","The functions described here manipulate polynomials stored in Newton’s divided-difference representation. The use of divided-differences\nis described in Abramowitz &amp; Stegun sections 25.1.4 and 25.2.26, and Burden and Faires, chapter 3, and discussed briefly below.",null,null],[5,"poly_dd_init","rgsl::polynomials::divided_difference_representation","This function computes a divided-difference representation of the interpolating polynomial for the points (x, y) stored in the arrays\nxa and ya of length size. On output the divided-differences of (xa,ya) are stored in the array dd, also of length size. Using the\nnotation above, dd[k] = [x_0,x_1,...,x_k].",null,null],[5,"poly_dd_eval","","This function evaluates the polynomial stored in divided-difference form in the arrays dd and xa of length size at the point x.",null,null],[5,"poly_dd_taylor","","This function converts the divided-difference representation of a polynomial to a Taylor expansion. The divided-difference representation\nis supplied in the arrays dd and xa of length size. On output the Taylor coefficients of the polynomial expanded about the point xp are\nstored in the array c also of length size. A workspace of length size must be provided in the array w.",null,null],[5,"poly_dd_hermite_init","","This function computes a divided-difference representation of the interpolating Hermite polynomial for the points (x, y) stored in the\narrays xa and ya of length size. Hermite interpolation constructs polynomials which also match first derivatives dy/dx which are provided\nin the array dya also of length size. The first derivatives can be incorported into the usual divided-difference algorithm by forming a\nnew dataset z = \\{x_0,x_0,x_1,x_1,...\\}, which is stored in the array za of length 2*size on output. On output the divided-differences\nof the Hermite representation are stored in the array dd, also of length 2*size. Using the notation above, dd[k] = [z_0,z_1,...,z_k].\nThe resulting Hermite polynomial can be evaluated by calling gsl_poly_dd_eval and using za for the input argument xa.",null,null],[0,"quadratic_equations","rgsl::polynomials","",null,null],[5,"poly_solve_quadratic","rgsl::polynomials::quadratic_equations","This function finds the real roots of the quadratic equation,",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"i32"}}],[5,"poly_complex_solve_quadratic","","This function finds the complex roots of the quadratic equation,",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"complexf64"},{"name":"complexf64"}],"output":{"name":"i32"}}],[0,"cubic_equations","rgsl::polynomials","",null,null],[5,"poly_solve_cubic","rgsl::polynomials::cubic_equations","This function finds the real roots of the cubic equation,",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"i32"}}],[5,"poly_complex_solve_cubic","","This function finds the complex roots of the cubic equation,",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"},{"name":"complexf64"},{"name":"complexf64"},{"name":"complexf64"}],"output":{"name":"i32"}}],[0,"pow","rgsl","",null,null],[8,"Pow","rgsl::pow","",null,null],[10,"pow_int","","This routine computes the power x^n for integer n. The power is computed efficiently—for example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications.\nA version of this function which also computes the numerical error in the result is available as gsl_sf_pow_int_e.",94,null],[10,"pow_uint","","This routine computes the power x^n for integer n. The power is computed efficiently—for example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications.\nA version of this function which also computes the numerical error in the result is available as gsl_sf_pow_int_e.",94,null],[10,"pow2","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",94,null],[10,"pow3","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",94,null],[10,"pow4","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",94,null],[10,"pow5","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",94,null],[10,"pow6","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",94,null],[10,"pow7","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",94,null],[10,"pow8","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",94,null],[10,"pow9","","This function can be used to compute small integer powers x^2, x^3, etc. efficiently.",94,null],[0,"power","rgsl","The following functions are equivalent to the function gsl_pow_int (see [1Small integer powers1](Pow.html)) with an error estimate.",null,null],[5,"pow_int","rgsl::power","This routine computes the power x^n for integer n. The power is computed using the minimum number of multiplications.\nFor example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications.\nFor reasons of efficiency, these functions do not check for overflow or underflow conditions.",null,{"inputs":[{"name":"f64"},{"name":"i32"}],"output":{"name":"f64"}}],[5,"pow_int_e","","This routine computes the power x^n for integer n. The power is computed using the minimum number of multiplications.\nFor example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications.\nFor reasons of efficiency, these functions do not check for overflow or underflow conditions.",null,null],[0,"psi","rgsl","The polygamma functions of order n are defined by",null,null],[0,"diagamma","rgsl::psi","",null,null],[5,"psi_int","rgsl::psi::diagamma","This routine computes the digamma function \\psi(n) for positive integer n. The digamma function is also called the Psi function.",null,{"inputs":[{"name":"i32"}],"output":{"name":"f64"}}],[5,"psi_int_e","","This routine computes the digamma function \\psi(n) for positive integer n. The digamma function is also called the Psi function.",null,null],[5,"psi","","This routine computes the digamma function \\psi(x) for general x, x \\ne 0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"psi_e","","This routine computes the digamma function \\psi(x) for general x, x \\ne 0.",null,null],[5,"psi_1piy","","This routine computes the real part of the digamma function on the line 1+i y, \\Re[\\psi(1 + i y)].",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"psi_1piy_e","","This routine computes the real part of the digamma function on the line 1+i y, \\Re[\\psi(1 + i y)].",null,null],[0,"trigamma","rgsl::psi","",null,null],[5,"psi_1_int","rgsl::psi::trigamma","This routine computes the Trigamma function \\psi&#39;(n) for positive integer n.",null,{"inputs":[{"name":"i32"}],"output":{"name":"f64"}}],[5,"psi_1_int_e","","This routine computes the Trigamma function \\psi&#39;(n) for positive integer n.",null,null],[5,"psi_1","","This routine computes the Trigamma function \\psi&#39;(x) for general x.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"psi_1_e","","This routine computes the Trigamma function \\psi&#39;(x) for general x.",null,null],[0,"polygamma","rgsl::psi","",null,null],[5,"psi_n","rgsl::psi::polygamma","This routine computes the polygamma function \\psi^{(n)}(x) for n &gt;= 0, x &gt; 0.",null,{"inputs":[{"name":"i32"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"psi_n_e","","This routine computes the polygamma function \\psi^{(n)}(x) for n &gt;= 0, x &gt; 0.",null,null],[0,"sort","rgsl","#Sorting",null,null],[0,"objects","rgsl::sort","The following function provides a simple alternative to the standard library function qsort. It is intended for systems lacking qsort, not\nas a replacement for it. The function qsort should be used whenever possible, as it will be faster and can provide stable ordering of equal\nelements. Documentation for qsort is available in the GNU C Library Reference Manual.",null,null],[5,"heapsort","rgsl::sort::objects","This function sorts the count elements of the array array, each of size size, into ascending order using the comparison function compare.\nThe type of the comparison function is defined by,",null,null],[5,"heapsort_index","","This function indirectly sorts the count elements of the array array, each of size size, into ascending order using the comparison\nfunction compare. The resulting permutation is stored in p, an array of length n. The elements of p give the index of the array element\nwhich would have been stored in that position if the array had been sorted in place. The first element of p gives the index of the\nleast element in array, and the last element of p gives the index of the greatest element in array. The array itself is not changed.",null,null],[0,"vectors","rgsl::sort","The following functions will sort the elements of an array or vector, either directly or indirectly. They are defined for all real and\ninteger types using the normal suffix rules. For example, the float versions of the array functions are gsl_sort_float and gsl_sort_float_index.\nThe corresponding vector functions are gsl_sort_vector_float and gsl_sort_vector_float_index. The prototypes are available in the header files\ngsl_sort_float.h gsl_sort_vector_float.h. The complete set of prototypes can be included using the header files gsl_sort.h and gsl_sort_vector.h.",null,null],[5,"sort","rgsl::sort::vectors","This function sorts the n elements of the array data with stride stride into ascending numerical order.",null,null],[5,"sort2","","This function sorts the n elements of the array data1 with stride stride1 into ascending numerical order, while making the same rearrangement\nof the array data2 with stride stride2, also of size n.",null,null],[5,"sort_vector","","This function sorts the elements of the vector v into ascending numerical order.",null,{"inputs":[{"name":"vectorf64"}],"output":null}],[5,"sort_vector2","","This function sorts the elements of the vector v1 into ascending numerical order, while making the same rearrangement of the vector v2.",null,{"inputs":[{"name":"vectorf64"},{"name":"vectorf64"}],"output":null}],[5,"sort_index","","This function indirectly sorts the n elements of the array data with stride stride into ascending order, storing the resulting\npermutation in p. The array p must be allocated with a sufficient length to store the n elements of the permutation. The elements of p\ngive the index of the array element which would have been stored in that position if the array had been sorted in place. The array data is not changed.",null,null],[5,"sort_vector_index","","This function indirectly sorts the elements of the vector v into ascending order, storing the resulting permutation in p. The elements of p give the\nindex of the vector element which would have been stored in that position if the vector had been sorted in place. The first element of p gives the index\nof the least element in v, and the last element of p gives the index of the greatest element in v. The vector v is not changed.",null,{"inputs":[{"name":"permutation"},{"name":"vectorf64"}],"output":{"name":"value"}}],[0,"select","rgsl::sort","The functions described in this section select the k smallest or largest elements of a data set of size N. The routines use an O(kN) direct insertion\nalgorithm which is suited to subsets that are small compared with the total size of the dataset. For example, the routines are useful for selecting the\n10 largest values from one million data points, but not for selecting the largest 100,000 values. If the subset is a significant part of the total dataset\nit may be faster to sort all the elements of the dataset directly with an O(N \\log N) algorithm and obtain the smallest or largest values that way.",null,null],[5,"sort_smallest","rgsl::sort::select","This function copies the k smallest elements of the array src, of size n and stride stride, in ascending numerical order into the array dest. The size\nk of the subset must be less than or equal to n. The data src is not modified by this operation.",null,null],[5,"sort_largest","","This function copies the k largest elements of the array src, of size n and stride stride, in descending numerical order into the array dest. k must\nbe less than or equal to n. The data src is not modified by this operation.",null,null],[5,"sort_vector_smallest","","This function copies the k smallest or largest elements of the vector v into the array dest. k must be less than or equal to the length of the vector v.",null,null],[5,"sort_vector_largest","","This function copies the k smallest or largest elements of the vector v into the array dest. k must be less than or equal to the length of the vector v.",null,null],[5,"sort_smallest_index","","This function stores the indices of the k smallest elements of the array src, of size n and stride stride, in the array p. The indices are chosen so that\nthe corresponding data is in ascending numerical order. k must be less than or equal to n. The data src is not modified by this operation.",null,null],[5,"sort_largest_index","","This function stores the indices of the k largest elements of the array src, of size n and stride stride, in the array p. The indices are chosen so that\nthe corresponding data is in descending numerical order. k must be less than or equal to n. The data src is not modified by this operation.",null,null],[5,"sort_vector_smallest_index","","This function stores the indices of the k smallest or largest elements of the vector v in the array p. k must be less than or equal to the length of\nthe vector v.",null,null],[5,"sort_vector_largest_index","","This function stores the indices of the k smallest or largest elements of the vector v in the array p. k must be less than or equal to the length of\nthe vector v.",null,null],[0,"statistics","rgsl","#Statistics",null,null],[5,"mean","rgsl::statistics","This function returns the arithmetic mean of data, a dataset of length n with stride stride. The arithmetic mean, or sample mean, is\ndenoted by \\Hat\\mu and defined as,",null,null],[5,"variance","","This function returns the estimated, or sample, variance of data, a dataset of length n with stride stride. The estimated variance is\ndenoted by \\Hat\\sigma^2 and is defined by,",null,null],[5,"variance_m","","This function returns the sample variance of data relative to the given value of mean. The function is computed with \\Hat\\mu replaced\nby the value of mean that you supply,",null,null],[5,"sd","","The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding\nvariance functions above.",null,null],[5,"sd_m","","The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding\nvariance functions above.",null,null],[5,"tss","","This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m the user-supplied value of mean is\nused, and for gsl_stats_tss it is computed using gsl_stats_mean.",null,null],[5,"tss_m","","This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m the user-supplied value of mean is\nused, and for gsl_stats_tss it is computed using gsl_stats_mean.",null,null],[5,"variance_with_fixed_mean","","This function computes an unbiased estimate of the variance of data when the population mean mean of the underlying distribution is\nknown a priori. In this case the estimator for the variance uses the factor 1/N and the sample mean \\Hat\\mu is replaced by the known\npopulation mean \\mu,",null,null],[5,"sd_with_fixed_mean","","This function calculates the standard deviation of data for a fixed population mean mean. The result is the square root of the\ncorresponding variance function.",null,null],[5,"absdev","","This function computes the absolute deviation from the mean of data, a dataset of length n with stride stride. The absolute deviation\nfrom the mean is defined as,",null,null],[5,"absdev_m","","This function computes the absolute deviation of the dataset data relative to the given value of mean,",null,null],[5,"skew","","This function computes the skewness of data, a dataset of length n with stride stride. The skewness is defined as,",null,null],[5,"skew_m_sd","","This function computes the skewness of the dataset data using the given values of the mean mean and standard deviation sd,",null,null],[5,"kurtosis","","This function computes the kurtosis of data, a dataset of length n with stride stride. The kurtosis is defined as,",null,null],[5,"kurtosis_m_sd","","This function computes the kurtosis of the dataset data using the given values of the mean mean and standard deviation sd,",null,null],[5,"lag1_autocorrelation","","This function computes the lag-1 autocorrelation of the dataset data.",null,null],[5,"lag1_autocorrelation_m","","This function computes the lag-1 autocorrelation of the dataset data using the given value of the mean mean.",null,null],[5,"covariance","","This function computes the covariance of the datasets data1 and data2 which must both be of the same length n.",null,null],[5,"covariance_m","","This function computes the covariance of the datasets data1 and data2 using the given values of the means, mean1 and mean2. This is\nuseful if you have already computed the means of data1 and data2 and want to avoid recomputing them.",null,null],[5,"correlation","","This function efficiently computes the Pearson correlation coefficient between the datasets data1 and data2 which must both be of the\nsame length n.",null,null],[5,"spearman","","This function computes the Spearman rank correlation coefficient between the datasets data1 and data2 which must both be of the same\nlength n. Additional workspace of size 2*n is required in work. The Spearman rank correlation between vectors x and y is equivalent to\nthe Pearson correlation between the ranked vectors x_R and y_R, where ranks are defined to be the average of the positions of an\nelement in the ascending order of the values.",null,null],[5,"wmean","","This function returns the weighted mean of the dataset data with stride stride and length n, using the set of weights w with stride\nwstride and length n. The weighted mean is defined as,",null,null],[5,"wvariance","","This function returns the estimated variance of the dataset data with stride stride and length n, using the set of weights w with\nstride wstride and length n. The estimated variance of a weighted dataset is calculated as,",null,null],[5,"wvariance_m","","This function returns the estimated variance of the weighted dataset data using the given weighted mean wmean.",null,null],[5,"wsd","","The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding\nvariance function gsl_stats_wvariance above.",null,null],[5,"wsd_m","","This function returns the square root of the corresponding variance function gsl_stats_wvariance_m above.",null,null],[5,"wvariance_with_fixed_mean","","This function computes an unbiased estimate of the variance of the weighted dataset data when the population mean mean of the\nunderlying distribution is known a priori. In this case the estimator for the variance replaces the sample mean \\Hat\\mu by the known\npopulation mean \\mu,",null,null],[5,"wsd_with_fixed_mean","","The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding\nvariance function above.",null,null],[5,"wtss","","This function returns the weighted total sum of squares (TSS) of data about the weighted mean. For gsl_stats_wtss_m the user-supplied\nvalue of wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.",null,null],[5,"wtss_m","","This function returns the weighted total sum of squares (TSS) of data about the weighted mean. For gsl_stats_wtss_m the user-supplied\nvalue of wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.",null,null],[5,"wabsdev","","This function computes the weighted absolute deviation from the weighted mean of data. The absolute deviation from the mean is defined\nas,",null,null],[5,"wabsdev_m","","This function computes the absolute deviation of the weighted dataset data about the given weighted mean wmean.",null,null],[5,"wskew","","This function computes the weighted skewness of the dataset data.",null,null],[5,"wskew_m_sd","","This function computes the weighted skewness of the dataset data using the given values of the weighted mean and weighted standard\ndeviation, wmean and wsd.",null,null],[5,"wkurtosis","","This function computes the weighted kurtosis of the dataset data.",null,null],[5,"wkurtosis_m_sd","","This function computes the weighted kurtosis of the dataset data using the given values of the weighted mean and weighted standard\ndeviation, wmean and wsd.",null,null],[5,"max","","This function returns the maximum value in data, a dataset of length n with stride stride. The maximum value is defined as the value\nof the element x_i which satisfies x_i &gt;= x_j for all j.",null,null],[5,"min","","This function returns the minimum value in data, a dataset of length n with stride stride. The minimum value is defined as the value\nof the element x_i which satisfies x_i &lt;= x_j for all j.",null,null],[5,"minmax","","This function finds both the minimum and maximum values min, max in data in a single pass.",null,null],[5,"max_index","","This function returns the index of the maximum value in data, a dataset of length n with stride stride. The maximum value is defined\nas the value of the element x_i which satisfies x_i &gt;= x_j for all j. When there are several equal maximum elements then the first\none is chosen.",null,null],[5,"min_index","","This function returns the index of the minimum value in data, a dataset of length n with stride stride. The minimum value is defined\nas the value of the element x_i which satisfies x_i &gt;= x_j for all j. When there are several equal minimum elements then the first\none is chosen.",null,null],[5,"minmax_index","","This function returns the indexes min_index, max_index of the minimum and maximum values in data in a single pass.",null,null],[5,"median_from_sorted_data","","This function returns the median value of sorted_data, a dataset of length n with stride stride. The elements of the array must be in\nascending numerical order. There are no checks to see whether the data are sorted, so the function gsl_sort should always be used\nfirst.",null,null],[5,"quantile_from_sorted_data","","This function returns a quantile value of sorted_data, a double-precision array of length n with stride stride. The elements of the\narray must be in ascending numerical order. The quantile is determined by the f, a fraction between 0 and 1. For example, to compute\nthe value of the 75th percentile f should have the value 0.75.",null,null],[0,"synchrotron","rgsl","",null,null],[5,"synchrotron_1","rgsl::synchrotron","This routine computes the first synchrotron function x \\int_x^\\infty dt K_{5/3}(t) for x &gt;= 0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"synchrotron_1_e","","This routine computes the first synchrotron function x \\int_x^\\infty dt K_{5/3}(t) for x &gt;= 0.",null,null],[5,"synchrotron_2","","This routine computes the second synchrotron function x K_{2/3}(x) for x &gt;= 0.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"synchrotron_2_e","","This routine computes the second synchrotron function x K_{2/3}(x) for x &gt;= 0.",null,null],[0,"transport","rgsl","The transport functions J(n,x) are defined by the integral representations J(n,x) := \\int_0^x dt t^n e^t /(e^t - 1)^2.",null,null],[5,"transport_2","rgsl::transport","This routine computes the transport function J(2,x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"transport_2_e","","This routine computes the transport function J(2,x).",null,null],[5,"transport_3","","This routine computes the transport function J(3,x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"transport_3_e","","This routine computes the transport function J(3,x).",null,null],[5,"transport_4","","This routine computes the transport function J(4,x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"transport_4_e","","This routine computes the transport function J(4,x).",null,null],[5,"transport_5","","This routine computes the transport function J(5,x).",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"transport_5_e","","This routine computes the transport function J(5,x).",null,null],[0,"trigonometric","rgsl","",null,null],[8,"Trigonometric","rgsl::trigonometric","",null,null],[10,"sin","","This routine computes the sine function \\sin(x).",95,null],[10,"sin_e","","This routine computes the sine function \\sin(x).",95,null],[10,"cos","","This routine computes the cosine function \\sin(x).",95,null],[10,"cos_e","","This routine computes the cosine function \\sin(x).",95,null],[10,"sf_hypot","","This routine computes the hypotenuse function \\sqrt{x^2 + y^2} avoiding overflow and underflow.",95,null],[10,"sf_hypot_e","","This routine computes the hypotenuse function \\sqrt{x^2 + y^2} avoiding overflow and underflow.",95,null],[10,"sinc","","This routine computes \\sinc(x) = \\sin(\\pi x) / (\\pi x) for any value of x.",95,null],[10,"sinc_e","","This routine computes \\sinc(x) = \\sin(\\pi x) / (\\pi x) for any value of x.",95,null],[10,"complex_sin_e","","This function computes the complex sine, \\sin(z_r + i z_i) storing the real and imaginary parts in szr, szi.",95,null],[10,"complex_cos_e","","This function computes the complex cosine, \\cos(z_r + i z_i) storing the real and imaginary parts in czr, czi.",95,null],[10,"complex_logsin_e","","This function computes the logarithm of the complex sine, \\log(\\sin(z_r + i z_i)) storing the real and imaginary parts in lszr, lszi.",95,null],[10,"lnsinh","","This routine computes \\log(\\sinh(x)) for x &gt; 0.",95,null],[10,"lnsinh_e","","This routine computes \\log(\\sinh(x)) for x &gt; 0.",95,null],[10,"lncosh","","This routine computes \\log(\\cosh(x)) for x &gt; 0.",95,null],[10,"lncosh_e","","This routine computes \\log(\\cosh(x)) for x &gt; 0.",95,null],[10,"polar_to_rect","","This function converts the polar coordinates (r,theta) to rectilinear coordinates (x,y), x = r\\cos(\\theta), y = r\\sin(\\theta).",95,null],[10,"rect_to_polar","","This function converts the rectilinear coordinates (x,y) to polar coordinates (r,theta), such that x = r\\cos(\\theta), y = r\\sin(\\theta).\nThe argument theta lies in the range [-\\pi, \\pi].",95,null],[10,"angle_restrict_symm","","This routine forces the angle theta to lie in the range (-\\pi,\\pi].",95,null],[10,"angle_restrict_symm_e","","This routine forces the angle theta to lie in the range (-\\pi,\\pi].",95,null],[10,"angle_restrict_pos","","This routine forces the angle theta to lie in the range [0, 2\\pi).",95,null],[10,"angle_restrict_pos_e","","This routine forces the angle theta to lie in the range [0, 2\\pi).",95,null],[10,"sin_err_e","","This routine computes the sine of an angle x with an associated absolute error dx, \\sin(x \\pm dx).",95,null],[10,"cos_err_e","","This routine computes the cosine of an angle x with an associated absolute error dx, \\cos(x \\pm dx).",95,null],[0,"util","rgsl","",null,null],[5,"subinterval_too_small","rgsl::util","",null,{"inputs":[{"name":"f64"},{"name":"f64"},{"name":"f64"}],"output":{"name":"bool"}}],[0,"wavelet_transforms","rgsl","##Transform Functions",null,null],[0,"one_dimension","rgsl::wavelet_transforms","These functions compute in-place forward and inverse discrete wavelet transforms of length n with stride stride on the array data. The\nlength of the transform n is restricted to powers of two. For the transform version of the function the argument dir can be either\nforward (+1) or backward (-1). A workspace work of length n must be provided.",null,null],[5,"transform","rgsl::wavelet_transforms::one_dimension","",null,null],[5,"transform_forward","","",null,null],[5,"transform_inverse","","",null,null],[0,"two_dimension","rgsl::wavelet_transforms","The library provides functions to perform two-dimensional discrete wavelet transforms on square matrices. The matrix dimensions must\nbe an integer power of two. There are two possible orderings of the rows and columns in the two-dimensional wavelet transform,\nreferred to as the “standard” and “non-standard” forms.",null,null],[5,"transform","rgsl::wavelet_transforms::two_dimension","These functions compute two-dimensional in-place forward and inverse discrete wavelet transforms in standard form on the array\ndata stored in row-major form with dimensions size1 and size2 and physical row length tda. The dimensions must be equal\n(square matrix) and are restricted to powers of two. For the transform version of the function the argument dir can be either\nforward (+1) or backward (-1). A workspace work of the appropriate size must be provided. On exit, the appropriate elements of\nthe array data are replaced by their two-dimensional wavelet transform.",null,null],[5,"transform_forward","","These functions compute two-dimensional in-place forward and inverse discrete wavelet transforms in standard form on the array\ndata stored in row-major form with dimensions size1 and size2 and physical row length tda. The dimensions must be equal\n(square matrix) and are restricted to powers of two. For the transform version of the function the argument dir can be either\nforward (+1) or backward (-1). A workspace work of the appropriate size must be provided. On exit, the appropriate elements of\nthe array data are replaced by their two-dimensional wavelet transform.",null,null],[5,"transform_inverse","","These functions compute two-dimensional in-place forward and inverse discrete wavelet transforms in standard form on the array\ndata stored in row-major form with dimensions size1 and size2 and physical row length tda. The dimensions must be equal\n(square matrix) and are restricted to powers of two. For the transform version of the function the argument dir can be either\nforward (+1) or backward (-1). A workspace work of the appropriate size must be provided. On exit, the appropriate elements of\nthe array data are replaced by their two-dimensional wavelet transform.",null,null],[5,"transform_matrix","","These functions compute the two-dimensional in-place wavelet transform on a matrix a.",null,{"inputs":[{"name":"wavelet"},{"name":"matrixf64"},{"name":"waveletdirection"},{"name":"waveletworkspace"}],"output":{"name":"value"}}],[5,"transform_matrix_forward","","These functions compute the two-dimensional in-place wavelet transform on a matrix a.",null,{"inputs":[{"name":"wavelet"},{"name":"matrixf64"},{"name":"waveletworkspace"}],"output":{"name":"value"}}],[5,"transform_matrix_inverse","","These functions compute the two-dimensional in-place wavelet transform on a matrix a.",null,{"inputs":[{"name":"wavelet"},{"name":"matrixf64"},{"name":"waveletworkspace"}],"output":{"name":"value"}}],[5,"nstransform","","These functions compute the two-dimensional wavelet transform in non-standard form.",null,null],[5,"nstransform_forward","","These functions compute the two-dimensional wavelet transform in non-standard form.",null,null],[5,"nstransform_inverse","","These functions compute the two-dimensional wavelet transform in non-standard form.",null,null],[5,"nstransform_matrix","","These functions compute the non-standard form of the two-dimensional in-place wavelet transform on a matrix a.",null,{"inputs":[{"name":"wavelet"},{"name":"matrixf64"},{"name":"waveletdirection"},{"name":"waveletworkspace"}],"output":{"name":"value"}}],[5,"nstransform_matrix_forward","","These functions compute the non-standard form of the two-dimensional in-place wavelet transform on a matrix a.",null,{"inputs":[{"name":"wavelet"},{"name":"matrixf64"},{"name":"waveletworkspace"}],"output":{"name":"value"}}],[5,"nstransform_matrix_inverse","","These functions compute the non-standard form of the two-dimensional in-place wavelet transform on a matrix a.",null,{"inputs":[{"name":"wavelet"},{"name":"matrixf64"},{"name":"waveletworkspace"}],"output":{"name":"value"}}],[0,"zeta","rgsl","The Riemann zeta function is defined in Abramowitz &amp; Stegun, Section 23.2.",null,null],[0,"riemann","rgsl::zeta","The Riemann zeta function is defined by the infinite sum \\zeta(s) = \\sum_{k=1}^\\infty k^{-s}.",null,null],[5,"zeta_int","rgsl::zeta::riemann","This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.",null,{"inputs":[{"name":"i32"}],"output":{"name":"f64"}}],[5,"zeta_int_e","","This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.",null,null],[5,"zeta","","This routine computes the Riemann zeta function \\zeta(s) for arbitrary s, s \\ne 1.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"zeta_e","","This routine computes the Riemann zeta function \\zeta(s) for arbitrary s, s \\ne 1.",null,null],[0,"riemann_mins_one","rgsl::zeta","For large positive argument, the Riemann zeta function approaches one.\nIn this region the fractional part is interesting, and therefore we need a function to evaluate it explicitly.",null,null],[5,"zetam1_int","rgsl::zeta::riemann_mins_one","This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.",null,{"inputs":[{"name":"i32"}],"output":{"name":"f64"}}],[5,"zetam1_int_e","","This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.",null,null],[5,"zetam1","","This routine computes \\zeta(s) - 1 for arbitrary s, s \\ne 1.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"zetam1_e","","This routine computes \\zeta(s) - 1 for arbitrary s, s \\ne 1.",null,null],[0,"hurwitz","rgsl::zeta","The Hurwitz zeta function is defined by \\zeta(s,q) = \\sum_0^\\infty (k+q)^{-s}.",null,null],[5,"hzeta","rgsl::zeta::hurwitz","This routine computes the Hurwitz zeta function \\zeta(s,q) for s &gt; 1, q &gt; 0.",null,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"f64"}}],[5,"hzeta_e","","This routine computes the Hurwitz zeta function \\zeta(s,q) for s &gt; 1, q &gt; 0.",null,null],[0,"eta","rgsl::zeta","The eta function is defined by \\eta(s) = (1-2^{1-s}) \\zeta(s).",null,null],[5,"eta_int","rgsl::zeta::eta","This routine computes the eta function \\eta(n) for integer n.",null,{"inputs":[{"name":"i32"}],"output":{"name":"f64"}}],[5,"eta_int_e","","This routine computes the eta function \\eta(n) for integer n.",null,null],[5,"eta","","This routine computes the eta function \\eta(s) for arbitrary s.",null,{"inputs":[{"name":"f64"}],"output":{"name":"f64"}}],[5,"eta_e","","This routine computes the eta function \\eta(s) for arbitrary s.",null,null],[6,"GSLResult","rgsl","A type for results generated by GSL functions where `Err` is `enums::Value`.",null,null],[6,"comparison_fn","","",null,null],[6,"function","","",null,null],[6,"integration_function","","",null,null],[6,"monte_function","","",null,null],[6,"select_function","","",null,null],[6,"value_function","","",null,null],[7,"SF_GAMMA_XMAX","","The maximum x such that gamma(x) is not considered an overflow.",null,null],[7,"SF_FACT_NMAX","","The maximum n such that gsl_sf_fact(n) does not give an overflow.",null,null],[7,"SF_DOUBLEFACT_NMAX","","The maximum n such that gsl_sf_doublefact(n) does not give an overflow.",null,null],[7,"SF_MATHIEU_COEFF","","",null,null],[7,"DBL_EPSILON","","",null,null],[7,"SQRT_DBL_EPSILON","","",null,null],[7,"ROOT3_DBL_EPSILON","","",null,null],[7,"ROOT4_DBL_EPSILON","","",null,null],[7,"ROOT5_DBL_EPSILON","","",null,null],[7,"ROOT6_DBL_EPSILON","","",null,null],[7,"DBL_MIN","","",null,null],[7,"SQRT_DBL_MIN","","",null,null],[7,"ROOT3_DBL_MIN","","",null,null],[7,"ROOT4_DBL_MIN","","",null,null],[7,"ROOT5_DBL_MIN","","",null,null],[7,"ROOT6_DBL_MIN","","",null,null],[7,"DBL_MAX","","",null,null],[7,"SQRT_DBL_MAX","","",null,null],[7,"ROOT3_DBL_MAX","","",null,null],[7,"ROOT4_DBL_MAX","","",null,null],[7,"ROOT5_DBL_MAX","","",null,null],[7,"ROOT6_DBL_MAX","","",null,null],[7,"LOG_DBL_MAX","","",null,null],[7,"NAN","","",null,null],[7,"POSINF","","",null,null],[7,"NEGINF","","",null,null],[11,"from","","",96,{"inputs":[{"name":"value"}],"output":{"name":"self"}}]],"paths":[[4,"Mode"],[4,"Value"],[4,"EigenSort"],[4,"FftDirection"],[4,"GaussKonrodRule"],[4,"IntegrationQawo"],[4,"VegasMode"],[4,"ODEiv"],[4,"WaveletDirection"],[3,"BSpLineWorkspace"],[3,"BSpLineDerivWorkspace"],[3,"ChebSeries"],[3,"Combination"],[3,"ComplexF64"],[3,"ComplexF32"],[3,"DiscreteHankel"],[3,"EigenSymmetricWorkspace"],[3,"EigenSymmetricVWorkspace"],[3,"EigenHermitianWorkspace"],[3,"EigenHermitianVWorkspace"],[3,"EigenNonSymmWorkspace"],[3,"EigenNonSymmVWorkspace"],[3,"EigenGenSymmWorkspace"],[3,"EigenGenSymmVWorkspace"],[3,"EigenGenHermWorkspace"],[3,"EigenGenHermVWorkspace"],[3,"EigenGenWorkspace"],[3,"EigenGenVWorkspace"],[3,"FftComplexWaveTable"],[3,"FftComplexWorkspace"],[3,"Histogram"],[3,"HistogramPdf"],[3,"Histogram2D"],[3,"Histogram2DPdf"],[3,"IntegrationWorkspace"],[3,"IntegrationQawsTable"],[3,"IntegrationQawoTable"],[3,"CquadWorkspace"],[3,"GLFixedTable"],[3,"InterpAccel"],[3,"Interp"],[3,"InterpType"],[3,"Spline"],[3,"MathieuWorkspace"],[3,"MatrixView"],[3,"MatrixF64"],[3,"MatrixF32"],[3,"MatrixComplexF64"],[3,"MatrixComplexF32"],[3,"MinimizerType"],[3,"Minimizer"],[3,"MiserParams"],[3,"PlainMonteCarlo"],[3,"MiserMonteCarlo"],[3,"VegasMonteCarlo"],[3,"MultiFitFunction"],[3,"MultiFitFdfSolver"],[3,"MultiFitFunctionFdf"],[3,"MultiFitFdfSolverType"],[3,"MultiSet"],[3,"NTuples"],[3,"ODEiv2System"],[3,"ODEiv2Step"],[3,"ODEiv2StepType"],[3,"ODEiv2Control"],[3,"ODEiv2ControlType"],[3,"ODEiv2Evolve"],[3,"ODEiv2Driver"],[3,"Permutation"],[3,"PolyComplex"],[3,"QRng"],[3,"QRngType"],[3,"RanDiscrete"],[3,"Result"],[3,"ResultE10"],[3,"LevinUWorkspace"],[3,"LevinUTruncWorkspace"],[3,"Rng"],[3,"RngType"],[3,"VectorView"],[3,"VectorF32"],[3,"VectorF64"],[3,"VectorComplexF64"],[3,"VectorComplexF32"],[3,"Wavelet"],[3,"WaveletType"],[3,"WaveletWorkspace"],[3,"Index"],[4,"Order"],[4,"Side"],[4,"Transpose"],[4,"Uplo"],[4,"Diag"],[8,"Elementary"],[8,"Pow"],[8,"Trigonometric"],[6,"GSLResult"]]};
searchIndex["ordered_float"] = {"doc":"Wrappers for total order on Floats.","items":[[3,"OrderedFloat","ordered_float","A wrapper around Floats providing an implementation of Ord and Hash.",null,null],[12,"0","","",0,null],[3,"NotNaN","","A wrapper around Floats providing an implementation of Ord and Hash.",null,null],[3,"FloatIsNaN","","An error indicating an attempt to construct NotNaN from a NaN",null,null],[11,"clone","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"orderedfloat"}}],[11,"fmt","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"into_inner","","Get the value out.",0,null],[11,"as_ref","","",0,null],[11,"as_mut","","",0,null],[11,"cmp","","",0,null],[11,"eq","","",0,null],[11,"hash","","",0,null],[11,"fmt","","",0,null],[11,"into","","",0,null],[11,"into","","",0,null],[11,"from","","",0,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"clone","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"notnan"}}],[11,"fmt","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"partial_cmp","","",1,null],[11,"lt","","",1,null],[11,"le","","",1,null],[11,"gt","","",1,null],[11,"ge","","",1,null],[11,"new","","Create a NotNaN value.",1,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[11,"unchecked_new","","Create a NotNaN value from a value that is guaranteed to not be NaN",1,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"into_inner","","Get the value out.",1,null],[11,"as_ref","","",1,null],[11,"cmp","","",1,null],[11,"hash","","",1,null],[11,"fmt","","",1,null],[11,"into","","",1,null],[11,"into","","",1,null],[11,"from","","",1,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"deref","","",1,null],[11,"add","","",1,null],[11,"add","","",1,null],[11,"add_assign","","",1,null],[11,"add_assign","","",1,null],[11,"add_assign","","",1,null],[11,"add_assign","","",1,null],[11,"sub","","",1,null],[11,"sub","","",1,null],[11,"sub_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"sub_assign","","",1,null],[11,"mul","","",1,null],[11,"mul","","",1,null],[11,"mul_assign","","",1,null],[11,"mul_assign","","",1,null],[11,"mul_assign","","",1,null],[11,"mul_assign","","",1,null],[11,"div","","",1,null],[11,"div","","",1,null],[11,"div_assign","","",1,null],[11,"div_assign","","",1,null],[11,"div_assign","","",1,null],[11,"div_assign","","",1,null],[11,"rem","","",1,null],[11,"rem","","",1,null],[11,"rem_assign","","",1,null],[11,"rem_assign","","",1,null],[11,"rem_assign","","",1,null],[11,"rem_assign","","",1,null],[11,"neg","","",1,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"clone","","",2,null],[11,"description","","",2,null],[11,"fmt","","",2,null],[11,"into","","",2,null]],"paths":[[3,"OrderedFloat"],[3,"NotNaN"],[3,"FloatIsNaN"]]};
searchIndex["unreachable"] = {"doc":"# unreachable","items":[[5,"unreachable","unreachable","Hint to the optimizer that any code path which calls this function is\nstatically unreachable and can be removed.",null,null],[8,"UncheckedOptionExt","","An extension trait for `Option&lt;T&gt;` providing unchecked unwrapping methods.",null,null],[10,"unchecked_unwrap","","Get the value out of this Option without checking for None.",0,null],[10,"unchecked_unwrap_none","","Assert that this Option is a None to the optimizer.",0,null],[8,"UncheckedResultExt","","An extension trait for `Result&lt;T, E&gt;` providing unchecked unwrapping methods.",null,null],[10,"unchecked_unwrap_ok","","Get the value out of this Result without checking for Err.",1,null],[10,"unchecked_unwrap_err","","Get the error out of this Result without checking for Ok.",1,null]],"paths":[[8,"UncheckedOptionExt"],[8,"UncheckedResultExt"]]};
searchIndex["ndarray"] = {"doc":"The `ndarray` crate provides an N-dimensional container for general elements\nand for numerics.","items":[[3,"Axis","ndarray","An axis index.",null,null],[12,"0","","",0,null],[3,"Indexes","","An iterator over the indexes of an array shape.",null,null],[3,"ShapeError","","An error related to array shape or layout.",null,null],[3,"Si","","A slice, a description of a range of an array axis.",null,null],[12,"0","","",1,null],[12,"1","","",1,null],[12,"2","","",1,null],[3,"InnerIter","","An iterator that traverses over all dimensions but the innermost,\nand yields each inner row.",null,null],[3,"InnerIterMut","","An iterator that traverses over all dimensions but the innermost,\nand yields each inner row (mutable).",null,null],[3,"AxisIter","","An iterator that traverses over an axis and\nand yields each subview.",null,null],[3,"AxisIterMut","","An iterator that traverses over an axis and\nand yields each subview (mutable)",null,null],[3,"AxisChunksIter","","An iterator that traverses over the specified axis\nand yields views of the specified size on this axis.",null,null],[3,"AxisChunksIterMut","","An iterator that traverses over the specified axis\nand yields mutable views of the specified size on this axis.",null,null],[3,"ArrayBase","","An *N*-dimensional array.",null,null],[3,"ViewRepr","","Array view’s representation.",null,null],[3,"Elements","","An iterator over the elements of an array.",null,null],[3,"ElementsMut","","An iterator over the elements of an array (mutable).",null,null],[3,"Indexed","","An iterator over the indexes and elements of an array.",null,null],[3,"IndexedMut","","An iterator over the indexes and elements of an array (mutable).",null,null],[3,"Shape","","A contiguous array shape of n dimensions.",null,null],[3,"StrideShape","","An array shape of n dimensions c-order, f-order or custom strides.",null,null],[4,"ErrorKind","","Error code for an error related to array shape or layout.",null,null],[13,"IncompatibleShape","","incompatible shape",2,null],[13,"IncompatibleLayout","","incompatible memory layout",2,null],[13,"RangeLimited","","the shape does not fit inside type limits",2,null],[13,"OutOfBounds","","out of bounds indexing",2,null],[13,"Unsupported","","aliasing array elements",2,null],[5,"stack","","Stack arrays along the given axis.",null,null],[5,"arr0","","Create a zero-dimensional array with the element `x`.",null,{"inputs":[{"name":"a"}],"output":{"name":"array0"}}],[5,"arr1","","Create a one-dimensional array with elements from `xs`.",null,null],[5,"rcarr1","","Create a one-dimensional array with elements from `xs`.",null,null],[5,"aview0","","Create a zero-dimensional array view borrowing `x`.",null,{"inputs":[{"name":"a"}],"output":{"name":"arrayview0"}}],[5,"aview1","","Create a one-dimensional array view with elements borrowing `xs`.",null,null],[5,"aview2","","Create a two-dimensional array view with elements borrowing `xs`.",null,null],[5,"aview_mut1","","Create a one-dimensional read-write array view with elements borrowing `xs`.",null,null],[5,"arr2","","Create a two-dimensional array with elements from `xs`.",null,null],[5,"rcarr2","","Create a two-dimensional array with elements from `xs`.",null,null],[5,"arr3","","Create a three-dimensional array with elements from `xs`.",null,null],[5,"rcarr3","","Create a three-dimensional array with elements from `xs`.",null,null],[11,"index","","",3,null],[11,"index_mut","","",3,null],[11,"eq","","",3,null],[11,"from_iter","","",3,{"inputs":[{"name":"i"}],"output":{"name":"arraybase"}}],[11,"hash","","",3,null],[11,"from","","",3,{"inputs":[{"name":"slice"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"arraybase"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"slice"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"arraybase"}],"output":{"name":"self"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"_data_slice","","",4,null],[11,"clone_with_ptr","","",4,null],[11,"_data_slice","","",4,null],[11,"fmt","","",0,null],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"axis","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"clone","","",0,null],[11,"clone","","",5,null],[11,"new","","Create an iterator over the array shape `dim`.",5,{"inputs":[{"name":"d"}],"output":{"name":"indexes"}}],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"clone","","",6,null],[11,"next","","",6,null],[11,"size_hint","","",6,null],[11,"fold","","",6,null],[11,"next_back","","",6,null],[11,"next","","",7,null],[11,"size_hint","","",7,null],[11,"next","","",8,null],[11,"size_hint","","",8,null],[11,"fold","","",8,null],[11,"next_back","","",8,null],[11,"next","","",9,null],[11,"size_hint","","",9,null],[11,"next","","",10,null],[11,"size_hint","","",10,null],[11,"next","","",11,null],[11,"size_hint","","",11,null],[11,"split_at","","Split the iterator at index, yielding two disjoint iterators.",12,null],[11,"clone","","",12,null],[11,"next","","",12,null],[11,"size_hint","","",12,null],[11,"next_back","","",12,null],[11,"split_at","","Split the iterator at index, yielding two disjoint iterators.",13,null],[11,"next","","",13,null],[11,"size_hint","","",13,null],[11,"next_back","","",13,null],[11,"next","","",14,null],[11,"size_hint","","",14,null],[11,"next_back","","",14,null],[11,"next","","",15,null],[11,"size_hint","","",15,null],[11,"next_back","","",15,null],[11,"fmt","","",1,null],[11,"hash","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"from","","",1,{"inputs":[{"name":"range"}],"output":{"name":"si"}}],[11,"from","","",1,{"inputs":[{"name":"rangefrom"}],"output":{"name":"si"}}],[11,"from","","",1,{"inputs":[{"name":"rangeto"}],"output":{"name":"si"}}],[11,"from","","",1,{"inputs":[{"name":"rangefull"}],"output":{"name":"si"}}],[11,"step","","",1,null],[11,"clone","","",1,null],[11,"clone","","",16,null],[11,"kind","","Return the `ErrorKind` of this error.",16,null],[11,"from_kind","","Create a new `ShapeError`",16,{"inputs":[{"name":"errorkind"}],"output":{"name":"self"}}],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"eq","","",2,null],[11,"eq","","",16,null],[11,"description","","",16,null],[11,"fmt","","",16,null],[11,"fmt","","",16,null],[11,"from","","",17,{"inputs":[{"name":"d"}],"output":{"name":"self"}}],[11,"from","","",18,{"inputs":[{"name":"d"}],"output":{"name":"self"}}],[11,"from","","",18,{"inputs":[{"name":"shape"}],"output":{"name":"self"}}],[11,"f","","",17,null],[11,"set_f","","",17,null],[11,"strides","","",17,null],[0,"prelude","","ndarray prelude.",null,null],[11,"clone","","",3,null],[11,"from_vec","","Create a one-dimensional array from a vector (no copying needed).",3,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"from_iter","","Create a one-dimensional array from an iterable.",3,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"linspace","","Create a one-dimensional array from the inclusive interval\n`[start, end]` with `n` elements. `F` must be a floating point type.",3,{"inputs":[{"name":"f"},{"name":"f"},{"name":"usize"}],"output":{"name":"self"}}],[11,"range","","Create a one-dimensional array from the half-open interval\n`[start, end)` with elements spaced by `step`. `F` must be a floating point type.",3,{"inputs":[{"name":"f"},{"name":"f"},{"name":"f"}],"output":{"name":"self"}}],[11,"eye","","Create an identity matrix of size `n` (square 2D array).",3,{"inputs":[{"name":"ix"}],"output":{"name":"self"}}],[11,"from_elem","","Create an array with copies of `elem`, shape `shape`.",3,{"inputs":[{"name":"sh"},{"name":"a"}],"output":{"name":"self"}}],[11,"zeros","","Create an array with zeros, shape `shape`.",3,{"inputs":[{"name":"sh"}],"output":{"name":"self"}}],[11,"default","","Create an array with default values, shape `shape`",3,{"inputs":[{"name":"sh"}],"output":{"name":"self"}}],[11,"from_shape_fn","","Create an array with values created by the function `f`.",3,{"inputs":[{"name":"sh"},{"name":"f"}],"output":{"name":"self"}}],[11,"from_shape_vec","","Create an array with the given shape from a vector. (No cloning of\nelements needed.)",3,{"inputs":[{"name":"sh"},{"name":"vec"}],"output":{"name":"result"}}],[11,"from_shape_vec_unchecked","","Create an array from a vector and interpret it according to the\nprovided dimensions and strides. (No cloning of elements needed.)",3,{"inputs":[{"name":"sh"},{"name":"vec"}],"output":{"name":"self"}}],[11,"len","","Return the total number of elements in the array.",3,null],[11,"dim","","Return the shape of the array.",3,null],[11,"shape","","Return the shape of the array as a slice.",3,null],[11,"strides","","Return the strides of the array",3,null],[11,"ndim","","Return the number of dimensions (axes) in the array",3,null],[11,"view","","Return a read-only view of the array",3,null],[11,"view_mut","","Return a read-write view of the array",3,null],[11,"to_owned","","Return an uniquely owned copy of the array",3,null],[11,"to_shared","","Return a shared ownership (copy on write) array.",3,null],[11,"into_shared","","Turn the array into a shared ownership (copy on write) array,\nwithout any copying.",3,null],[11,"iter","","Return an iterator of references to the elements of the array.",3,null],[11,"iter_mut","","Return an iterator of mutable references to the elements of the array.",3,null],[11,"indexed_iter","","Return an iterator of indexes and references to the elements of the array.",3,null],[11,"indexed_iter_mut","","Return an iterator of indexes and mutable references to the elements of the array.",3,null],[11,"slice","","Return a sliced array.",3,null],[11,"slice_mut","","Return a sliced read-write view of the array.",3,null],[11,"islice","","Slice the array’s view in place.",3,null],[11,"get","","Return a reference to the element at `index`, or return `None`\nif the index is out of bounds.",3,null],[11,"get_mut","","Return a mutable reference to the element at `index`, or return `None`\nif the index is out of bounds.",3,null],[11,"uget","","Perform *unchecked* array indexing.",3,null],[11,"uget_mut","","Perform *unchecked* array indexing.",3,null],[11,"swap","","Swap elements at indices `index1` and `index2`.",3,null],[11,"subview","","Along `axis`, select the subview `index` and return a\nview with that axis removed.",3,null],[11,"subview_mut","","Along `axis`, select the subview `index` and return a read-write view\nwith the axis removed.",3,null],[11,"isubview","","Collapse dimension `axis` into length one,\nand select the subview of `index` along that axis.",3,null],[11,"into_subview","","Along `axis`, select the subview `index` and return `self`\nwith that axis removed.",3,null],[11,"select","","Along `axis`, select arbitrary subviews corresponding to `indices`\n and and copy them into a new array.",3,null],[11,"inner_iter","","Return an iterator that traverses over all dimensions but the innermost,\nand yields each inner row.",3,null],[11,"inner_iter_mut","","Return an iterator that traverses over all dimensions but the innermost,\nand yields each inner row.",3,null],[11,"outer_iter","","Return an iterator that traverses over the outermost dimension\nand yields each subview.",3,null],[11,"outer_iter_mut","","Return an iterator that traverses over the outermost dimension\nand yields each subview.",3,null],[11,"axis_iter","","Return an iterator that traverses over `axis`\nand yields each subview along it.",3,null],[11,"axis_iter_mut","","Return an iterator that traverses over `axis`\nand yields each mutable subview along it.",3,null],[11,"axis_chunks_iter","","Return an iterator that traverses over `axis` by chunks of `size`,\nyielding non-overlapping views along that axis.",3,null],[11,"axis_chunks_iter_mut","","Return an iterator that traverses over `axis` by chunks of `size`,\nyielding non-overlapping read-write views along that axis.",3,null],[11,"diag","","Return an view of the diagonal elements of the array.",3,null],[11,"diag_mut","","Return a read-write view over the diagonal elements of the array.",3,null],[11,"into_diag","","Return the diagonal as a one-dimensional array.",3,null],[11,"is_standard_layout","","Return `true` if the array data is laid out in contiguous “C order” in\nmemory (where the last index is the most rapidly varying).",3,null],[11,"as_ptr","","Return a pointer to the first element in the array.",3,null],[11,"as_mut_ptr","","Return a mutable pointer to the first element in the array.",3,null],[11,"as_slice","","Return the array’s data as a slice, if it is contiguous and in standard order.\nReturn `None` otherwise.",3,null],[11,"as_slice_mut","","Return the array’s data as a slice, if it is contiguous and in standard order.\nReturn `None` otherwise.",3,null],[11,"as_slice_memory_order","","Return the array’s data as a slice if it is contiguous,\nreturn `None` otherwise.",3,null],[11,"as_slice_memory_order_mut","","Return the array’s data as a slice if it is contiguous,\nreturn `None` otherwise.",3,null],[11,"reshape","","Transform the array into `shape`; any shape with the same number of\nelements is accepted.",3,null],[11,"into_shape","","Transform the array into `shape`; any shape with the same number of\nelements is accepted, but the source array or view must be\ncontiguous, otherwise we cannot rearrange the dimension.",3,null],[11,"broadcast","","Act like a larger size and/or shape array by *broadcasting*\ninto a larger shape, if possible.",3,null],[11,"swap_axes","","Swap axes `ax` and `bx`.",3,null],[11,"reversed_axes","","Transpose the array by reversing axes.",3,null],[11,"t","","Return a transposed view of the array.",3,null],[11,"assign","","Perform an elementwise assigment to `self` from `rhs`.",3,null],[11,"assign_scalar","","Perform an elementwise assigment to `self` from scalar `x`.",3,null],[11,"zip_mut_with","","Traverse two arrays in unspecified order, in lock step,\ncalling the closure `f` on each element pair.",3,null],[11,"fold","","Traverse the array elements and apply a fold,\nreturning the resulting value.",3,null],[11,"map","","Call `f` by reference on each element and create a new array\nwith the new values.",3,null],[11,"mapv","","Call `f` by **v**alue on each element and create a new array\nwith the new values.",3,null],[11,"mapv_into","","Call `f` by **v**alue on each element, update the array with the new values\nand return it.",3,null],[11,"map_inplace","","Modify the array in place by calling `f` by mutable reference on each element.",3,null],[11,"mapv_inplace","","Modify the array in place by calling `f` by **v**alue on each element.\nThe array is updated with the new values.",3,null],[11,"visit","","Visit each element in the array by calling `f` by reference\non each element.",3,null],[11,"fold_axis","","Fold along an axis.",3,null],[11,"map_axis","","Reduce the values along an axis into just one value, producing a new\narray with one less dimension.",3,null],[11,"into_raw_vec","","Return a vector of the elements in the array, in the way they are\nstored internally.",3,null],[11,"row","","Return an array view of row `index`.",3,null],[11,"row_mut","","Return a mutable array view of row `index`.",3,null],[11,"rows","","Return the number of rows (length of `Axis(0)`) in the two-dimensional array.",3,null],[11,"column","","Return an array view of column `index`.",3,null],[11,"column_mut","","Return a mutable array view of column `index`.",3,null],[11,"cols","","Return the number of columns (length of `Axis(1)`) in the two-dimensional array.",3,null],[11,"scalar_sum","","Return the sum of all elements in the array.",3,null],[11,"sum","","Return sum along `axis`.",3,null],[11,"mean","","Return mean along `axis`.",3,null],[11,"all_close","","Return `true` if the arrays&#39; elementwise differences are all within\nthe given absolute tolerance, `false` otherwise.",3,null],[0,"linalg","","Linear algebra.",null,null],[5,"general_mat_mul","ndarray::linalg","General matrix multiplication.",null,{"inputs":[{"name":"a"},{"name":"arraybase"},{"name":"arraybase"},{"name":"a"},{"name":"arraybase"}],"output":null}],[11,"dot","ndarray","Compute the dot product of one-dimensional arrays.",3,null],[11,"dot","","Perform matrix multiplication of rectangular arrays `self` and `rhs`.",3,null],[11,"dot","","",3,null],[11,"dot","","",3,null],[11,"scaled_add","","Perform the operation `self += alpha * rhs` efficiently, where\n`alpha` is a scalar and `rhs` is another array. This operation is\nalso known as `axpy` in BLAS.",3,null],[8,"Dot","ndarray::linalg","Matrix Multiplication",null,null],[16,"Output","","The result of the operation.",19,null],[10,"dot","","",19,null],[11,"add","ndarray","",3,null],[11,"add","","",3,null],[11,"add","","",3,null],[11,"sub","","",3,null],[11,"sub","","",3,null],[11,"sub","","",3,null],[11,"mul","","",3,null],[11,"mul","","",3,null],[11,"mul","","",3,null],[11,"div","","",3,null],[11,"div","","",3,null],[11,"div","","",3,null],[11,"rem","","",3,null],[11,"rem","","",3,null],[11,"rem","","",3,null],[11,"bitand","","",3,null],[11,"bitand","","",3,null],[11,"bitand","","",3,null],[11,"bitor","","",3,null],[11,"bitor","","",3,null],[11,"bitor","","",3,null],[11,"bitxor","","",3,null],[11,"bitxor","","",3,null],[11,"bitxor","","",3,null],[11,"shl","","",3,null],[11,"shl","","",3,null],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"shr","","",3,null],[11,"shr","","",3,null],[11,"neg","","Perform an elementwise negation of `self` and return the result.",3,null],[11,"not","","Perform an elementwise unary not of `self` and return the result.",3,null],[11,"add_assign","","",3,null],[11,"add_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"sub_assign","","",3,null],[11,"mul_assign","","",3,null],[11,"mul_assign","","",3,null],[11,"div_assign","","",3,null],[11,"div_assign","","",3,null],[11,"rem_assign","","",3,null],[11,"rem_assign","","",3,null],[11,"bitand_assign","","",3,null],[11,"bitand_assign","","",3,null],[11,"bitor_assign","","",3,null],[11,"bitor_assign","","",3,null],[11,"bitxor_assign","","",3,null],[11,"bitxor_assign","","",3,null],[11,"shl_assign","","",3,null],[11,"shl_assign","","",3,null],[11,"shr_assign","","",3,null],[11,"shr_assign","","",3,null],[11,"from_shape","","Create a read-only array view borrowing its data from a slice.",3,null],[11,"from_shape_ptr","","Create an `ArrayView&lt;A, D&gt;` from shape information and a\nraw pointer to the elements.",3,null],[11,"split_at","","Split the array along `axis` and return one view strictly before the\nsplit and one view after the split.",3,null],[11,"from_shape","","Create a read-write array view borrowing its data from a slice.",3,null],[11,"from_shape_ptr","","Create an `ArrayViewMut&lt;A, D&gt;` from shape information and a\nraw pointer to the elements.",3,null],[11,"split_at","","Split the array along `axis` and return one mutable view strictly\nbefore the split and one mutable view after the split.",3,null],[6,"Ix0","","zero-dimensionial",null,null],[6,"Ix1","","one-dimensional",null,null],[6,"Ix2","","two-dimensional",null,null],[6,"Ix3","","three-dimensional",null,null],[6,"Ix4","","four-dimensional",null,null],[6,"IxDyn","","dynamic-dimensional",null,null],[6,"Array0","","zero-dimensional array",null,null],[6,"Array1","","one-dimensional array",null,null],[6,"Array2","","two-dimensional array",null,null],[6,"Array3","","three-dimensional array",null,null],[6,"Array4","","four-dimensional array",null,null],[6,"ArrayD","","dynamic-dimensional array",null,null],[6,"ArrayView0","","zero-dimensional array view",null,null],[6,"ArrayView1","","one-dimensional array view",null,null],[6,"ArrayView2","","two-dimensional array view",null,null],[6,"ArrayView3","","three-dimensional array view",null,null],[6,"ArrayView4","","four-dimensional array view",null,null],[6,"ArrayViewD","","dynamic-dimensional array view",null,null],[6,"ArrayViewMut0","","zero-dimensional read-write array view",null,null],[6,"ArrayViewMut1","","one-dimensional read-write array view",null,null],[6,"ArrayViewMut2","","two-dimensional read-write array view",null,null],[6,"ArrayViewMut3","","three-dimensional read-write array view",null,null],[6,"ArrayViewMut4","","four-dimensional read-write array view",null,null],[6,"ArrayViewMutD","","dynamic-dimensional read-write array view",null,null],[6,"Ix","","Array index type",null,null],[6,"Ixs","","Array index type (signed)",null,null],[6,"RcArray","","Array where the data is reference counted and copy on write, it\ncan act as both an owner as the data as well as a lightweight view.",null,null],[6,"Array","","Array where the data is owned uniquely.",null,null],[6,"OwnedArray","","Array where the data is owned uniquely.",null,null],[6,"ArrayView","","A lightweight array view.",null,null],[6,"ArrayViewMut","","A lightweight read-write array view.",null,null],[17,"S","","Slice value for the full range of an axis.",null,null],[8,"Dimension","","Array shape and index trait.",null,null],[16,"SliceArg","","`SliceArg` is the type which is used to specify slicing for this\ndimension.",20,null],[8,"RemoveAxis","","Array shape with a next smaller dimension.",null,null],[16,"Smaller","","",21,null],[10,"remove_axis","","",21,null],[8,"NdIndex","","Tuple or fixed size arrays that can be used to index an array.",null,null],[16,"Dim","","",22,null],[8,"AsArray","","Argument conversion into an array view",null,null],[8,"LinalgScalar","","Elements that support linear algebra operations.",null,null],[8,"NdFloat","","Floating-point element types `f32` and `f64`.",null,null],[8,"ShapeBuilder","","A trait for `Shape` and `D where D: Dimension` that allows\ncustomizing the memory layout (strides) of an array shape.",null,null],[16,"Dim","","",23,null],[10,"f","","",23,null],[10,"set_f","","",23,null],[10,"strides","","",23,null],[8,"Data","","Array representation trait.",null,null],[16,"Elem","","The array element type.",24,null],[8,"DataMut","","Array representation trait.",null,null],[8,"DataOwned","","Array representation trait.",null,null],[8,"DataShared","","Array representation trait.",null,null],[8,"DataClone","","Array representation trait.",null,null],[8,"FixedInitializer","","Fixed-size array used for array initialization",null,null],[16,"Elem","","",25,null],[10,"as_init_slice","","",25,null],[10,"len","","",25,{"inputs":[],"output":{"name":"usize"}}],[8,"ScalarOperand","","Elements that can be used as direct operands in arithmetic with arrays.",null,null],[11,"clone","","",4,null],[11,"clone","","",7,null],[11,"fmt","","",17,null],[11,"clone","","",17,null],[11,"fmt","","",18,null],[11,"clone","","",18,null],[14,"s!","","Slice argument constructor.",null,null],[14,"stack!","","Stack arrays along the given axis.",null,null],[11,"into_iter","","",26,null],[11,"into_iter","","",27,null],[11,"ndim","","",28,null],[11,"size","","",28,null],[11,"size_checked","","",28,null],[11,"default_strides","","",28,null],[11,"_fastest_varying_stride_order","","",28,null],[11,"first_index","","",28,null],[11,"next_for","","",28,null],[11,"stride_offset","","Self is an index, return the stride offset",28,{"inputs":[{"name":"ix"},{"name":"ix"}],"output":{"name":"isize"}}],[11,"stride_offset_checked","","Return stride offset for this dimension and index.",28,null],[11,"remove_axis","","",28,null]],"paths":[[3,"Axis"],[3,"Si"],[4,"ErrorKind"],[3,"ArrayBase"],[3,"ViewRepr"],[3,"Indexes"],[3,"Elements"],[3,"Indexed"],[3,"ElementsMut"],[3,"IndexedMut"],[3,"InnerIter"],[3,"InnerIterMut"],[3,"AxisIter"],[3,"AxisIterMut"],[3,"AxisChunksIter"],[3,"AxisChunksIterMut"],[3,"ShapeError"],[3,"Shape"],[3,"StrideShape"],[8,"Dot"],[8,"Dimension"],[8,"RemoveAxis"],[8,"NdIndex"],[8,"ShapeBuilder"],[8,"Data"],[8,"FixedInitializer"],[6,"ArrayView"],[6,"ArrayViewMut"],[6,"Ix"]]};
searchIndex["num_bigint"] = {"doc":"A Big integer (signed version: `BigInt`, unsigned version: `BigUint`).","items":[[3,"BigUint","num_bigint","A big unsigned integer type.",null,null],[3,"BigInt","","A big signed integer type.",null,null],[4,"ParseBigIntError","","",null,null],[13,"ParseInt","","",0,null],[13,"Other","","",0,null],[4,"Sign","","A Sign is a `BigInt`&#39;s composing element.",null,null],[13,"Minus","","",1,null],[13,"NoSign","","",1,null],[13,"Plus","","",1,null],[11,"hash","","",2,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"decode","","",2,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",2,null],[11,"eq","","",2,null],[11,"partial_cmp","","",2,null],[11,"cmp","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"biguint"}}],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"from_str","","",2,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from_str_radix","","Creates and initializes a `BigUint`.",2,{"inputs":[{"name":"str"},{"name":"u32"}],"output":{"name":"result"}}],[11,"bitand","","",2,null],[11,"bitand","","",2,null],[11,"bitor","","",2,null],[11,"bitor","","",2,null],[11,"bitxor","","",2,null],[11,"bitxor","","",2,null],[11,"shl","","",2,null],[11,"shr","","",2,null],[11,"zero","","",2,{"inputs":[],"output":{"name":"biguint"}}],[11,"is_zero","","",2,null],[11,"one","","",2,{"inputs":[],"output":{"name":"biguint"}}],[11,"add","","",2,null],[11,"add","","",2,null],[11,"sub","","",2,null],[11,"sub","","",2,null],[11,"mul","","",2,null],[11,"mul","","",2,null],[11,"div","","",2,null],[11,"div","","",2,null],[11,"rem","","",2,null],[11,"rem","","",2,null],[11,"neg","","",2,null],[11,"checked_add","","",2,null],[11,"checked_sub","","",2,null],[11,"checked_mul","","",2,null],[11,"checked_div","","",2,null],[11,"div_rem","","",2,null],[11,"div_floor","","",2,null],[11,"mod_floor","","",2,null],[11,"div_mod_floor","","",2,null],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",2,null],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",2,null],[11,"divides","","Deprecated, use `is_multiple_of` instead.",2,null],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",2,null],[11,"is_even","","Returns `true` if the number is divisible by `2`.",2,null],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",2,null],[11,"to_i64","","",2,null],[11,"to_u64","","",2,null],[11,"to_f32","","",2,null],[11,"to_f64","","",2,null],[11,"from_i64","","",2,{"inputs":[{"name":"i64"}],"output":{"name":"option"}}],[11,"from_u64","","",2,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_f64","","",2,{"inputs":[{"name":"f64"}],"output":{"name":"option"}}],[11,"from","","",2,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"from","","",2,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[11,"from","","",2,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"from","","",2,{"inputs":[{"name":"u32"}],"output":{"name":"self"}}],[11,"from","","",2,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"to_biguint","","",2,null],[11,"new","","Creates and initializes a `BigUint`.",2,{"inputs":[{"name":"vec"}],"output":{"name":"biguint"}}],[11,"from_slice","","Creates and initializes a `BigUint`.",2,null],[11,"from_bytes_be","","Creates and initializes a `BigUint`.",2,null],[11,"from_bytes_le","","Creates and initializes a `BigUint`.",2,null],[11,"to_bytes_le","","Returns the byte representation of the `BigUint` in little-endian byte order.",2,null],[11,"to_bytes_be","","Returns the byte representation of the `BigUint` in big-endian byte order.",2,null],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix.\n`radix` must be in the range `[2, 36]`.",2,null],[11,"parse_bytes","","Creates and initializes a `BigUint`.",2,null],[11,"bits","","Determines the fewest bits necessary to express the `BigUint`.",2,null],[11,"hash","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"cmp","","",1,null],[11,"partial_cmp","","",1,null],[11,"eq","","",1,null],[11,"decode","","",1,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",1,null],[11,"neg","","Negate Sign value.",1,null],[11,"mul","","",1,null],[11,"hash","","",3,null],[11,"fmt","","",3,null],[11,"clone","","",3,null],[11,"decode","","",3,{"inputs":[{"name":"__d"}],"output":{"name":"result"}}],[11,"encode","","",3,null],[11,"eq","","",3,null],[11,"partial_cmp","","",3,null],[11,"cmp","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"bigint"}}],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"from_str","","",3,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"from_str_radix","","Creates and initializes a BigInt.",3,{"inputs":[{"name":"str"},{"name":"u32"}],"output":{"name":"result"}}],[11,"shl","","",3,null],[11,"shr","","",3,null],[11,"zero","","",3,{"inputs":[],"output":{"name":"bigint"}}],[11,"is_zero","","",3,null],[11,"one","","",3,{"inputs":[],"output":{"name":"bigint"}}],[11,"abs","","",3,null],[11,"abs_sub","","",3,null],[11,"signum","","",3,null],[11,"is_positive","","",3,null],[11,"is_negative","","",3,null],[11,"add","","",3,null],[11,"add","","",3,null],[11,"sub","","",3,null],[11,"sub","","",3,null],[11,"mul","","",3,null],[11,"mul","","",3,null],[11,"div","","",3,null],[11,"div","","",3,null],[11,"rem","","",3,null],[11,"rem","","",3,null],[11,"neg","","",3,null],[11,"checked_add","","",3,null],[11,"checked_sub","","",3,null],[11,"checked_mul","","",3,null],[11,"checked_div","","",3,null],[11,"div_rem","","",3,null],[11,"div_floor","","",3,null],[11,"mod_floor","","",3,null],[11,"div_mod_floor","","",3,null],[11,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`.",3,null],[11,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",3,null],[11,"divides","","Deprecated, use `is_multiple_of` instead.",3,null],[11,"is_multiple_of","","Returns `true` if the number is a multiple of `other`.",3,null],[11,"is_even","","Returns `true` if the number is divisible by `2`.",3,null],[11,"is_odd","","Returns `true` if the number is not divisible by `2`.",3,null],[11,"to_i64","","",3,null],[11,"to_u64","","",3,null],[11,"to_f32","","",3,null],[11,"to_f64","","",3,null],[11,"from_i64","","",3,{"inputs":[{"name":"i64"}],"output":{"name":"option"}}],[11,"from_u64","","",3,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_f64","","",3,{"inputs":[{"name":"f64"}],"output":{"name":"option"}}],[11,"from","","",3,{"inputs":[{"name":"i64"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"i8"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"i16"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"i32"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"isize"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"u32"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from","","",3,{"inputs":[{"name":"biguint"}],"output":{"name":"self"}}],[11,"to_bigint","","",3,null],[11,"to_bigint","","",2,null],[11,"to_biguint","","",3,null],[11,"new","","Creates and initializes a BigInt.",3,{"inputs":[{"name":"sign"},{"name":"vec"}],"output":{"name":"bigint"}}],[11,"from_biguint","","Creates and initializes a `BigInt`.",3,{"inputs":[{"name":"sign"},{"name":"biguint"}],"output":{"name":"bigint"}}],[11,"from_slice","","Creates and initializes a `BigInt`.",3,null],[11,"from_bytes_be","","Creates and initializes a `BigInt`.",3,null],[11,"from_bytes_le","","Creates and initializes a `BigInt`.",3,null],[11,"to_bytes_le","","Returns the sign and the byte representation of the `BigInt` in little-endian byte order.",3,null],[11,"to_bytes_be","","Returns the sign and the byte representation of the `BigInt` in big-endian byte order.",3,null],[11,"to_str_radix","","Returns the integer formatted as a string in the given radix.\n`radix` must be in the range `[2, 36]`.",3,null],[11,"sign","","Returns the sign of the `BigInt` as a `Sign`.",3,null],[11,"parse_bytes","","Creates and initializes a `BigInt`.",3,null],[11,"bits","","Determines the fewest bits necessary to express the `BigInt`,\nnot including the sign.",3,null],[11,"to_biguint","","Converts this `BigInt` into a `BigUint`, if it&#39;s not negative.",3,null],[11,"checked_add","","",3,null],[11,"checked_sub","","",3,null],[11,"checked_mul","","",3,null],[11,"checked_div","","",3,null],[0,"big_digit","","",null,null],[5,"from_doublebigdigit","num_bigint::big_digit","Split one `DoubleBigDigit` into two `BigDigit`s.",null,null],[5,"to_doublebigdigit","","Join two `BigDigit`s into one `DoubleBigDigit`",null,{"inputs":[{"name":"bigdigit"},{"name":"bigdigit"}],"output":{"name":"doublebigdigit"}}],[6,"BigDigit","","A `BigDigit` is a `BigUint`&#39;s composing element.",null,null],[6,"DoubleBigDigit","","A `DoubleBigDigit` is the internal type used to do the computations.  Its\nsize is the double of the size of `BigDigit`.",null,null],[17,"ZERO_BIG_DIGIT","","",null,null],[17,"BITS","","",null,null],[17,"BASE","","",null,null],[6,"BigDigit","num_bigint","A `BigDigit` is a `BigUint`&#39;s composing element.",null,null],[6,"DoubleBigDigit","","A `DoubleBigDigit` is the internal type used to do the computations.  Its\nsize is the double of the size of `BigDigit`.",null,null],[17,"ZERO_BIG_DIGIT","","",null,null],[8,"ToBigUint","","A generic trait for converting a value to a `BigUint`.",null,null],[10,"to_biguint","","Converts the value of `self` to a `BigUint`.",4,null],[8,"ToBigInt","","A generic trait for converting a value to a `BigInt`.",null,null],[10,"to_bigint","","Converts the value of `self` to a `BigInt`.",5,null],[8,"RandBigInt","","",null,null],[10,"gen_biguint","","Generate a random `BigUint` of the given bit size.",6,null],[10,"gen_bigint","","Generate a random BigInt of the given bit size.",6,null],[10,"gen_biguint_below","","Generate a random `BigUint` less than the given bound. Fails\nwhen the bound is zero.",6,null],[10,"gen_biguint_range","","Generate a random `BigUint` within the given range. The lower\nbound is inclusive; the upper bound is exclusive. Fails when\nthe upper bound is not greater than the lower bound.",6,null],[10,"gen_bigint_range","","Generate a random `BigInt` within the given range. The lower\nbound is inclusive; the upper bound is exclusive. Fails when\nthe upper bound is not greater than the lower bound.",6,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"fmt","","",0,null],[11,"fmt","","",0,null],[11,"description","","",0,null],[11,"from","","",0,{"inputs":[{"name":"parseinterror"}],"output":{"name":"parsebiginterror"}}]],"paths":[[4,"ParseBigIntError"],[4,"Sign"],[3,"BigUint"],[3,"BigInt"],[8,"ToBigUint"],[8,"ToBigInt"],[8,"RandBigInt"]]};
searchIndex["rand"] = {"doc":"Utilities for random number generation","items":[[3,"Generator","rand","Iterator which will generate a stream of random items.",null,null],[3,"AsciiGenerator","","Iterator which will continuously generate random ascii characters.",null,null],[3,"XorShiftRng","","An Xorshift[1] random number\ngenerator.",null,null],[3,"Open01","","A wrapper for generating floating point numbers uniformly in the\nopen interval `(0,1)` (not including either endpoint).",null,null],[12,"0","","",0,null],[3,"Closed01","","A wrapper for generating floating point numbers uniformly in the\nclosed interval `[0,1]` (including both endpoints).",null,null],[12,"0","","",1,null],[3,"StdRng","","The standard RNG. This is designed to be efficient on the current\nplatform.",null,null],[3,"ThreadRng","","The thread-local RNG.",null,null],[5,"weak_rng","","Create a weak random number generator with a default algorithm and seed.",null,{"inputs":[],"output":{"name":"xorshiftrng"}}],[5,"thread_rng","","Retrieve the lazily-initialized thread-local random number\ngenerator, seeded by the system. Intended to be used in method\nchaining style, e.g. `thread_rng().gen::&lt;i32&gt;()`.",null,{"inputs":[],"output":{"name":"threadrng"}}],[5,"random","","Generates a random value using the thread-local random number generator.",null,{"inputs":[],"output":{"name":"t"}}],[5,"sample","","Randomly sample up to `amount` elements from an iterator.",null,{"inputs":[{"name":"r"},{"name":"i"},{"name":"usize"}],"output":{"name":"vec"}}],[0,"distributions","","Sampling from random distributions.",null,null],[3,"RandSample","rand::distributions","A wrapper for generating types that implement `Rand` via the\n`Sample` &amp; `IndependentSample` traits.",null,null],[3,"Weighted","","A value with a particular weight for use with `WeightedChoice`.",null,null],[12,"weight","","The numerical weight of this item",2,null],[12,"item","","The actual item which is being weighted",2,null],[3,"WeightedChoice","","A distribution that selects from a finite collection of weighted items.",null,null],[0,"range","","Generating numbers between two others.",null,null],[3,"Range","rand::distributions::range","Sample values uniformly between two bounds.",null,null],[8,"SampleRange","","The helper trait for types that have a sensible way to sample\nuniformly between two values. This should not be used directly,\nand is only to facilitate `Range`.",null,null],[10,"construct_range","","Construct the `Range` object that `sample_range`\nrequires. This should not ever be called directly, only via\n`Range::new`, which will check that `low &lt; high`, so this\nfunction doesn&#39;t have to repeat the check.",3,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"range"}}],[10,"sample_range","","Sample a value from the given `Range` with the given `Rng` as\na source of randomness.",3,{"inputs":[{"name":"range"},{"name":"r"}],"output":{"name":"self"}}],[11,"clone","","",4,null],[11,"new","","Create a new `Range` instance that samples uniformly from\n`[low, high)`. Panics if `low &gt;= high`.",4,{"inputs":[{"name":"x"},{"name":"x"}],"output":{"name":"range"}}],[11,"sample","","",4,null],[11,"ind_sample","","",4,null],[0,"gamma","rand::distributions","The Gamma and derived distributions.",null,null],[3,"Gamma","rand::distributions::gamma","The Gamma distribution `Gamma(shape, scale)` distribution.",null,null],[3,"ChiSquared","","The chi-squared distribution `χ²(k)`, where `k` is the degrees of\nfreedom.",null,null],[3,"FisherF","","The Fisher F distribution `F(m, n)`.",null,null],[3,"StudentT","","The Student t distribution, `t(nu)`, where `nu` is the degrees of\nfreedom.",null,null],[11,"clone","","",5,null],[11,"new","","Construct an object representing the `Gamma(shape, scale)`\ndistribution.",5,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"gamma"}}],[11,"sample","","",5,null],[11,"ind_sample","","",5,null],[11,"clone","","",6,null],[11,"new","","Create a new chi-squared distribution with degrees-of-freedom\n`k`. Panics if `k &lt; 0`.",6,{"inputs":[{"name":"f64"}],"output":{"name":"chisquared"}}],[11,"sample","","",6,null],[11,"ind_sample","","",6,null],[11,"clone","","",7,null],[11,"new","","Create a new `FisherF` distribution, with the given\nparameter. Panics if either `m` or `n` are not positive.",7,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"fisherf"}}],[11,"sample","","",7,null],[11,"ind_sample","","",7,null],[11,"clone","","",8,null],[11,"new","","Create a new Student t distribution with `n` degrees of\nfreedom. Panics if `n &lt;= 0`.",8,{"inputs":[{"name":"f64"}],"output":{"name":"studentt"}}],[11,"sample","","",8,null],[11,"ind_sample","","",8,null],[0,"normal","rand::distributions","The normal and derived distributions.",null,null],[3,"StandardNormal","rand::distributions::normal","A wrapper around an `f64` to generate N(0, 1) random numbers\n(a.k.a.  a standard normal, or Gaussian).",null,null],[12,"0","","",9,null],[3,"Normal","","The normal distribution `N(mean, std_dev**2)`.",null,null],[3,"LogNormal","","The log-normal distribution `ln N(mean, std_dev**2)`.",null,null],[11,"clone","","",9,null],[11,"rand","","",9,{"inputs":[{"name":"r"}],"output":{"name":"standardnormal"}}],[11,"clone","","",10,null],[11,"new","","Construct a new `Normal` distribution with the given mean and\nstandard deviation.",10,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"normal"}}],[11,"sample","","",10,null],[11,"ind_sample","","",10,null],[11,"clone","","",11,null],[11,"new","","Construct a new `LogNormal` distribution with the given mean\nand standard deviation.",11,{"inputs":[{"name":"f64"},{"name":"f64"}],"output":{"name":"lognormal"}}],[11,"sample","","",11,null],[11,"ind_sample","","",11,null],[0,"exponential","rand::distributions","The exponential distribution.",null,null],[3,"Exp1","rand::distributions::exponential","A wrapper around an `f64` to generate Exp(1) random numbers.",null,null],[12,"0","","",12,null],[3,"Exp","","The exponential distribution `Exp(lambda)`.",null,null],[11,"clone","","",12,null],[11,"rand","","",12,{"inputs":[{"name":"r"}],"output":{"name":"exp1"}}],[11,"clone","","",13,null],[11,"new","","Construct a new `Exp` with the given shape parameter\n`lambda`. Panics if `lambda &lt;= 0`.",13,{"inputs":[{"name":"f64"}],"output":{"name":"exp"}}],[11,"sample","","",13,null],[11,"ind_sample","","",13,null],[8,"Sample","rand::distributions","Types that can be used to create a random instance of `Support`.",null,null],[10,"sample","","Generate a random value of `Support`, using `rng` as the\nsource of randomness.",14,null],[8,"IndependentSample","","`Sample`s that do not require keeping track of state.",null,null],[10,"ind_sample","","Generate a random value.",15,null],[11,"clone","","",16,null],[11,"sample","","",16,null],[11,"ind_sample","","",16,null],[11,"new","","",16,{"inputs":[],"output":{"name":"randsample"}}],[11,"clone","","",2,null],[11,"new","","Create a new `WeightedChoice`.",17,null],[11,"sample","","",17,null],[11,"ind_sample","","",17,null],[0,"isaac","rand","The ISAAC random number generator.",null,null],[3,"IsaacRng","rand::isaac","A random number generator that uses the ISAAC algorithm[1].",null,null],[3,"Isaac64Rng","","A random number generator that uses ISAAC-64[1], the 64-bit\nvariant of the ISAAC algorithm.",null,null],[11,"new_unseeded","","Create an ISAAC random number generator using the default\nfixed seed.",18,{"inputs":[],"output":{"name":"isaacrng"}}],[11,"clone","","",18,null],[11,"next_u32","","",18,null],[11,"reseed","","",18,null],[11,"from_seed","","Create an ISAAC random number generator with a seed. This can\nbe any length, although the maximum number of elements used is\n256 and any more will be silently ignored. A generator\nconstructed with a given seed will generate the same sequence\nof values as all other generators constructed with that seed.",18,null],[11,"rand","","",18,{"inputs":[{"name":"r"}],"output":{"name":"isaacrng"}}],[11,"new_unseeded","","Create a 64-bit ISAAC random number generator using the\ndefault fixed seed.",19,{"inputs":[],"output":{"name":"isaac64rng"}}],[11,"clone","","",19,null],[11,"next_u32","","",19,null],[11,"next_u64","","",19,null],[11,"reseed","","",19,null],[11,"from_seed","","Create an ISAAC random number generator with a seed. This can\nbe any length, although the maximum number of elements used is\n256 and any more will be silently ignored. A generator\nconstructed with a given seed will generate the same sequence\nof values as all other generators constructed with that seed.",19,null],[11,"rand","","",19,{"inputs":[{"name":"r"}],"output":{"name":"isaac64rng"}}],[0,"chacha","rand","The ChaCha random number generator.",null,null],[3,"ChaChaRng","rand::chacha","A random number generator that uses the ChaCha20 algorithm [1].",null,null],[11,"clone","","",20,null],[11,"new_unseeded","","Create an ChaCha random number generator using the default\nfixed key of 8 zero words.",20,{"inputs":[],"output":{"name":"chacharng"}}],[11,"set_counter","","Sets the internal 128-bit ChaCha counter to\na user-provided value. This permits jumping\narbitrarily ahead (or backwards) in the pseudorandom stream.",20,null],[11,"next_u32","","",20,null],[11,"reseed","","",20,null],[11,"from_seed","","Create a ChaCha generator from a seed,\nobtained from a variable-length u32 array.\nOnly up to 8 words are used; if less than 8\nwords are used, the remaining are set to zero.",20,null],[11,"rand","","",20,{"inputs":[{"name":"r"}],"output":{"name":"chacharng"}}],[0,"reseeding","rand","A wrapper around another RNG that reseeds it after it\ngenerates a certain number of random bytes.",null,null],[3,"ReseedingRng","rand::reseeding","A wrapper around any RNG which reseeds the underlying RNG after it\nhas generated a certain number of random bytes.",null,null],[12,"reseeder","","Controls the behaviour when reseeding the RNG.",21,null],[3,"ReseedWithDefault","","Reseed an RNG using a `Default` instance. This reseeds by\nreplacing the RNG with the result of a `Default::default` call.",null,null],[8,"Reseeder","","Something that can be used to reseed an RNG via `ReseedingRng`.",null,null],[10,"reseed","","Reseed the given RNG.",22,null],[11,"new","","Create a new `ReseedingRng` with the given parameters.",21,{"inputs":[{"name":"r"},{"name":"u64"},{"name":"rsdr"}],"output":{"name":"reseedingrng"}}],[11,"reseed_if_necessary","","Reseed the internal RNG if the number of bytes that have been\ngenerated exceed the threshold.",21,null],[11,"next_u32","","",21,null],[11,"next_u64","","",21,null],[11,"fill_bytes","","",21,null],[11,"reseed","","",21,null],[11,"from_seed","","Create a new `ReseedingRng` from the given reseeder and\nseed. This uses a default value for `generation_threshold`.",21,null],[11,"clone","","",23,null],[11,"reseed","","",23,null],[11,"default","","",23,{"inputs":[],"output":{"name":"reseedwithdefault"}}],[11,"rand","rand","",0,{"inputs":[{"name":"r"}],"output":{"name":"open01"}}],[11,"rand","","",1,{"inputs":[{"name":"r"}],"output":{"name":"closed01"}}],[11,"rand","","",0,{"inputs":[{"name":"r"}],"output":{"name":"open01"}}],[11,"rand","","",1,{"inputs":[{"name":"r"}],"output":{"name":"closed01"}}],[0,"os","","Interfaces to the operating system provided random number\ngenerators.",null,null],[3,"OsRng","rand::os","A random number generator that retrieves randomness straight from\nthe operating system. Platform sources:",null,null],[11,"new","","Create a new `OsRng`.",24,{"inputs":[],"output":{"name":"result"}}],[11,"next_u32","","",24,null],[11,"next_u64","","",24,null],[11,"fill_bytes","","",24,null],[0,"read","rand","A wrapper around any Read to treat it as an RNG.",null,null],[3,"ReadRng","rand::read","An RNG that reads random bytes straight from a `Read`. This will\nwork best with an infinite reader, but this is not required.",null,null],[11,"new","","Create a new `ReadRng` from a `Read`.",25,{"inputs":[{"name":"r"}],"output":{"name":"readrng"}}],[11,"next_u32","","",25,null],[11,"next_u64","","",25,null],[11,"fill_bytes","","",25,null],[8,"Rand","rand","A type that can be randomly generated using an `Rng`.",null,null],[10,"rand","","Generates a random instance of this type using the specified source of\nrandomness.",26,{"inputs":[{"name":"r"}],"output":{"name":"self"}}],[8,"Rng","","A random number generator.",null,null],[10,"next_u32","","Return the next random u32.",27,null],[11,"next_u64","","Return the next random u64.",27,null],[11,"next_f32","","Return the next random f32 selected from the half-open\ninterval `[0, 1)`.",27,null],[11,"next_f64","","Return the next random f64 selected from the half-open\ninterval `[0, 1)`.",27,null],[11,"fill_bytes","","Fill `dest` with random data.",27,null],[11,"gen","","Return a random value of a `Rand` type.",27,null],[11,"gen_iter","","Return an iterator that will yield an infinite number of randomly\ngenerated items.",27,null],[11,"gen_range","","Generate a random value in the range [`low`, `high`).",27,null],[11,"gen_weighted_bool","","Return a bool with a 1 in n chance of true",27,null],[11,"gen_ascii_chars","","Return an iterator of random characters from the set A-Z,a-z,0-9.",27,null],[11,"choose","","Return a random element from `values`.",27,null],[11,"shuffle","","Shuffle a mutable slice in place.",27,null],[8,"SeedableRng","","A random number generator that can be explicitly seeded to produce\nthe same stream of randomness multiple times.",null,null],[10,"reseed","","Reseed an RNG with the given seed.",28,null],[10,"from_seed","","Create a new RNG with the given seed.",28,{"inputs":[{"name":"seed"}],"output":{"name":"self"}}],[11,"next","","",29,null],[11,"next","","",30,null],[11,"clone","","",31,null],[11,"new_unseeded","","Creates a new XorShiftRng instance which is not seeded.",31,{"inputs":[],"output":{"name":"xorshiftrng"}}],[11,"next_u32","","",31,null],[11,"reseed","","Reseed an XorShiftRng. This will panic if `seed` is entirely 0.",31,null],[11,"from_seed","","Create a new XorShiftRng. This will panic if `seed` is entirely 0.",31,null],[11,"rand","","",31,{"inputs":[{"name":"r"}],"output":{"name":"xorshiftrng"}}],[11,"clone","","",32,null],[11,"new","","Create a randomly seeded instance of `StdRng`.",32,{"inputs":[],"output":{"name":"result"}}],[11,"next_u32","","",32,null],[11,"next_u64","","",32,null],[11,"reseed","","",32,null],[11,"from_seed","","",32,null],[11,"clone","","",33,null],[11,"next_u32","","",33,null],[11,"next_u64","","",33,null],[11,"fill_bytes","","",33,null]],"paths":[[3,"Open01"],[3,"Closed01"],[3,"Weighted"],[8,"SampleRange"],[3,"Range"],[3,"Gamma"],[3,"ChiSquared"],[3,"FisherF"],[3,"StudentT"],[3,"StandardNormal"],[3,"Normal"],[3,"LogNormal"],[3,"Exp1"],[3,"Exp"],[8,"Sample"],[8,"IndependentSample"],[3,"RandSample"],[3,"WeightedChoice"],[3,"IsaacRng"],[3,"Isaac64Rng"],[3,"ChaChaRng"],[3,"ReseedingRng"],[8,"Reseeder"],[3,"ReseedWithDefault"],[3,"OsRng"],[3,"ReadRng"],[8,"Rand"],[8,"Rng"],[8,"SeedableRng"],[3,"Generator"],[3,"AsciiGenerator"],[3,"XorShiftRng"],[3,"StdRng"],[3,"ThreadRng"]]};
searchIndex["rust_htslib"] = {"doc":"Rust-HTSlib provides a high level BAM API.\nReading and writing BAM files is as easy as","items":[[0,"htslib","rust_htslib","",null,null],[3,"Struct___kstring_t","rust_htslib::htslib","",null,null],[12,"l","","",0,null],[12,"m","","",0,null],[12,"s","","",0,null],[3,"Struct_htsFormat","","",null,null],[12,"category","","",1,null],[12,"format","","",1,null],[12,"version","","",1,null],[12,"compression","","",1,null],[12,"compression_level","","",1,null],[12,"specific","","",1,null],[3,"Struct_Unnamed1","","",null,null],[12,"major","","",2,null],[12,"minor","","",2,null],[3,"Struct_Unnamed2","","",null,null],[12,"isbin_isright_isbe_iscram_dummy","","",3,null],[12,"lineno","","",3,null],[12,"line","","",3,null],[12,"_fn","","",3,null],[12,"fn_aux","","",3,null],[12,"fp","","",3,null],[12,"format","","",3,null],[3,"Union_Unnamed3","","",null,null],[12,"_bindgen_data_","","",4,null],[3,"Struct_Unnamed4","","",null,null],[12,"u","","",5,null],[12,"v","","",5,null],[3,"Struct_Unnamed5","","",null,null],[12,"readres_finished_dummy","","",6,null],[12,"tid","","",6,null],[12,"beg","","",6,null],[12,"end","","",6,null],[12,"n_off","","",6,null],[12,"i","","",6,null],[12,"curr_tid","","",6,null],[12,"curr_beg","","",6,null],[12,"curr_end","","",6,null],[12,"curr_off","","",6,null],[12,"off","","",6,null],[12,"readrec","","",6,null],[12,"bins","","",6,null],[3,"Struct_Unnamed6","","",null,null],[12,"n","","",7,null],[12,"m","","",7,null],[12,"a","","",7,null],[3,"Struct_Unnamed7","","",null,null],[12,"n_targets","","",8,null],[12,"ignore_sam_err","","",8,null],[12,"l_text","","",8,null],[12,"target_len","","",8,null],[12,"cigar_tab","","",8,null],[12,"target_name","","",8,null],[12,"text","","",8,null],[12,"sdict","","",8,null],[3,"Struct_Unnamed8","","",null,null],[12,"tid","","",9,null],[12,"pos","","",9,null],[12,"bin","","",9,null],[12,"qual","","",9,null],[12,"l_qname","","",9,null],[12,"flag","","",9,null],[12,"n_cigar","","",9,null],[12,"l_qseq","","",9,null],[12,"mtid","","",9,null],[12,"mpos","","",9,null],[12,"isize","","",9,null],[3,"Struct_Unnamed9","","",null,null],[12,"core","","",10,null],[12,"l_data","","",10,null],[12,"m_data","","",10,null],[12,"data","","",10,null],[12,"id","","",10,null],[3,"Struct_Unnamed10","","",null,null],[12,"b","","",11,null],[12,"qpos","","",11,null],[12,"indel","","",11,null],[12,"level","","",11,null],[12,"isdel_ishead_istail_isrefskip_isaux","","",11,null],[4,"Struct_BGZF","","",null,null],[4,"Struct_cram_fd","","",null,null],[4,"Struct_hFILE","","",null,null],[4,"Struct___hts_idx_t","","",null,null],[4,"Struct___bam_plp_t","","",null,null],[4,"Struct___bam_mplp_t","","",null,null],[5,"bgzf_close","","",null,null],[7,"hts_verbose","","",null,null],[7,"seq_nt16_table","","",null,null],[7,"seq_nt16_str","","",null,null],[7,"seq_nt16_int","","",null,null],[5,"bgzf_open","","",null,null],[5,"hts_version","","",null,null],[5,"hts_detect_format","","",null,null],[5,"hts_format_description","","",null,null],[5,"hts_open","","",null,null],[5,"hts_hopen","","",null,null],[5,"hts_close","","",null,null],[5,"hts_get_format","","",null,null],[5,"hts_set_opt","","",null,null],[5,"hts_getline","","",null,null],[5,"hts_readlines","","",null,null],[5,"hts_readlist","","",null,null],[5,"hts_set_threads","","",null,null],[5,"hts_set_fai_filename","","",null,null],[5,"hts_idx_init","","",null,null],[5,"hts_idx_destroy","","",null,null],[5,"hts_idx_push","","",null,null],[5,"hts_idx_finish","","",null,null],[5,"hts_idx_save","","",null,null],[5,"hts_idx_load","","",null,null],[5,"hts_idx_get_meta","","",null,null],[5,"hts_idx_set_meta","","",null,null],[5,"hts_idx_get_stat","","",null,null],[5,"hts_idx_get_n_no_coor","","",null,null],[5,"hts_parse_reg","","",null,null],[5,"hts_itr_query","","",null,null],[5,"hts_itr_destroy","","",null,null],[5,"hts_itr_querys","","",null,null],[5,"hts_itr_next","","",null,null],[5,"hts_idx_seqnames","","",null,null],[5,"hts_file_type","","",null,null],[5,"bam_hdr_init","","",null,null],[5,"bam_hdr_read","","",null,null],[5,"bam_hdr_write","","",null,null],[5,"bam_hdr_destroy","","",null,null],[5,"bam_name2id","","",null,null],[5,"bam_hdr_dup","","",null,null],[5,"bam_init1","","",null,null],[5,"bam_destroy1","","",null,null],[5,"bam_read1","","",null,null],[5,"bam_write1","","",null,null],[5,"bam_copy1","","",null,null],[5,"bam_dup1","","",null,null],[5,"bam_cigar2qlen","","",null,null],[5,"bam_cigar2rlen","","",null,null],[5,"bam_endpos","","",null,null],[5,"bam_str2flag","","",null,null],[5,"bam_flag2str","","",null,null],[5,"bam_index_build","","",null,null],[5,"sam_index_load","","",null,null],[5,"sam_itr_queryi","","",null,null],[5,"sam_itr_querys","","",null,null],[5,"sam_open_mode","","",null,null],[5,"sam_hdr_parse","","",null,null],[5,"sam_hdr_read","","",null,null],[5,"sam_hdr_write","","",null,null],[5,"sam_parse1","","",null,null],[5,"sam_format1","","",null,null],[5,"sam_read1","","",null,null],[5,"sam_write1","","",null,null],[5,"bam_aux_get","","",null,null],[5,"bam_aux2i","","",null,null],[5,"bam_aux2f","","",null,null],[5,"bam_aux2A","","",null,null],[5,"bam_aux2Z","","",null,null],[5,"bam_aux_append","","",null,null],[5,"bam_aux_del","","",null,null],[5,"bam_plp_init","","",null,null],[5,"bam_plp_destroy","","",null,null],[5,"bam_plp_push","","",null,null],[5,"bam_plp_next","","",null,null],[5,"bam_plp_auto","","",null,null],[5,"bam_plp_set_maxcnt","","",null,null],[5,"bam_plp_reset","","",null,null],[5,"bam_mplp_init","","",null,null],[5,"bam_mplp_init_overlaps","","",null,null],[5,"bam_mplp_destroy","","",null,null],[5,"bam_mplp_set_maxcnt","","",null,null],[5,"bam_mplp_auto","","",null,null],[11,"clone","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"struct___kstring_t"}}],[11,"clone","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"struct_htsformat"}}],[11,"clone","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"struct_unnamed1"}}],[11,"clone","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"struct_unnamed2"}}],[11,"clone","","",4,null],[11,"bgzf","","",4,null],[11,"cram","","",4,null],[11,"hfile","","",4,null],[11,"voidp","","",4,null],[11,"default","","",4,{"inputs":[],"output":{"name":"union_unnamed3"}}],[11,"clone","","",5,null],[11,"default","","",5,{"inputs":[],"output":{"name":"struct_unnamed4"}}],[11,"clone","","",6,null],[11,"default","","",6,{"inputs":[],"output":{"name":"struct_unnamed5"}}],[11,"clone","","",7,null],[11,"default","","",7,{"inputs":[],"output":{"name":"struct_unnamed6"}}],[11,"clone","","",8,null],[11,"default","","",8,{"inputs":[],"output":{"name":"struct_unnamed7"}}],[11,"clone","","",9,null],[11,"default","","",9,{"inputs":[],"output":{"name":"struct_unnamed8"}}],[11,"clone","","",10,null],[11,"default","","",10,{"inputs":[],"output":{"name":"struct_unnamed9"}}],[11,"clone","","",11,null],[11,"default","","",11,{"inputs":[],"output":{"name":"struct_unnamed10"}}],[0,"vcf","","",null,null],[3,"Struct___kstring_t","rust_htslib::htslib::vcf","",null,null],[12,"l","","",12,null],[12,"m","","",12,null],[12,"s","","",12,null],[3,"Struct_htsFormat","","",null,null],[12,"category","","",13,null],[12,"format","","",13,null],[12,"version","","",13,null],[12,"compression","","",13,null],[12,"compression_level","","",13,null],[12,"specific","","",13,null],[3,"Struct_Unnamed1","","",null,null],[12,"major","","",14,null],[12,"minor","","",14,null],[3,"Struct_Unnamed2","","",null,null],[12,"isbin_isright_isbe_iscram_dummy","","",15,null],[12,"lineno","","",15,null],[12,"line","","",15,null],[12,"_fn","","",15,null],[12,"fn_aux","","",15,null],[12,"fp","","",15,null],[12,"format","","",15,null],[3,"Union_Unnamed3","","",null,null],[12,"_bindgen_data_","","",16,null],[3,"Struct_Unnamed4","","",null,null],[12,"u","","",17,null],[12,"v","","",17,null],[3,"Struct_Unnamed5","","",null,null],[12,"readres_finished_dummy","","",18,null],[12,"tid","","",18,null],[12,"beg","","",18,null],[12,"end","","",18,null],[12,"n_off","","",18,null],[12,"i","","",18,null],[12,"curr_tid","","",18,null],[12,"curr_beg","","",18,null],[12,"curr_end","","",18,null],[12,"curr_off","","",18,null],[12,"off","","",18,null],[12,"readrec","","",18,null],[12,"bins","","",18,null],[3,"Struct_Unnamed6","","",null,null],[12,"n","","",19,null],[12,"m","","",19,null],[12,"a","","",19,null],[3,"Struct_Unnamed7","","",null,null],[12,"__val","","",20,null],[3,"Union_wait","","",null,null],[12,"_bindgen_data_","","",21,null],[3,"Struct_Unnamed8","","",null,null],[12,"_bindgen_bitfield_1_","","",22,null],[3,"Struct_Unnamed9","","",null,null],[12,"_bindgen_bitfield_1_","","",23,null],[3,"Union_Unnamed10","","",null,null],[12,"_bindgen_data_","","",24,null],[3,"Struct_Unnamed11","","",null,null],[12,"quot","","",25,null],[12,"rem","","",25,null],[3,"Struct_Unnamed12","","",null,null],[12,"quot","","",26,null],[12,"rem","","",26,null],[3,"Struct_Unnamed13","","",null,null],[12,"quot","","",27,null],[12,"rem","","",27,null],[3,"Struct_Unnamed14","","",null,null],[12,"__val","","",28,null],[3,"Struct_timespec","","",null,null],[12,"tv_sec","","",29,null],[12,"tv_nsec","","",29,null],[3,"Struct_timeval","","",null,null],[12,"tv_sec","","",30,null],[12,"tv_usec","","",30,null],[3,"Struct_Unnamed15","","",null,null],[12,"__fds_bits","","",31,null],[3,"Union_pthread_attr_t","","",null,null],[12,"_bindgen_data_","","",32,null],[3,"Struct___pthread_internal_list","","",null,null],[12,"__prev","","",33,null],[12,"__next","","",33,null],[3,"Union_Unnamed16","","",null,null],[12,"_bindgen_data_","","",34,null],[3,"Struct___pthread_mutex_s","","",null,null],[12,"__lock","","",35,null],[12,"__count","","",35,null],[12,"__owner","","",35,null],[12,"__nusers","","",35,null],[12,"__kind","","",35,null],[12,"__spins","","",35,null],[12,"__elision","","",35,null],[12,"__list","","",35,null],[3,"Union_Unnamed17","","",null,null],[12,"_bindgen_data_","","",36,null],[3,"Union_Unnamed18","","",null,null],[12,"_bindgen_data_","","",37,null],[3,"Struct_Unnamed19","","",null,null],[12,"__lock","","",38,null],[12,"__futex","","",38,null],[12,"__total_seq","","",38,null],[12,"__wakeup_seq","","",38,null],[12,"__woken_seq","","",38,null],[12,"__mutex","","",38,null],[12,"__nwaiters","","",38,null],[12,"__broadcast_seq","","",38,null],[3,"Union_Unnamed20","","",null,null],[12,"_bindgen_data_","","",39,null],[3,"Union_Unnamed21","","",null,null],[12,"_bindgen_data_","","",40,null],[3,"Struct_Unnamed22","","",null,null],[12,"__lock","","",41,null],[12,"__nr_readers","","",41,null],[12,"__readers_wakeup","","",41,null],[12,"__writer_wakeup","","",41,null],[12,"__nr_readers_queued","","",41,null],[12,"__nr_writers_queued","","",41,null],[12,"__writer","","",41,null],[12,"__shared","","",41,null],[12,"__pad1","","",41,null],[12,"__pad2","","",41,null],[12,"__flags","","",41,null],[3,"Union_Unnamed23","","",null,null],[12,"_bindgen_data_","","",42,null],[3,"Union_Unnamed24","","",null,null],[12,"_bindgen_data_","","",43,null],[3,"Union_Unnamed25","","",null,null],[12,"_bindgen_data_","","",44,null],[3,"Struct_random_data","","",null,null],[12,"fptr","","",45,null],[12,"rptr","","",45,null],[12,"state","","",45,null],[12,"rand_type","","",45,null],[12,"rand_deg","","",45,null],[12,"rand_sep","","",45,null],[12,"end_ptr","","",45,null],[3,"Struct_drand48_data","","",null,null],[12,"__x","","",46,null],[12,"__old_x","","",46,null],[12,"__c","","",46,null],[12,"__init","","",46,null],[12,"__a","","",46,null],[3,"Struct___locale_struct","","",null,null],[12,"__locales","","",47,null],[12,"__ctype_b","","",47,null],[12,"__ctype_tolower","","",47,null],[12,"__ctype_toupper","","",47,null],[12,"__names","","",47,null],[3,"Struct_Unnamed26","","",null,null],[12,"__count","","",48,null],[12,"__value","","",48,null],[3,"Union_Unnamed27","","",null,null],[12,"_bindgen_data_","","",49,null],[3,"Struct_Unnamed28","","",null,null],[12,"__pos","","",50,null],[12,"__state","","",50,null],[3,"Struct_Unnamed29","","",null,null],[12,"__pos","","",51,null],[12,"__state","","",51,null],[3,"Struct__IO_marker","","",null,null],[12,"_next","","",52,null],[12,"_sbuf","","",52,null],[12,"_pos","","",52,null],[3,"Struct__IO_FILE","","",null,null],[12,"_flags","","",53,null],[12,"_IO_read_ptr","","",53,null],[12,"_IO_read_end","","",53,null],[12,"_IO_read_base","","",53,null],[12,"_IO_write_base","","",53,null],[12,"_IO_write_ptr","","",53,null],[12,"_IO_write_end","","",53,null],[12,"_IO_buf_base","","",53,null],[12,"_IO_buf_end","","",53,null],[12,"_IO_save_base","","",53,null],[12,"_IO_backup_base","","",53,null],[12,"_IO_save_end","","",53,null],[12,"_markers","","",53,null],[12,"_chain","","",53,null],[12,"_fileno","","",53,null],[12,"_flags2","","",53,null],[12,"_old_offset","","",53,null],[12,"_cur_column","","",53,null],[12,"_vtable_offset","","",53,null],[12,"_shortbuf","","",53,null],[12,"_lock","","",53,null],[12,"_offset","","",53,null],[12,"__pad1","","",53,null],[12,"__pad2","","",53,null],[12,"__pad3","","",53,null],[12,"__pad4","","",53,null],[12,"__pad5","","",53,null],[12,"_mode","","",53,null],[12,"_unused2","","",53,null],[3,"Struct_Unnamed30","","",null,null],[12,"tab","","",54,null],[12,"sep","","",54,null],[12,"finished","","",54,null],[12,"p","","",54,null],[3,"Struct_Unnamed31","","",null,null],[12,"_type","","",55,null],[12,"key","","",55,null],[12,"value","","",55,null],[12,"nkeys","","",55,null],[12,"keys","","",55,null],[12,"vals","","",55,null],[3,"Struct_Unnamed32","","",null,null],[12,"info","","",56,null],[12,"hrec","","",56,null],[12,"id","","",56,null],[3,"Struct_Unnamed33","","",null,null],[12,"key","","",57,null],[12,"val","","",57,null],[3,"Struct_Unnamed34","","",null,null],[12,"n","","",58,null],[12,"id","","",58,null],[12,"dict","","",58,null],[12,"samples","","",58,null],[12,"hrec","","",58,null],[12,"nhrec","","",58,null],[12,"dirty","","",58,null],[12,"ntransl","","",58,null],[12,"transl","","",58,null],[12,"nsamples_ori","","",58,null],[12,"keep_samples","","",58,null],[12,"mem","","",58,null],[3,"Struct_Unnamed35","","",null,null],[12,"_type","","",59,null],[12,"n","","",59,null],[3,"Struct_Unnamed36","","",null,null],[12,"id","","",60,null],[12,"n","","",60,null],[12,"size","","",60,null],[12,"_type","","",60,null],[12,"p","","",60,null],[12,"p_len","","",60,null],[12,"p_off_p_free","","",60,null],[3,"Struct_Unnamed37","","",null,null],[12,"key","","",61,null],[12,"_type","","",61,null],[12,"len","","",61,null],[12,"v1","","",61,null],[12,"vptr","","",61,null],[12,"vptr_len","","",61,null],[12,"vptr_off_vptr_free","","",61,null],[3,"Union_Unnamed38","","",null,null],[12,"_bindgen_data_","","",62,null],[3,"Struct_Unnamed39","","",null,null],[12,"m_fmt","","",63,null],[12,"m_info","","",63,null],[12,"m_id","","",63,null],[12,"m_als","","",63,null],[12,"m_allele","","",63,null],[12,"m_flt","","",63,null],[12,"n_flt","","",63,null],[12,"flt","","",63,null],[12,"id","","",63,null],[12,"als","","",63,null],[12,"allele","","",63,null],[12,"info","","",63,null],[12,"fmt","","",63,null],[12,"var","","",63,null],[12,"n_var","","",63,null],[12,"var_type","","",63,null],[12,"shared_dirty","","",63,null],[12,"indiv_dirty","","",63,null],[3,"Struct_Unnamed40","","",null,null],[12,"rid","","",64,null],[12,"pos","","",64,null],[12,"rlen","","",64,null],[12,"qual","","",64,null],[12,"n_info","","",64,null],[12,"n_allele","","",64,null],[12,"n_fmt_n_sample","","",64,null],[12,"shared","","",64,null],[12,"indiv","","",64,null],[12,"d","","",64,null],[12,"max_unpack","","",64,null],[12,"unpacked","","",64,null],[12,"unpack_size","","",64,null],[12,"errcode","","",64,null],[3,"Struct___va_list_tag","","",null,null],[12,"gp_offset","","",65,null],[12,"fp_offset","","",65,null],[12,"overflow_arg_area","","",65,null],[12,"reg_save_area","","",65,null],[4,"Struct_BGZF","","",null,null],[4,"Struct_cram_fd","","",null,null],[4,"Struct_hFILE","","",null,null],[4,"Struct___hts_idx_t","","",null,null],[4,"Struct___locale_data","","",null,null],[4,"Struct__IO_jump_t","","",null,null],[4,"Struct__IO_FILE_plus","","",null,null],[5,"bcf_read1_core","","",null,null],[7,"hts_verbose","","",null,null],[7,"seq_nt16_table","","",null,null],[7,"seq_nt16_str","","",null,null],[7,"seq_nt16_int","","",null,null],[7,"_IO_2_1_stdin_","","",null,null],[7,"_IO_2_1_stdout_","","",null,null],[7,"_IO_2_1_stderr_","","",null,null],[7,"stdin","","",null,null],[7,"stdout","","",null,null],[7,"stderr","","",null,null],[7,"sys_nerr","","",null,null],[7,"sys_errlist","","",null,null],[7,"bcf_type_shift","","",null,null],[7,"bcf_float_vector_end","","",null,null],[7,"bcf_float_missing","","",null,null],[5,"__assert_fail","","",null,null],[5,"__assert_perror_fail","","",null,null],[5,"__assert","","",null,null],[5,"hts_version","","",null,null],[5,"hts_detect_format","","",null,null],[5,"hts_format_description","","",null,null],[5,"hts_open","","",null,null],[5,"hts_hopen","","",null,null],[5,"hts_close","","",null,null],[5,"hts_get_format","","",null,null],[5,"hts_set_opt","","",null,null],[5,"hts_getline","","",null,null],[5,"hts_readlines","","",null,null],[5,"hts_readlist","","",null,null],[5,"hts_set_threads","","",null,null],[5,"hts_set_fai_filename","","",null,null],[5,"hts_idx_init","","",null,null],[5,"hts_idx_destroy","","",null,null],[5,"hts_idx_push","","",null,null],[5,"hts_idx_finish","","",null,null],[5,"hts_idx_save","","",null,null],[5,"hts_idx_load","","",null,null],[5,"hts_idx_get_meta","","",null,null],[5,"hts_idx_set_meta","","",null,null],[5,"hts_idx_get_stat","","",null,null],[5,"hts_idx_get_n_no_coor","","",null,null],[5,"hts_parse_reg","","",null,null],[5,"hts_itr_query","","",null,null],[5,"hts_itr_destroy","","",null,null],[5,"hts_itr_querys","","",null,null],[5,"hts_itr_next","","",null,null],[5,"hts_idx_seqnames","","",null,null],[5,"hts_file_type","","",null,null],[5,"__ctype_get_mb_cur_max","","",null,null],[5,"atof","","",null,null],[5,"atoi","","",null,null],[5,"atol","","",null,null],[5,"atoll","","",null,null],[5,"strtod","","",null,null],[5,"strtof","","",null,null],[5,"strtold","","",null,null],[5,"strtol","","",null,null],[5,"strtoul","","",null,null],[5,"strtoq","","",null,null],[5,"strtouq","","",null,null],[5,"strtoll","","",null,null],[5,"strtoull","","",null,null],[5,"l64a","","",null,null],[5,"a64l","","",null,null],[5,"select","","",null,null],[5,"pselect","","",null,null],[5,"gnu_dev_major","","",null,null],[5,"gnu_dev_minor","","",null,null],[5,"gnu_dev_makedev","","",null,null],[5,"random","","",null,null],[5,"srandom","","",null,null],[5,"initstate","","",null,null],[5,"setstate","","",null,null],[5,"random_r","","",null,null],[5,"srandom_r","","",null,null],[5,"initstate_r","","",null,null],[5,"setstate_r","","",null,null],[5,"rand","","",null,null],[5,"srand","","",null,null],[5,"rand_r","","",null,null],[5,"drand48","","",null,null],[5,"erand48","","",null,null],[5,"lrand48","","",null,null],[5,"nrand48","","",null,null],[5,"mrand48","","",null,null],[5,"jrand48","","",null,null],[5,"srand48","","",null,null],[5,"seed48","","",null,null],[5,"lcong48","","",null,null],[5,"drand48_r","","",null,null],[5,"erand48_r","","",null,null],[5,"lrand48_r","","",null,null],[5,"nrand48_r","","",null,null],[5,"mrand48_r","","",null,null],[5,"jrand48_r","","",null,null],[5,"srand48_r","","",null,null],[5,"seed48_r","","",null,null],[5,"lcong48_r","","",null,null],[5,"malloc","","",null,null],[5,"calloc","","",null,null],[5,"realloc","","",null,null],[5,"free","","",null,null],[5,"cfree","","",null,null],[5,"alloca","","",null,null],[5,"valloc","","",null,null],[5,"posix_memalign","","",null,null],[5,"abort","","",null,null],[5,"atexit","","",null,null],[5,"on_exit","","",null,null],[5,"exit","","",null,null],[5,"_Exit","","",null,null],[5,"getenv","","",null,null],[5,"putenv","","",null,null],[5,"setenv","","",null,null],[5,"unsetenv","","",null,null],[5,"clearenv","","",null,null],[5,"mktemp","","",null,null],[5,"mkstemp","","",null,null],[5,"mkstemps","","",null,null],[5,"mkdtemp","","",null,null],[5,"system","","",null,null],[5,"realpath","","",null,null],[5,"bsearch","","",null,null],[5,"qsort","","",null,null],[5,"abs","","",null,null],[5,"labs","","",null,null],[5,"llabs","","",null,null],[5,"div","","",null,null],[5,"ldiv","","",null,null],[5,"lldiv","","",null,null],[5,"ecvt","","",null,null],[5,"fcvt","","",null,null],[5,"gcvt","","",null,null],[5,"qecvt","","",null,null],[5,"qfcvt","","",null,null],[5,"qgcvt","","",null,null],[5,"ecvt_r","","",null,null],[5,"fcvt_r","","",null,null],[5,"qecvt_r","","",null,null],[5,"qfcvt_r","","",null,null],[5,"mblen","","",null,null],[5,"mbtowc","","",null,null],[5,"wctomb","","",null,null],[5,"mbstowcs","","",null,null],[5,"wcstombs","","",null,null],[5,"rpmatch","","",null,null],[5,"getsubopt","","",null,null],[5,"getloadavg","","",null,null],[5,"memcpy","","",null,null],[5,"memmove","","",null,null],[5,"memccpy","","",null,null],[5,"memset","","",null,null],[5,"memcmp","","",null,null],[5,"memchr","","",null,null],[5,"strcpy","","",null,null],[5,"strncpy","","",null,null],[5,"strcat","","",null,null],[5,"strncat","","",null,null],[5,"strcmp","","",null,null],[5,"strncmp","","",null,null],[5,"strcoll","","",null,null],[5,"strxfrm","","",null,null],[5,"strcoll_l","","",null,null],[5,"strxfrm_l","","",null,null],[5,"strdup","","",null,null],[5,"strndup","","",null,null],[5,"strchr","","",null,null],[5,"strrchr","","",null,null],[5,"strcspn","","",null,null],[5,"strspn","","",null,null],[5,"strpbrk","","",null,null],[5,"strstr","","",null,null],[5,"strtok","","",null,null],[5,"__strtok_r","","",null,null],[5,"strtok_r","","",null,null],[5,"strlen","","",null,null],[5,"strnlen","","",null,null],[5,"strerror","","",null,null],[5,"strerror_r","","",null,null],[5,"strerror_l","","",null,null],[5,"__bzero","","",null,null],[5,"bcopy","","",null,null],[5,"bzero","","",null,null],[5,"bcmp","","",null,null],[5,"index","","",null,null],[5,"rindex","","",null,null],[5,"ffs","","",null,null],[5,"strcasecmp","","",null,null],[5,"strncasecmp","","",null,null],[5,"strsep","","",null,null],[5,"strsignal","","",null,null],[5,"__stpcpy","","",null,null],[5,"stpcpy","","",null,null],[5,"__stpncpy","","",null,null],[5,"stpncpy","","",null,null],[5,"__underflow","","",null,null],[5,"__uflow","","",null,null],[5,"__overflow","","",null,null],[5,"_IO_getc","","",null,null],[5,"_IO_putc","","",null,null],[5,"_IO_feof","","",null,null],[5,"_IO_ferror","","",null,null],[5,"_IO_peekc_locked","","",null,null],[5,"_IO_flockfile","","",null,null],[5,"_IO_funlockfile","","",null,null],[5,"_IO_ftrylockfile","","",null,null],[5,"_IO_vfscanf","","",null,null],[5,"_IO_vfprintf","","",null,null],[5,"_IO_padn","","",null,null],[5,"_IO_sgetn","","",null,null],[5,"_IO_seekoff","","",null,null],[5,"_IO_seekpos","","",null,null],[5,"_IO_free_backup_area","","",null,null],[5,"remove","","",null,null],[5,"rename","","",null,null],[5,"renameat","","",null,null],[5,"tmpfile","","",null,null],[5,"tmpnam","","",null,null],[5,"tmpnam_r","","",null,null],[5,"tempnam","","",null,null],[5,"fclose","","",null,null],[5,"fflush","","",null,null],[5,"fflush_unlocked","","",null,null],[5,"fopen","","",null,null],[5,"freopen","","",null,null],[5,"fdopen","","",null,null],[5,"fmemopen","","",null,null],[5,"open_memstream","","",null,null],[5,"setbuf","","",null,null],[5,"setvbuf","","",null,null],[5,"setbuffer","","",null,null],[5,"setlinebuf","","",null,null],[5,"fprintf","","",null,null],[5,"printf","","",null,null],[5,"sprintf","","",null,null],[5,"vfprintf","","",null,null],[5,"vprintf","","",null,null],[5,"vsprintf","","",null,null],[5,"snprintf","","",null,null],[5,"vsnprintf","","",null,null],[5,"vdprintf","","",null,null],[5,"dprintf","","",null,null],[5,"fscanf","","",null,null],[5,"scanf","","",null,null],[5,"sscanf","","",null,null],[5,"vfscanf","","",null,null],[5,"vscanf","","",null,null],[5,"vsscanf","","",null,null],[5,"fgetc","","",null,null],[5,"getc","","",null,null],[5,"getchar","","",null,null],[5,"getc_unlocked","","",null,null],[5,"getchar_unlocked","","",null,null],[5,"fgetc_unlocked","","",null,null],[5,"fputc","","",null,null],[5,"putc","","",null,null],[5,"putchar","","",null,null],[5,"fputc_unlocked","","",null,null],[5,"putc_unlocked","","",null,null],[5,"putchar_unlocked","","",null,null],[5,"getw","","",null,null],[5,"putw","","",null,null],[5,"fgets","","",null,null],[5,"gets","","",null,null],[5,"__getdelim","","",null,null],[5,"getdelim","","",null,null],[5,"getline","","",null,null],[5,"fputs","","",null,null],[5,"puts","","",null,null],[5,"ungetc","","",null,null],[5,"fread","","",null,null],[5,"fwrite","","",null,null],[5,"fread_unlocked","","",null,null],[5,"fwrite_unlocked","","",null,null],[5,"fseek","","",null,null],[5,"ftell","","",null,null],[5,"rewind","","",null,null],[5,"fseeko","","",null,null],[5,"ftello","","",null,null],[5,"fgetpos","","",null,null],[5,"fsetpos","","",null,null],[5,"clearerr","","",null,null],[5,"feof","","",null,null],[5,"ferror","","",null,null],[5,"clearerr_unlocked","","",null,null],[5,"feof_unlocked","","",null,null],[5,"ferror_unlocked","","",null,null],[5,"perror","","",null,null],[5,"fileno","","",null,null],[5,"fileno_unlocked","","",null,null],[5,"popen","","",null,null],[5,"pclose","","",null,null],[5,"ctermid","","",null,null],[5,"flockfile","","",null,null],[5,"ftrylockfile","","",null,null],[5,"funlockfile","","",null,null],[5,"kvsprintf","","",null,null],[5,"ksprintf","","",null,null],[5,"ksplit_core","","",null,null],[5,"kstrstr","","",null,null],[5,"kstrnstr","","",null,null],[5,"kmemmem","","",null,null],[5,"kstrtok","","",null,null],[5,"bcf_hdr_init","","",null,null],[5,"bcf_hdr_destroy","","",null,null],[5,"bcf_init","","",null,null],[5,"bcf_destroy","","",null,null],[5,"bcf_empty","","",null,null],[5,"bcf_clear","","",null,null],[5,"bcf_hdr_read","","",null,null],[5,"bcf_hdr_set_samples","","",null,null],[5,"bcf_subset_format","","",null,null],[5,"bcf_hdr_write","","",null,null],[5,"vcf_parse","","",null,null],[5,"vcf_format","","",null,null],[5,"bcf_read","","",null,null],[5,"bcf_unpack","","",null,null],[5,"bcf_dup","","",null,null],[5,"bcf_copy","","",null,null],[5,"bcf_write","","",null,null],[5,"vcf_hdr_read","","",null,null],[5,"vcf_hdr_write","","",null,null],[5,"vcf_read","","",null,null],[5,"vcf_write","","",null,null],[5,"bcf_readrec","","",null,null],[5,"bcf_hdr_dup","","",null,null],[5,"bcf_hdr_combine","","",null,null],[5,"bcf_hdr_add_sample","","",null,null],[5,"bcf_hdr_set","","",null,null],[5,"bcf_hdr_fmt_text","","",null,null],[5,"bcf_hdr_append","","",null,null],[5,"bcf_hdr_printf","","",null,null],[5,"bcf_hdr_get_version","","",null,null],[5,"bcf_hdr_set_version","","",null,null],[5,"bcf_hdr_remove","","",null,null],[5,"bcf_hdr_subset","","",null,null],[5,"bcf_hdr_seqnames","","",null,null],[5,"bcf_hdr_parse","","",null,null],[5,"bcf_hdr_sync","","",null,null],[5,"bcf_hdr_parse_line","","",null,null],[5,"bcf_hrec_format","","",null,null],[5,"bcf_hdr_add_hrec","","",null,null],[5,"bcf_hdr_get_hrec","","",null,null],[5,"bcf_hrec_dup","","",null,null],[5,"bcf_hrec_add_key","","",null,null],[5,"bcf_hrec_set_val","","",null,null],[5,"bcf_hrec_find_key","","",null,null],[5,"hrec_add_idx","","",null,null],[5,"bcf_hrec_destroy","","",null,null],[5,"bcf_subset","","",null,null],[5,"bcf_translate","","",null,null],[5,"bcf_get_variant_types","","",null,null],[5,"bcf_get_variant_type","","",null,null],[5,"bcf_is_snp","","",null,null],[5,"bcf_update_filter","","",null,null],[5,"bcf_add_filter","","",null,null],[5,"bcf_remove_filter","","",null,null],[5,"bcf_has_filter","","",null,null],[5,"bcf_update_alleles","","",null,null],[5,"bcf_update_alleles_str","","",null,null],[5,"bcf_update_id","","",null,null],[5,"bcf_update_info","","",null,null],[5,"bcf_update_format_string","","",null,null],[5,"bcf_update_format","","",null,null],[5,"bcf_get_fmt","","",null,null],[5,"bcf_get_info","","",null,null],[5,"bcf_get_fmt_id","","",null,null],[5,"bcf_get_info_id","","",null,null],[5,"bcf_get_info_values","","",null,null],[5,"bcf_get_format_string","","",null,null],[5,"bcf_get_format_values","","",null,null],[5,"bcf_hdr_id2int","","",null,null],[5,"bcf_fmt_array","","",null,null],[5,"bcf_fmt_sized_array","","",null,null],[5,"bcf_enc_vchar","","",null,null],[5,"bcf_enc_vint","","",null,null],[5,"bcf_enc_vfloat","","",null,null],[5,"bcf_index_build","","",null,null],[6,"__int128_t","","",null,null],[6,"__uint128_t","","",null,null],[6,"__builtin_va_list","","",null,null],[6,"int8_t","","",null,null],[6,"int16_t","","",null,null],[6,"int32_t","","",null,null],[6,"int64_t","","",null,null],[6,"uint8_t","","",null,null],[6,"uint16_t","","",null,null],[6,"uint32_t","","",null,null],[6,"uint64_t","","",null,null],[6,"int_least8_t","","",null,null],[6,"int_least16_t","","",null,null],[6,"int_least32_t","","",null,null],[6,"int_least64_t","","",null,null],[6,"uint_least8_t","","",null,null],[6,"uint_least16_t","","",null,null],[6,"uint_least32_t","","",null,null],[6,"uint_least64_t","","",null,null],[6,"int_fast8_t","","",null,null],[6,"int_fast16_t","","",null,null],[6,"int_fast32_t","","",null,null],[6,"int_fast64_t","","",null,null],[6,"uint_fast8_t","","",null,null],[6,"uint_fast16_t","","",null,null],[6,"uint_fast32_t","","",null,null],[6,"uint_fast64_t","","",null,null],[6,"intptr_t","","",null,null],[6,"uintptr_t","","",null,null],[6,"intmax_t","","",null,null],[6,"uintmax_t","","",null,null],[6,"ptrdiff_t","","",null,null],[6,"size_t","","",null,null],[6,"wchar_t","","",null,null],[6,"BGZF","","",null,null],[6,"kstring_t","","",null,null],[6,"Enum_htsFormatCategory","","",null,null],[6,"Enum_htsExactFormat","","",null,null],[6,"Enum_htsCompression","","",null,null],[6,"htsFormat","","",null,null],[6,"htsFile","","",null,null],[6,"Enum_sam_fields","","",null,null],[6,"Enum_cram_option","","",null,null],[6,"hts_idx_t","","",null,null],[6,"hts_pair64_t","","",null,null],[6,"hts_readrec_func","","",null,null],[6,"hts_itr_t","","",null,null],[6,"hts_name2id_f","","",null,null],[6,"hts_id2name_f","","",null,null],[6,"hts_itr_query_func","","",null,null],[6,"__u_char","","",null,null],[6,"__u_short","","",null,null],[6,"__u_int","","",null,null],[6,"__u_long","","",null,null],[6,"__int8_t","","",null,null],[6,"__uint8_t","","",null,null],[6,"__int16_t","","",null,null],[6,"__uint16_t","","",null,null],[6,"__int32_t","","",null,null],[6,"__uint32_t","","",null,null],[6,"__int64_t","","",null,null],[6,"__uint64_t","","",null,null],[6,"__quad_t","","",null,null],[6,"__u_quad_t","","",null,null],[6,"__dev_t","","",null,null],[6,"__uid_t","","",null,null],[6,"__gid_t","","",null,null],[6,"__ino_t","","",null,null],[6,"__ino64_t","","",null,null],[6,"__mode_t","","",null,null],[6,"__nlink_t","","",null,null],[6,"__off_t","","",null,null],[6,"__off64_t","","",null,null],[6,"__pid_t","","",null,null],[6,"__fsid_t","","",null,null],[6,"__clock_t","","",null,null],[6,"__rlim_t","","",null,null],[6,"__rlim64_t","","",null,null],[6,"__id_t","","",null,null],[6,"__time_t","","",null,null],[6,"__useconds_t","","",null,null],[6,"__suseconds_t","","",null,null],[6,"__daddr_t","","",null,null],[6,"__key_t","","",null,null],[6,"__clockid_t","","",null,null],[6,"__timer_t","","",null,null],[6,"__blksize_t","","",null,null],[6,"__blkcnt_t","","",null,null],[6,"__blkcnt64_t","","",null,null],[6,"__fsblkcnt_t","","",null,null],[6,"__fsblkcnt64_t","","",null,null],[6,"__fsfilcnt_t","","",null,null],[6,"__fsfilcnt64_t","","",null,null],[6,"__fsword_t","","",null,null],[6,"__ssize_t","","",null,null],[6,"__syscall_slong_t","","",null,null],[6,"__syscall_ulong_t","","",null,null],[6,"__loff_t","","",null,null],[6,"__qaddr_t","","",null,null],[6,"__caddr_t","","",null,null],[6,"__intptr_t","","",null,null],[6,"__socklen_t","","",null,null],[6,"__WAIT_STATUS","","",null,null],[6,"div_t","","",null,null],[6,"ldiv_t","","",null,null],[6,"lldiv_t","","",null,null],[6,"u_char","","",null,null],[6,"u_short","","",null,null],[6,"u_int","","",null,null],[6,"u_long","","",null,null],[6,"quad_t","","",null,null],[6,"u_quad_t","","",null,null],[6,"fsid_t","","",null,null],[6,"loff_t","","",null,null],[6,"ino_t","","",null,null],[6,"dev_t","","",null,null],[6,"gid_t","","",null,null],[6,"mode_t","","",null,null],[6,"nlink_t","","",null,null],[6,"uid_t","","",null,null],[6,"off_t","","",null,null],[6,"pid_t","","",null,null],[6,"id_t","","",null,null],[6,"ssize_t","","",null,null],[6,"daddr_t","","",null,null],[6,"caddr_t","","",null,null],[6,"key_t","","",null,null],[6,"clock_t","","",null,null],[6,"time_t","","",null,null],[6,"clockid_t","","",null,null],[6,"timer_t","","",null,null],[6,"ulong","","",null,null],[6,"ushort","","",null,null],[6,"_uint","","",null,null],[6,"u_int8_t","","",null,null],[6,"u_int16_t","","",null,null],[6,"u_int32_t","","",null,null],[6,"u_int64_t","","",null,null],[6,"register_t","","",null,null],[6,"__sig_atomic_t","","",null,null],[6,"__sigset_t","","",null,null],[6,"sigset_t","","",null,null],[6,"suseconds_t","","",null,null],[6,"__fd_mask","","",null,null],[6,"fd_set","","",null,null],[6,"fd_mask","","",null,null],[6,"blksize_t","","",null,null],[6,"blkcnt_t","","",null,null],[6,"fsblkcnt_t","","",null,null],[6,"fsfilcnt_t","","",null,null],[6,"pthread_t","","",null,null],[6,"pthread_attr_t","","",null,null],[6,"__pthread_list_t","","",null,null],[6,"pthread_mutex_t","","",null,null],[6,"pthread_mutexattr_t","","",null,null],[6,"pthread_cond_t","","",null,null],[6,"pthread_condattr_t","","",null,null],[6,"pthread_key_t","","",null,null],[6,"pthread_once_t","","",null,null],[6,"pthread_rwlock_t","","",null,null],[6,"pthread_rwlockattr_t","","",null,null],[6,"pthread_spinlock_t","","",null,null],[6,"pthread_barrier_t","","",null,null],[6,"pthread_barrierattr_t","","",null,null],[6,"__compar_fn_t","","",null,null],[6,"__locale_t","","",null,null],[6,"locale_t","","",null,null],[6,"__gnuc_va_list","","",null,null],[6,"va_list","","",null,null],[6,"FILE","","",null,null],[6,"__FILE","","",null,null],[6,"__mbstate_t","","",null,null],[6,"_G_fpos_t","","",null,null],[6,"_G_fpos64_t","","",null,null],[6,"_IO_lock_t","","",null,null],[6,"Enum___codecvt_result","","",null,null],[6,"_IO_FILE","","",null,null],[6,"__io_read_fn","","",null,null],[6,"__io_write_fn","","",null,null],[6,"__io_seek_fn","","",null,null],[6,"__io_close_fn","","",null,null],[6,"fpos_t","","",null,null],[6,"ks_tokaux_t","","",null,null],[6,"bcf_hrec_t","","",null,null],[6,"bcf_idinfo_t","","",null,null],[6,"bcf_idpair_t","","",null,null],[6,"bcf_hdr_t","","",null,null],[6,"variant_t","","",null,null],[6,"bcf_fmt_t","","",null,null],[6,"bcf_info_t","","",null,null],[6,"bcf_dec_t","","",null,null],[6,"bcf1_t","","",null,null],[6,"vcfFile","","",null,null],[6,"__va_list_tag","","",null,null],[17,"BCF_HL_FLT","","",null,null],[17,"BCF_HL_INFO","","",null,null],[17,"BCF_HL_FMT","","",null,null],[17,"BCF_HL_CTG","","",null,null],[17,"BCF_HL_STR","","",null,null],[17,"BCF_HL_GEN","","",null,null],[17,"BCF_HT_FLAG","","",null,null],[17,"BCF_HT_INT","","",null,null],[17,"BCF_HT_REAL","","",null,null],[17,"BCF_HT_STR","","",null,null],[17,"BCF_UN_STR","","",null,null],[17,"BCF_UN_FLT","","",null,null],[17,"BCF_DT_ID","","",null,null],[17,"BCF_DT_CTG","","",null,null],[17,"BCF_DT_SAMPLE","","",null,null],[17,"BCF_VL_FIXED","","",null,null],[17,"BCF_VL_VAR","","",null,null],[17,"BCF_VL_A","","",null,null],[17,"BCF_VL_G","","",null,null],[17,"BCF_VL_R","","",null,null],[17,"unknown_category","","",null,null],[17,"sequence_data","","",null,null],[17,"variant_data","","",null,null],[17,"index_file","","",null,null],[17,"region_list","","",null,null],[17,"category_maximum","","",null,null],[17,"unknown_format","","",null,null],[17,"binary_format","","",null,null],[17,"text_format","","",null,null],[17,"sam","","",null,null],[17,"bam","","",null,null],[17,"bai","","",null,null],[17,"cram","","",null,null],[17,"crai","","",null,null],[17,"vcf","","",null,null],[17,"bcf","","",null,null],[17,"csi","","",null,null],[17,"gzi","","",null,null],[17,"tbi","","",null,null],[17,"bed","","",null,null],[17,"format_maximum","","",null,null],[17,"no_compression","","",null,null],[17,"gzip","","",null,null],[17,"bgzf","","",null,null],[17,"custom","","",null,null],[17,"compression_maximum","","",null,null],[17,"SAM_QNAME","","",null,null],[17,"SAM_FLAG","","",null,null],[17,"SAM_RNAME","","",null,null],[17,"SAM_POS","","",null,null],[17,"SAM_MAPQ","","",null,null],[17,"SAM_CIGAR","","",null,null],[17,"SAM_RNEXT","","",null,null],[17,"SAM_PNEXT","","",null,null],[17,"SAM_TLEN","","",null,null],[17,"SAM_SEQ","","",null,null],[17,"SAM_QUAL","","",null,null],[17,"SAM_AUX","","",null,null],[17,"SAM_RGAUX","","",null,null],[17,"CRAM_OPT_DECODE_MD","","",null,null],[17,"CRAM_OPT_PREFIX","","",null,null],[17,"CRAM_OPT_VERBOSITY","","",null,null],[17,"CRAM_OPT_SEQS_PER_SLICE","","",null,null],[17,"CRAM_OPT_SLICES_PER_CONTAINER","","",null,null],[17,"CRAM_OPT_RANGE","","",null,null],[17,"CRAM_OPT_VERSION","","",null,null],[17,"CRAM_OPT_EMBED_REF","","",null,null],[17,"CRAM_OPT_IGNORE_MD5","","",null,null],[17,"CRAM_OPT_REFERENCE","","",null,null],[17,"CRAM_OPT_MULTI_SEQ_PER_SLICE","","",null,null],[17,"CRAM_OPT_NO_REF","","",null,null],[17,"CRAM_OPT_USE_BZIP2","","",null,null],[17,"CRAM_OPT_SHARED_REF","","",null,null],[17,"CRAM_OPT_NTHREADS","","",null,null],[17,"CRAM_OPT_THREAD_POOL","","",null,null],[17,"CRAM_OPT_USE_LZMA","","",null,null],[17,"CRAM_OPT_USE_RANS","","",null,null],[17,"CRAM_OPT_REQUIRED_FIELDS","","",null,null],[17,"__codecvt_ok","","",null,null],[17,"__codecvt_partial","","",null,null],[17,"__codecvt_error","","",null,null],[17,"__codecvt_noconv","","",null,null],[11,"clone","","",12,null],[11,"default","","",12,{"inputs":[],"output":{"name":"struct___kstring_t"}}],[11,"clone","","",13,null],[11,"default","","",13,{"inputs":[],"output":{"name":"struct_htsformat"}}],[11,"clone","","",14,null],[11,"default","","",14,{"inputs":[],"output":{"name":"struct_unnamed1"}}],[11,"clone","","",15,null],[11,"default","","",15,{"inputs":[],"output":{"name":"struct_unnamed2"}}],[11,"clone","","",16,null],[11,"bgzf","","",16,null],[11,"cram","","",16,null],[11,"hfile","","",16,null],[11,"voidp","","",16,null],[11,"default","","",16,{"inputs":[],"output":{"name":"union_unnamed3"}}],[11,"clone","","",17,null],[11,"default","","",17,{"inputs":[],"output":{"name":"struct_unnamed4"}}],[11,"clone","","",18,null],[11,"default","","",18,{"inputs":[],"output":{"name":"struct_unnamed5"}}],[11,"clone","","",19,null],[11,"default","","",19,{"inputs":[],"output":{"name":"struct_unnamed6"}}],[11,"clone","","",20,null],[11,"default","","",20,{"inputs":[],"output":{"name":"struct_unnamed7"}}],[11,"clone","","",21,null],[11,"w_status","","",21,null],[11,"__wait_terminated","","",21,null],[11,"__wait_stopped","","",21,null],[11,"default","","",21,{"inputs":[],"output":{"name":"union_wait"}}],[11,"clone","","",22,null],[11,"default","","",22,{"inputs":[],"output":{"name":"struct_unnamed8"}}],[11,"clone","","",23,null],[11,"default","","",23,{"inputs":[],"output":{"name":"struct_unnamed9"}}],[11,"clone","","",24,null],[11,"__uptr","","",24,null],[11,"__iptr","","",24,null],[11,"default","","",24,{"inputs":[],"output":{"name":"union_unnamed10"}}],[11,"clone","","",25,null],[11,"default","","",25,{"inputs":[],"output":{"name":"struct_unnamed11"}}],[11,"clone","","",26,null],[11,"default","","",26,{"inputs":[],"output":{"name":"struct_unnamed12"}}],[11,"clone","","",27,null],[11,"default","","",27,{"inputs":[],"output":{"name":"struct_unnamed13"}}],[11,"clone","","",28,null],[11,"default","","",28,{"inputs":[],"output":{"name":"struct_unnamed14"}}],[11,"clone","","",29,null],[11,"default","","",29,{"inputs":[],"output":{"name":"struct_timespec"}}],[11,"clone","","",30,null],[11,"default","","",30,{"inputs":[],"output":{"name":"struct_timeval"}}],[11,"clone","","",31,null],[11,"default","","",31,{"inputs":[],"output":{"name":"struct_unnamed15"}}],[11,"clone","","",32,null],[11,"__size","","",32,null],[11,"__align","","",32,null],[11,"default","","",32,{"inputs":[],"output":{"name":"union_pthread_attr_t"}}],[11,"clone","","",33,null],[11,"default","","",33,{"inputs":[],"output":{"name":"struct___pthread_internal_list"}}],[11,"clone","","",34,null],[11,"__data","","",34,null],[11,"__size","","",34,null],[11,"__align","","",34,null],[11,"default","","",34,{"inputs":[],"output":{"name":"union_unnamed16"}}],[11,"clone","","",35,null],[11,"default","","",35,{"inputs":[],"output":{"name":"struct___pthread_mutex_s"}}],[11,"clone","","",36,null],[11,"__size","","",36,null],[11,"__align","","",36,null],[11,"default","","",36,{"inputs":[],"output":{"name":"union_unnamed17"}}],[11,"clone","","",37,null],[11,"__data","","",37,null],[11,"__size","","",37,null],[11,"__align","","",37,null],[11,"default","","",37,{"inputs":[],"output":{"name":"union_unnamed18"}}],[11,"clone","","",38,null],[11,"default","","",38,{"inputs":[],"output":{"name":"struct_unnamed19"}}],[11,"clone","","",39,null],[11,"__size","","",39,null],[11,"__align","","",39,null],[11,"default","","",39,{"inputs":[],"output":{"name":"union_unnamed20"}}],[11,"clone","","",40,null],[11,"__data","","",40,null],[11,"__size","","",40,null],[11,"__align","","",40,null],[11,"default","","",40,{"inputs":[],"output":{"name":"union_unnamed21"}}],[11,"clone","","",41,null],[11,"default","","",41,{"inputs":[],"output":{"name":"struct_unnamed22"}}],[11,"clone","","",42,null],[11,"__size","","",42,null],[11,"__align","","",42,null],[11,"default","","",42,{"inputs":[],"output":{"name":"union_unnamed23"}}],[11,"clone","","",43,null],[11,"__size","","",43,null],[11,"__align","","",43,null],[11,"default","","",43,{"inputs":[],"output":{"name":"union_unnamed24"}}],[11,"clone","","",44,null],[11,"__size","","",44,null],[11,"__align","","",44,null],[11,"default","","",44,{"inputs":[],"output":{"name":"union_unnamed25"}}],[11,"clone","","",45,null],[11,"default","","",45,{"inputs":[],"output":{"name":"struct_random_data"}}],[11,"clone","","",46,null],[11,"default","","",46,{"inputs":[],"output":{"name":"struct_drand48_data"}}],[11,"clone","","",47,null],[11,"default","","",47,{"inputs":[],"output":{"name":"struct___locale_struct"}}],[11,"clone","","",48,null],[11,"default","","",48,{"inputs":[],"output":{"name":"struct_unnamed26"}}],[11,"clone","","",49,null],[11,"__wch","","",49,null],[11,"__wchb","","",49,null],[11,"default","","",49,{"inputs":[],"output":{"name":"union_unnamed27"}}],[11,"clone","","",50,null],[11,"default","","",50,{"inputs":[],"output":{"name":"struct_unnamed28"}}],[11,"clone","","",51,null],[11,"default","","",51,{"inputs":[],"output":{"name":"struct_unnamed29"}}],[11,"clone","","",52,null],[11,"default","","",52,{"inputs":[],"output":{"name":"struct__io_marker"}}],[11,"clone","","",53,null],[11,"default","","",53,{"inputs":[],"output":{"name":"struct__io_file"}}],[11,"clone","","",54,null],[11,"default","","",54,{"inputs":[],"output":{"name":"struct_unnamed30"}}],[11,"clone","","",55,null],[11,"default","","",55,{"inputs":[],"output":{"name":"struct_unnamed31"}}],[11,"clone","","",56,null],[11,"default","","",56,{"inputs":[],"output":{"name":"struct_unnamed32"}}],[11,"clone","","",57,null],[11,"default","","",57,{"inputs":[],"output":{"name":"struct_unnamed33"}}],[11,"clone","","",58,null],[11,"default","","",58,{"inputs":[],"output":{"name":"struct_unnamed34"}}],[11,"clone","","",59,null],[11,"default","","",59,{"inputs":[],"output":{"name":"struct_unnamed35"}}],[11,"clone","","",60,null],[11,"default","","",60,{"inputs":[],"output":{"name":"struct_unnamed36"}}],[11,"clone","","",61,null],[11,"default","","",61,{"inputs":[],"output":{"name":"struct_unnamed37"}}],[11,"clone","","",62,null],[11,"i","","",62,null],[11,"f","","",62,null],[11,"default","","",62,{"inputs":[],"output":{"name":"union_unnamed38"}}],[11,"clone","","",63,null],[11,"default","","",63,{"inputs":[],"output":{"name":"struct_unnamed39"}}],[11,"clone","","",64,null],[11,"default","","",64,{"inputs":[],"output":{"name":"struct_unnamed40"}}],[11,"clone","","",65,null],[11,"default","","",65,{"inputs":[],"output":{"name":"struct___va_list_tag"}}],[0,"vcfutils","rust_htslib::htslib","",null,null],[5,"bcf_trim_alleles","rust_htslib::htslib::vcfutils","",null,null],[6,"BGZF","rust_htslib::htslib","",null,null],[6,"int8_t","","",null,null],[6,"int16_t","","",null,null],[6,"int32_t","","",null,null],[6,"int64_t","","",null,null],[6,"uint8_t","","",null,null],[6,"uint16_t","","",null,null],[6,"uint32_t","","",null,null],[6,"uint64_t","","",null,null],[6,"int_least8_t","","",null,null],[6,"int_least16_t","","",null,null],[6,"int_least32_t","","",null,null],[6,"int_least64_t","","",null,null],[6,"uint_least8_t","","",null,null],[6,"uint_least16_t","","",null,null],[6,"uint_least32_t","","",null,null],[6,"uint_least64_t","","",null,null],[6,"int_fast8_t","","",null,null],[6,"int_fast16_t","","",null,null],[6,"int_fast32_t","","",null,null],[6,"int_fast64_t","","",null,null],[6,"uint_fast8_t","","",null,null],[6,"uint_fast16_t","","",null,null],[6,"uint_fast32_t","","",null,null],[6,"uint_fast64_t","","",null,null],[6,"intptr_t","","",null,null],[6,"uintptr_t","","",null,null],[6,"intmax_t","","",null,null],[6,"uintmax_t","","",null,null],[6,"ptrdiff_t","","",null,null],[6,"size_t","","",null,null],[6,"wchar_t","","",null,null],[6,"kstring_t","","",null,null],[6,"Enum_htsFormatCategory","","",null,null],[6,"Enum_htsExactFormat","","",null,null],[6,"Enum_htsCompression","","",null,null],[6,"htsFormat","","",null,null],[6,"htsFile","","",null,null],[6,"Enum_sam_fields","","",null,null],[6,"Enum_cram_option","","",null,null],[6,"hts_idx_t","","",null,null],[6,"hts_pair64_t","","",null,null],[6,"hts_readrec_func","","",null,null],[6,"hts_itr_t","","",null,null],[6,"hts_name2id_f","","",null,null],[6,"hts_id2name_f","","",null,null],[6,"hts_itr_query_func","","",null,null],[6,"bam_hdr_t","","",null,null],[6,"bam1_core_t","","",null,null],[6,"bam1_t","","",null,null],[6,"samFile","","",null,null],[6,"bam_pileup1_t","","",null,null],[6,"bam_plp_auto_f","","",null,null],[6,"bam_plp_t","","",null,null],[6,"bam_mplp_t","","",null,null],[17,"HTS_FMT_BAI","","",null,null],[17,"unknown_category","","",null,null],[17,"sequence_data","","",null,null],[17,"variant_data","","",null,null],[17,"index_file","","",null,null],[17,"region_list","","",null,null],[17,"category_maximum","","",null,null],[17,"unknown_format","","",null,null],[17,"binary_format","","",null,null],[17,"text_format","","",null,null],[17,"sam","","",null,null],[17,"bam","","",null,null],[17,"bai","","",null,null],[17,"cram","","",null,null],[17,"crai","","",null,null],[17,"vcf","","",null,null],[17,"bcf","","",null,null],[17,"csi","","",null,null],[17,"gzi","","",null,null],[17,"tbi","","",null,null],[17,"bed","","",null,null],[17,"format_maximum","","",null,null],[17,"no_compression","","",null,null],[17,"gzip","","",null,null],[17,"bgzf","","",null,null],[17,"custom","","",null,null],[17,"compression_maximum","","",null,null],[17,"SAM_QNAME","","",null,null],[17,"SAM_FLAG","","",null,null],[17,"SAM_RNAME","","",null,null],[17,"SAM_POS","","",null,null],[17,"SAM_MAPQ","","",null,null],[17,"SAM_CIGAR","","",null,null],[17,"SAM_RNEXT","","",null,null],[17,"SAM_PNEXT","","",null,null],[17,"SAM_TLEN","","",null,null],[17,"SAM_SEQ","","",null,null],[17,"SAM_QUAL","","",null,null],[17,"SAM_AUX","","",null,null],[17,"SAM_RGAUX","","",null,null],[17,"CRAM_OPT_DECODE_MD","","",null,null],[17,"CRAM_OPT_PREFIX","","",null,null],[17,"CRAM_OPT_VERBOSITY","","",null,null],[17,"CRAM_OPT_SEQS_PER_SLICE","","",null,null],[17,"CRAM_OPT_SLICES_PER_CONTAINER","","",null,null],[17,"CRAM_OPT_RANGE","","",null,null],[17,"CRAM_OPT_VERSION","","",null,null],[17,"CRAM_OPT_EMBED_REF","","",null,null],[17,"CRAM_OPT_IGNORE_MD5","","",null,null],[17,"CRAM_OPT_REFERENCE","","",null,null],[17,"CRAM_OPT_MULTI_SEQ_PER_SLICE","","",null,null],[17,"CRAM_OPT_NO_REF","","",null,null],[17,"CRAM_OPT_USE_BZIP2","","",null,null],[17,"CRAM_OPT_SHARED_REF","","",null,null],[17,"CRAM_OPT_NTHREADS","","",null,null],[17,"CRAM_OPT_THREAD_POOL","","",null,null],[17,"CRAM_OPT_USE_LZMA","","",null,null],[17,"CRAM_OPT_USE_RANS","","",null,null],[17,"CRAM_OPT_REQUIRED_FIELDS","","",null,null],[0,"bam","rust_htslib","",null,null],[3,"Reader","rust_htslib::bam","A BAM reader.",null,null],[12,"header","","",66,null],[3,"IndexedReader","","",null,null],[12,"header","","",67,null],[3,"Writer","","A BAM writer.",null,null],[12,"header","","",68,null],[3,"Records","","Iterator over the records of a BAM.",null,null],[3,"HeaderView","","",null,null],[4,"ReadError","","",null,null],[13,"Truncated","","",69,null],[13,"Invalid","","",69,null],[13,"NoMoreRecord","","",69,null],[4,"IndexError","","",null,null],[13,"InvalidIndex","","",70,null],[13,"InvalidPath","","",70,null],[4,"BGZFError","","",null,null],[13,"InvalidPath","","",71,null],[4,"WriteError","","",null,null],[13,"Some","","",72,null],[4,"SeekError","","",null,null],[13,"Some","","",73,null],[0,"record","","",null,null],[3,"Record","rust_htslib::bam::record","A BAM record.",null,null],[12,"inner","","",74,null],[3,"Seq","","",null,null],[12,"encoded","","",75,null],[4,"Aux","","Auxiliary record data.",null,null],[13,"Integer","","",76,null],[13,"String","","",76,null],[13,"Float","","",76,null],[13,"Char","","",76,null],[4,"Cigar","","",null,null],[13,"Match","","",77,null],[13,"Ins","","",77,null],[13,"Del","","",77,null],[13,"RefSkip","","",77,null],[13,"SoftClip","","",77,null],[13,"HardClip","","",77,null],[13,"Pad","","",77,null],[13,"Equal","","",77,null],[13,"Diff","","",77,null],[13,"Back","","",77,null],[11,"new","","Create an empty BAM record.",74,{"inputs":[],"output":{"name":"self"}}],[11,"from_inner","","",74,null],[11,"inner_mut","","",74,null],[11,"inner","","",74,null],[11,"tid","","Get target id.",74,null],[11,"set_tid","","Set target id.",74,null],[11,"pos","","Get position (0-based).",74,null],[11,"set_pos","","Set position (0-based).",74,null],[11,"end_pos","","",74,null],[11,"bin","","",74,null],[11,"set_bin","","",74,null],[11,"mapq","","Get MAPQ.",74,null],[11,"set_mapq","","Set MAPQ.",74,null],[11,"flags","","Get raw flags.",74,null],[11,"set_flags","","Set raw flags.",74,null],[11,"unset_flags","","Unset all flags.",74,null],[11,"mtid","","Get target id of mate.",74,null],[11,"set_mtid","","Set target id of mate.",74,null],[11,"mpos","","Get mate position.",74,null],[11,"set_mpos","","Set mate position.",74,null],[11,"insert_size","","Get insert size.",74,null],[11,"set_insert_size","","Set insert size.",74,null],[11,"qname","","Get qname (read name).",74,null],[11,"set","","Set variable length data (qname, cigar, seq, qual).",74,null],[11,"cigar","","Get cigar sequence.",74,null],[11,"seq","","Get read sequence.",74,null],[11,"qual","","Get base qualities.",74,null],[11,"aux","","Get auxiliary data (tags).",74,null],[11,"push_aux","","Add auxiliary data.",74,null],[11,"is_paired","","",74,null],[11,"set_paired","","",74,null],[11,"is_proper_pair","","",74,null],[11,"set_proper_pair","","",74,null],[11,"is_unmapped","","",74,null],[11,"set_unmapped","","",74,null],[11,"is_mate_unmapped","","",74,null],[11,"set_mate_unmapped","","",74,null],[11,"is_reverse","","",74,null],[11,"set_reverse","","",74,null],[11,"is_mate_reverse","","",74,null],[11,"set_mate_reverse","","",74,null],[11,"is_first_in_template","","",74,null],[11,"set_first_in_template","","",74,null],[11,"is_last_in_template","","",74,null],[11,"set_last_in_template","","",74,null],[11,"is_secondary","","",74,null],[11,"set_secondary","","",74,null],[11,"is_quality_check_failed","","",74,null],[11,"set_quality_check_failed","","",74,null],[11,"is_duplicate","","",74,null],[11,"set_duplicate","","",74,null],[11,"is_supplementary","","",74,null],[11,"set_supplementary","","",74,null],[11,"drop","","",74,null],[11,"fmt","","",76,null],[11,"eq","","",76,null],[11,"ne","","",76,null],[11,"string","","Get string from aux data (panics if not a string).",76,null],[11,"float","","",76,null],[11,"integer","","",76,null],[11,"char","","",76,null],[11,"encoded_base","","",75,null],[11,"as_bytes","","",75,null],[11,"len","","",75,null],[11,"index","","",75,null],[11,"fmt","","",77,null],[11,"eq","","",77,null],[11,"ne","","",77,null],[0,"header","rust_htslib::bam","",null,null],[3,"Header","rust_htslib::bam::header","A BAM header.",null,null],[3,"HeaderRecord","","Header record.",null,null],[11,"new","","Create a new header.",78,{"inputs":[],"output":{"name":"self"}}],[11,"push_record","","Add a record to the header.",78,null],[11,"push_comment","","Add a comment to the header.",78,null],[11,"to_bytes","","",78,null],[11,"new","","Create a new header record.\nSee SAM format specification for possible record types.",79,null],[11,"push_tag","","Add a new tag to the record.",79,null],[0,"pileup","rust_htslib::bam","",null,null],[3,"Pileup","rust_htslib::bam::pileup","A pileup over one genomic position.",null,null],[3,"Alignment","","An aligned read in a pileup.",null,null],[3,"Pileups","","Iterator over pileups.",null,null],[4,"Indel","","",null,null],[13,"Ins","","",80,null],[13,"Del","","",80,null],[13,"None","","",80,null],[4,"PileupError","","",null,null],[13,"Some","","",81,null],[6,"Alignments","","Iterator over alignments of a pileup.",null,null],[11,"tid","","",82,null],[11,"pos","","",82,null],[11,"depth","","",82,null],[11,"alignments","","",82,null],[11,"new","","",83,{"inputs":[{"name":"bam_pileup1_t"}],"output":{"name":"self"}}],[11,"qpos","","Position within the read.",83,null],[11,"indel","","Insertion, deletion (with length) or None if no indel.",83,null],[11,"record","","The corresponding record.",83,null],[11,"eq","","",80,null],[11,"ne","","",80,null],[11,"fmt","","",80,null],[11,"new","","",84,{"inputs":[{"name":"bam_plp_t"}],"output":{"name":"self"}}],[11,"set_max_depth","","",84,null],[11,"next","","",84,null],[11,"drop","","",84,null],[11,"fmt","","",81,null],[11,"fmt","","",81,null],[11,"description","","",81,null],[11,"cause","","",81,null],[8,"Read","rust_htslib::bam","A trait for a BAM reader with a read method.",null,null],[10,"read","","Read next BAM record into given record.\nUse this method in combination with a single allocated record to avoid the reallocations\noccurring with the iterator.",85,null],[10,"records","","Iterator over the records of the seeked region.\nNote that, while being convenient, this is less efficient than pre-allocating a\n`Record` and reading into it with the `read` method, since every iteration involves\nthe allocation of a new `Record`.",85,null],[10,"pileup","","Iterator over pileups.",85,null],[10,"bgzf","","Return the BGZF struct",85,null],[11,"new","","Create a new Reader.",66,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"read","","",66,null],[11,"records","","Iterator over the records of the seeked region.\nNote that, while being convenient, this is less efficient than pre-allocating a\n`Record` and reading into it with the `read` method, since every iteration involves\nthe allocation of a new `Record`.",66,null],[11,"pileup","","",66,null],[11,"bgzf","","",66,null],[11,"drop","","",66,null],[11,"new","","Create a new Reader.",67,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"seek","","",67,null],[11,"read","","",67,null],[11,"records","","Iterator over the records of the seeked region.\nNote that, while being convenient, this is less efficient than pre-allocating a\n`Record` and reading into it with the `read` method, since every iteration involves\nthe allocation of a new `Record`.",67,null],[11,"pileup","","",67,null],[11,"bgzf","","",67,null],[11,"drop","","",67,null],[11,"new","","Create a new BAM file.",68,{"inputs":[{"name":"p"},{"name":"header"}],"output":{"name":"result"}}],[11,"with_template","","Create a new BAM file from template.",68,{"inputs":[{"name":"t"},{"name":"p"}],"output":{"name":"result"}}],[11,"write","","Write record to BAM.",68,null],[11,"drop","","",68,null],[11,"next","","",86,null],[11,"fmt","","",69,null],[11,"fmt","","",69,null],[11,"description","","",69,null],[11,"cause","","",69,null],[11,"is_eof","","Returns true if no record has been read because the end of the file was reached.",69,null],[11,"fmt","","",70,null],[11,"fmt","","",70,null],[11,"description","","",70,null],[11,"cause","","",70,null],[11,"fmt","","",71,null],[11,"fmt","","",71,null],[11,"description","","",71,null],[11,"cause","","",71,null],[11,"fmt","","",72,null],[11,"fmt","","",72,null],[11,"description","","",72,null],[11,"cause","","",72,null],[11,"fmt","","",73,null],[11,"fmt","","",73,null],[11,"description","","",73,null],[11,"cause","","",73,null],[11,"tid","","",87,null],[11,"target_count","","",87,null],[11,"target_names","","",87,null],[11,"target_len","","",87,null],[0,"bcf","rust_htslib","",null,null],[3,"Reader","rust_htslib::bcf","",null,null],[12,"header","","",88,null],[3,"Writer","","",null,null],[12,"header","","",89,null],[3,"Records","","",null,null],[4,"BCFError","","",null,null],[13,"InvalidPath","","",90,null],[4,"ReadError","","",null,null],[13,"Invalid","","",91,null],[13,"NoMoreRecord","","",91,null],[4,"WriteError","","",null,null],[13,"WriteError","","",92,null],[0,"record","","",null,null],[3,"Record","rust_htslib::bcf::record","",null,null],[12,"inner","","",93,null],[12,"header","","",93,null],[3,"Genotype","","Genotype representation as a vector of `GenotypeAllele`.",null,null],[3,"Genotypes","","Lazy representation of genotypes, that does no computation until a particular genotype is queried.",null,null],[3,"Info","","",null,null],[3,"Format","","",null,null],[4,"GenotypeAllele","","Phased or unphased alleles, represented as indices.",null,null],[13,"Unphased","","",94,null],[13,"Phased","","",94,null],[13,"UnphasedMissing","","",94,null],[13,"PhasedMissing","","",94,null],[4,"InfoReadError","","",null,null],[13,"UndefinedTag","","",95,null],[13,"UnexpectedType","","",95,null],[4,"FormatReadError","","",null,null],[13,"UndefinedTag","","",96,null],[13,"UnexpectedType","","",96,null],[13,"MissingTag","","",96,null],[4,"TagWriteError","","",null,null],[13,"Some","","",97,null],[4,"TrimAllelesError","","",null,null],[13,"Some","","",98,null],[8,"Numeric","","Common methods for numeric INFO and FORMAT entries",null,null],[10,"is_missing","","Return true if entry is a missing value",99,null],[10,"missing","","Return missing value for storage in BCF record.",99,{"inputs":[],"output":{"name":"self"}}],[11,"new","","",93,{"inputs":[],"output":{"name":"self"}}],[11,"inner","","",93,null],[11,"inner_mut","","",93,null],[11,"rid","","",93,null],[11,"pos","","",93,null],[11,"set_pos","","",93,null],[11,"alleles","","",93,null],[11,"qual","","",93,null],[11,"set_qual","","",93,null],[11,"info","","Get the value of the given info tag.",93,null],[11,"sample_count","","",93,null],[11,"allele_count","","",93,null],[11,"genotypes","","Get genotypes as vector of one `Genotype` per sample.",93,null],[11,"format","","Get the value of the given format tag for each sample.",93,null],[11,"push_format_integer","","Add an integer format tag. Data is a flattened two-dimensional array.\nThe first dimension contains one array for each sample.\nReturns error if tag is not present in header.",93,null],[11,"push_format_float","","Add a float format tag. Data is a flattened two-dimensional array.\nThe first dimension contains one array for each sample.\nReturns error if tag is not present in header.",93,null],[11,"push_info_integer","","Add an integer info tag.",93,null],[11,"push_info_float","","Add a float info tag.",93,null],[11,"push_info","","Add an info tag.",93,null],[11,"trim_alleles","","Remove unused alleles.",93,null],[11,"fmt","","",94,null],[11,"from_encoded","","Decode given integer according to BCF standard.",94,{"inputs":[{"name":"i32"}],"output":{"name":"self"}}],[11,"index","","",94,null],[11,"fmt","","",94,null],[11,"fmt","","",100,null],[11,"deref","","",100,null],[11,"fmt","","",100,null],[11,"fmt","","",101,null],[11,"get","","Get genotype of ith sample. So far, only supports diploid genotypes.",101,null],[11,"drop","","",93,null],[11,"integer","","Get integers from tag. `None` if tag not present in record.\nImport `bcf::record::Numeric` for missing value handling.",102,null],[11,"integer_mut","","Get mutable integers from tag. `None` if tag not present in record.\nImport `bcf::record::Numeric` for missing value handling.",102,null],[11,"float","","Get floats from tag. `None` if tag not present in record.\nImport `bcf::record::Numeric` for missing value handling.",102,null],[11,"float_mut","","Get mutable floats from tag. `None` if tag not present in record.\nImport `bcf::record::Numeric` for missing value handling.",102,null],[11,"flag","","",102,null],[11,"string","","Get strings from tag. `None` if tag not present in record.",102,null],[11,"string_mut","","Get mutable strings from tag. `None` if tag not present in record.",102,null],[11,"inner","","",103,null],[11,"inner_mut","","",103,null],[11,"integer","","",103,null],[11,"integer_mut","","",103,null],[11,"float","","",103,null],[11,"float_mut","","",103,null],[11,"string","","",103,null],[11,"string_mut","","",103,null],[11,"fmt","","",95,null],[11,"fmt","","",95,null],[11,"description","","",95,null],[11,"cause","","",95,null],[11,"fmt","","",96,null],[11,"fmt","","",96,null],[11,"description","","",96,null],[11,"cause","","",96,null],[11,"fmt","","",97,null],[11,"fmt","","",97,null],[11,"description","","",97,null],[11,"cause","","",97,null],[11,"fmt","","",98,null],[11,"fmt","","",98,null],[11,"description","","",98,null],[11,"cause","","",98,null],[0,"header","rust_htslib::bcf","",null,null],[3,"Header","rust_htslib::bcf::header","A BCF header.",null,null],[12,"inner","","",104,null],[12,"subset","","",104,null],[3,"HeaderView","","",null,null],[12,"inner","","",105,null],[4,"TagType","","",null,null],[13,"Flag","","",106,null],[13,"Integer","","",106,null],[13,"Float","","",106,null],[13,"String","","",106,null],[4,"TagLength","","",null,null],[13,"Fixed","","",107,null],[13,"AltAlleles","","",107,null],[13,"Alleles","","",107,null],[13,"Genotypes","","",107,null],[13,"Variable","","",107,null],[4,"RidError","","",null,null],[13,"UnknownSequence","","",108,null],[4,"SubsetError","","",null,null],[13,"DuplicateSampleName","","",109,null],[4,"TagTypeError","","",null,null],[13,"UnexpectedTagType","","",110,null],[13,"UndefinedTag","","",110,null],[6,"SampleSubset","","",null,null],[11,"new","","Create a new header.",104,{"inputs":[],"output":{"name":"self"}}],[11,"with_template","","",104,{"inputs":[{"name":"headerview"}],"output":{"name":"self"}}],[11,"subset_template","","",104,null],[11,"push_sample","","",104,null],[11,"push_record","","Add a record to the header.",104,null],[11,"remove_info","","",104,null],[11,"remove_format","","",104,null],[11,"drop","","",104,null],[11,"new","","",105,null],[11,"sample_count","","",105,null],[11,"samples","","",105,null],[11,"rid2name","","",105,null],[11,"name2rid","","",105,null],[11,"info_type","","",105,null],[11,"format_type","","",105,null],[11,"fmt","","",108,null],[11,"fmt","","",108,null],[11,"description","","",108,null],[11,"cause","","",108,null],[11,"fmt","","",109,null],[11,"fmt","","",109,null],[11,"description","","",109,null],[11,"cause","","",109,null],[11,"fmt","","",110,null],[11,"fmt","","",110,null],[11,"description","","",110,null],[11,"cause","","",110,null],[11,"new","rust_htslib::bcf","",88,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"read","","",88,null],[11,"records","","",88,null],[11,"drop","","",88,null],[11,"new","","",89,{"inputs":[{"name":"p"},{"name":"header"},{"name":"bool"},{"name":"bool"}],"output":{"name":"result"}}],[11,"translate","","Translate record to header of this writer.",89,null],[11,"subset","","Subset samples of record to match header of this writer.",89,null],[11,"write","","",89,null],[11,"drop","","",89,null],[11,"next","","",111,null],[11,"fmt","","",90,null],[11,"fmt","","",90,null],[11,"description","","",90,null],[11,"cause","","",90,null],[11,"fmt","","",91,null],[11,"fmt","","",91,null],[11,"description","","",91,null],[11,"cause","","",91,null],[11,"is_eof","","Returns true if no record has been read because the end of the file was reached.",91,null],[11,"fmt","","",92,null],[11,"fmt","","",92,null],[11,"description","","",92,null],[11,"cause","","",92,null],[0,"utils","rust_htslib","",null,null],[5,"copy_memory","rust_htslib::utils","Copies data from `src` to `dst`\nTODO remove once stable in standard library.",null,null],[5,"path_to_cstring","","",null,{"inputs":[{"name":"p"}],"output":{"name":"option"}}]],"paths":[[3,"Struct___kstring_t"],[3,"Struct_htsFormat"],[3,"Struct_Unnamed1"],[3,"Struct_Unnamed2"],[3,"Union_Unnamed3"],[3,"Struct_Unnamed4"],[3,"Struct_Unnamed5"],[3,"Struct_Unnamed6"],[3,"Struct_Unnamed7"],[3,"Struct_Unnamed8"],[3,"Struct_Unnamed9"],[3,"Struct_Unnamed10"],[3,"Struct___kstring_t"],[3,"Struct_htsFormat"],[3,"Struct_Unnamed1"],[3,"Struct_Unnamed2"],[3,"Union_Unnamed3"],[3,"Struct_Unnamed4"],[3,"Struct_Unnamed5"],[3,"Struct_Unnamed6"],[3,"Struct_Unnamed7"],[3,"Union_wait"],[3,"Struct_Unnamed8"],[3,"Struct_Unnamed9"],[3,"Union_Unnamed10"],[3,"Struct_Unnamed11"],[3,"Struct_Unnamed12"],[3,"Struct_Unnamed13"],[3,"Struct_Unnamed14"],[3,"Struct_timespec"],[3,"Struct_timeval"],[3,"Struct_Unnamed15"],[3,"Union_pthread_attr_t"],[3,"Struct___pthread_internal_list"],[3,"Union_Unnamed16"],[3,"Struct___pthread_mutex_s"],[3,"Union_Unnamed17"],[3,"Union_Unnamed18"],[3,"Struct_Unnamed19"],[3,"Union_Unnamed20"],[3,"Union_Unnamed21"],[3,"Struct_Unnamed22"],[3,"Union_Unnamed23"],[3,"Union_Unnamed24"],[3,"Union_Unnamed25"],[3,"Struct_random_data"],[3,"Struct_drand48_data"],[3,"Struct___locale_struct"],[3,"Struct_Unnamed26"],[3,"Union_Unnamed27"],[3,"Struct_Unnamed28"],[3,"Struct_Unnamed29"],[3,"Struct__IO_marker"],[3,"Struct__IO_FILE"],[3,"Struct_Unnamed30"],[3,"Struct_Unnamed31"],[3,"Struct_Unnamed32"],[3,"Struct_Unnamed33"],[3,"Struct_Unnamed34"],[3,"Struct_Unnamed35"],[3,"Struct_Unnamed36"],[3,"Struct_Unnamed37"],[3,"Union_Unnamed38"],[3,"Struct_Unnamed39"],[3,"Struct_Unnamed40"],[3,"Struct___va_list_tag"],[3,"Reader"],[3,"IndexedReader"],[3,"Writer"],[4,"ReadError"],[4,"IndexError"],[4,"BGZFError"],[4,"WriteError"],[4,"SeekError"],[3,"Record"],[3,"Seq"],[4,"Aux"],[4,"Cigar"],[3,"Header"],[3,"HeaderRecord"],[4,"Indel"],[4,"PileupError"],[3,"Pileup"],[3,"Alignment"],[3,"Pileups"],[8,"Read"],[3,"Records"],[3,"HeaderView"],[3,"Reader"],[3,"Writer"],[4,"BCFError"],[4,"ReadError"],[4,"WriteError"],[3,"Record"],[4,"GenotypeAllele"],[4,"InfoReadError"],[4,"FormatReadError"],[4,"TagWriteError"],[4,"TrimAllelesError"],[8,"Numeric"],[3,"Genotype"],[3,"Genotypes"],[3,"Info"],[3,"Format"],[3,"Header"],[3,"HeaderView"],[4,"TagType"],[4,"TagLength"],[4,"RidError"],[4,"SubsetError"],[4,"TagTypeError"],[3,"Records"]]};
searchIndex["itertools"] = {"doc":"Itertools — extra iterator adaptors, functions and macros.","items":[[4,"Either","itertools","`Either` represents an alternative holding one value out of\neither of the two possible values.",null,null],[13,"Left","","A value of type `L`.",0,null],[13,"Right","","A value of type `R`.",0,null],[4,"Diff","","A type returned by the [`diff_with`](./fn.diff_with.html) function.",null,null],[13,"FirstMismatch","","The index of the first non-matching element along with both iterator&#39;s remaining elements\nstarting with the first mis-match.",1,null],[13,"Shorter","","The total number of elements that were in `J` along with the remaining elements of `I`.",1,null],[13,"Longer","","The total number of elements that were in `I` along with the remaining elements of `J`.",1,null],[4,"MinMaxResult","","`MinMaxResult` is an enum returned by `minmax`. See `Itertools::minmax()` for\nmore detail.",null,null],[13,"NoElements","","Empty iterator",2,null],[13,"OneElement","","Iterator with one element, so the minimum and maximum are the same",2,null],[13,"MinMax","","More than one element in the iterator, the first element is not larger\nthan the second",2,null],[4,"EitherOrBoth","","A value yielded by `ZipLongest`.\nContains one or two values, depending on which of the input iterators are exhausted.",null,null],[13,"Both","","Neither input iterator is exhausted yet, yielding two values.",3,null],[13,"Left","","The parameter iterator of `.zip_longest()` is exhausted,\nonly yielding a value from the `self` iterator.",3,null],[13,"Right","","The `self` iterator of `.zip_longest()` is exhausted,\nonly yielding a value from the parameter iterator.",3,null],[4,"FoldWhile","","An enum used for controlling the execution of `.fold_while()`.",null,null],[13,"Continue","","Continue folding with this value",4,null],[13,"Done","","Fold is complete and will return this value",4,null],[5,"cons_tuples","","Create an iterator that maps for example iterators of\n`((A, B), C)` to `(A, B, C)`.",null,{"inputs":[{"name":"i"}],"output":{"name":"constuples"}}],[5,"diff_with","","Compares every element yielded by both `i` and `j` with the given function in lock-step and\nreturns a `Diff` which describes how `j` differs from `i`.",null,{"inputs":[{"name":"i"},{"name":"j"},{"name":"f"}],"output":{"name":"option"}}],[5,"repeat_n","","Create an iterator that produces `n` repetitions of `element`.",null,{"inputs":[{"name":"a"},{"name":"usize"}],"output":{"name":"repeatn"}}],[5,"repeat_call","","An iterator source that produces elements indefinitely by calling\na given closure.",null,{"inputs":[{"name":"f"}],"output":{"name":"repeatcall"}}],[5,"unfold","","Creates a new unfold source with the specified closure as the &quot;iterator\nfunction&quot; and an initial state to eventually pass to the closure",null,{"inputs":[{"name":"st"},{"name":"f"}],"output":{"name":"unfold"}}],[5,"iterate","","Creates a new iterator that infinitely applies function to value and yields results.",null,{"inputs":[{"name":"st"},{"name":"f"}],"output":{"name":"iterate"}}],[5,"multizip","","An iterator that generalizes *.zip()* and allows running multiple iterators in lockstep.",null,{"inputs":[{"name":"u"}],"output":{"name":"zip"}}],[5,"interleave","","Create an iterator that interleaves elements in `i` and `j`.",null,{"inputs":[{"name":"i"},{"name":"j"}],"output":{"name":"interleave"}}],[5,"merge","","Create an iterator that merges elements in `i` and `j`.",null,{"inputs":[{"name":"i"},{"name":"j"}],"output":{"name":"merge"}}],[5,"multipeek","","An iterator adaptor that allows the user to peek at multiple `.next()`\nvalues without advancing the base iterator.",null,{"inputs":[{"name":"i"}],"output":{"name":"multipeek"}}],[5,"put_back","","Create an iterator where you can put back a single item",null,{"inputs":[{"name":"i"}],"output":{"name":"putback"}}],[5,"put_back_n","","Create an iterator where you can put back multiple values to the front\nof the iteration.",null,{"inputs":[{"name":"i"}],"output":{"name":"putbackn"}}],[5,"kmerge","","Create an iterator that merges elements of the contained iterators.",null,{"inputs":[{"name":"i"}],"output":{"name":"kmerge"}}],[5,"zip_eq","","Iterate `i` and `j` in lock step.",null,{"inputs":[{"name":"i"},{"name":"j"}],"output":{"name":"zipeq"}}],[5,"rciter","","Return an iterator inside a `Rc&lt;RefCell&lt;_&gt;&gt;` wrapper.",null,{"inputs":[{"name":"i"}],"output":{"name":"rciter"}}],[5,"enumerate","","Iterate `iterable` with a running index.",null,{"inputs":[{"name":"i"}],"output":{"name":"enumerate"}}],[5,"rev","","Iterate `iterable` in reverse.",null,{"inputs":[{"name":"i"}],"output":{"name":"rev"}}],[5,"zip","","Iterate `i` and `j` in lock step.",null,{"inputs":[{"name":"i"},{"name":"j"}],"output":{"name":"zip"}}],[5,"chain","","Create an iterator that first iterates `i` and then `j`.",null,{"inputs":[{"name":"i"},{"name":"j"}],"output":{"name":"chain"}}],[5,"cloned","","Create an iterator that clones each element from &amp;T to T",null,{"inputs":[{"name":"i"}],"output":{"name":"cloned"}}],[5,"fold","","Perform a fold operation over the iterable.",null,{"inputs":[{"name":"i"},{"name":"b"},{"name":"f"}],"output":{"name":"b"}}],[5,"all","","Test whether the predicate holds for all elements in the iterable.",null,{"inputs":[{"name":"i"},{"name":"f"}],"output":{"name":"bool"}}],[5,"any","","Test whether the predicate holds for any elements in the iterable.",null,{"inputs":[{"name":"i"},{"name":"f"}],"output":{"name":"bool"}}],[5,"max","","Return the maximum value of the iterable.",null,{"inputs":[{"name":"i"}],"output":{"name":"option"}}],[5,"min","","Return the minimum value of the iterable.",null,{"inputs":[{"name":"i"}],"output":{"name":"option"}}],[5,"join","","Combine all iterator elements into one String, seperated by `sep`.",null,{"inputs":[{"name":"i"},{"name":"str"}],"output":{"name":"string"}}],[5,"sorted","","Collect all the iterable&#39;s elements into a sorted vector in ascending order.",null,{"inputs":[{"name":"i"}],"output":{"name":"vec"}}],[5,"equal","","Return `true` if both iterators produce equal sequences\n(elements pairwise equal and sequences of the same length),\n`false` otherwise.",null,{"inputs":[{"name":"i"},{"name":"j"}],"output":{"name":"bool"}}],[5,"assert_equal","","Assert that two iterators produce equal sequences, with the same\nsemantics as *equal(a, b)*.",null,{"inputs":[{"name":"i"},{"name":"j"}],"output":null}],[5,"partition","","Partition a sequence using predicate `pred` so that elements\nthat map to `true` are placed before elements which map to `false`.",null,{"inputs":[{"name":"i"},{"name":"f"}],"output":{"name":"usize"}}],[0,"structs","","The concrete iterator types.",null,null],[3,"Dedup","itertools::structs","An iterator adaptor that removes repeated duplicates.",null,null],[3,"Interleave","","An iterator adaptor that alternates elements from two iterators until both\nrun out.",null,null],[3,"InterleaveShortest","","An iterator adaptor that alternates elements from the two iterators until\none of them runs out.",null,null],[3,"Product","","An iterator adaptor that iterates over the cartesian product of\nthe element sets of two iterators `I` and `J`.",null,null],[3,"PutBack","","An iterator adaptor that allows putting back a single\nitem to the front of the iterator.",null,null],[3,"PutBackN","","An iterator adaptor that allows putting multiple\nitems in front of the iterator.",null,null],[3,"Batching","","A “meta iterator adaptor”. Its closure recives a reference to the iterator\nand may pick off as many elements as it likes, to produce the next iterator element.",null,null],[3,"Step","","An iterator adaptor that steps a number elements in the base iterator\nfor each iteration.",null,null],[3,"Merge","","An iterator adaptor that merges the two base iterators in ascending order.\nIf both base iterators are sorted (ascending), the result is sorted.",null,null],[3,"MergeBy","","An iterator adaptor that merges the two base iterators in ascending order.\nIf both base iterators are sorted (ascending), the result is sorted.",null,null],[3,"MultiPeek","","See [`multipeek()`](../fn.multipeek.html) for more information.",null,null],[3,"TakeWhileRef","","An iterator adaptor that borrows from a `Clone`-able iterator\nto only pick off elements while the predicate returns `true`.",null,null],[3,"WhileSome","","An iterator adaptor that filters `Option&lt;A&gt;` iterator elements\nand produces `A`. Stops on the first `None` encountered.",null,null],[3,"Coalesce","","An iterator adaptor that may join together adjacent elements.",null,null],[3,"TupleCombinations","","An iterator to iterate through all combinations in a `Clone`-able iterator that produces tuples\nof a specific size.",null,null],[3,"Combinations","","An iterator to iterate through all the `n`-length combinations in an iterator.",null,null],[3,"Unique","","An iterator adapter to filter out duplicate elements.",null,null],[3,"UniqueBy","","An iterator adapter to filter out duplicate elements.",null,null],[3,"Flatten","","An iterator adapter to simply flatten a structure.",null,null],[3,"ConsTuples","","An iterator that maps an iterator of tuples like\n`((A, B), C)` to an iterator of `(A, B, C)`.",null,null],[3,"Format","","Format all iterator elements lazily, separated by `sep`.",null,null],[3,"FormatWith","","Format all iterator elements lazily, separated by `sep`.",null,null],[3,"IntoChunks","","`ChunkLazy` is the storage for a lazy chunking operation.",null,null],[3,"Chunk","","An iterator for the elements in a single chunk.",null,null],[3,"Chunks","","An iterator that yields the Chunk iterators.",null,null],[3,"GroupBy","","`GroupBy` is the storage for the lazy grouping operation.",null,null],[3,"Group","","An iterator for the elements in a single group.",null,null],[3,"Groups","","An iterator that yields the Group iterators.",null,null],[3,"Intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator.",null,null],[3,"KMerge","","An iterator adaptor that merges an abitrary number of base iterators in ascending order.\nIf all base iterators are sorted (ascending), the result is sorted.",null,null],[3,"PadUsing","","An iterator adaptor that pads a sequence to a minimum length by filling\nmissing elements using a closure.",null,null],[3,"RcIter","","A wrapper for `Rc&lt;RefCell&lt;I&gt;&gt;`, that implements the `Iterator` trait.",null,null],[12,"rciter","","The boxed iterator.",5,null],[3,"RepeatN","","An iterator that produces *n* repetitions of an element.",null,null],[3,"RepeatCall","","See [`repeat_call`](../fn.repeat_call.html) for more information.",null,null],[3,"Unfold","","See [`unfold`](../fn.unfold.html) for more information.",null,null],[12,"state","","Internal state that will be passed to the closure on the next iteration",6,null],[3,"Iterate","","An iterator that infinitely applies function to value and yields results.",null,null],[3,"Tee","","One half of an iterator pair where both return the same elements.",null,null],[3,"TupleBuffer","","An iterator over a incomplete tuple.",null,null],[3,"TupleWindows","","An iterator over all contiguous windows that produces tuples of a specific size.",null,null],[3,"Tuples","","An iterator that groups the items in tuples of a specific size.",null,null],[3,"ZipEq","","An iterator which iterates two other iterators simultaneously",null,null],[3,"ZipLongest","","An iterator which iterates two other iterators simultaneously",null,null],[3,"Zip","","See [`multizip`](../fn.multizip.html) for more information.",null,null],[11,"fmt","","",7,null],[11,"clone","","",7,null],[11,"next","","",7,null],[11,"size_hint","","",7,null],[11,"fmt","","",8,null],[11,"clone","","",8,null],[11,"next","","",8,null],[11,"size_hint","","",8,null],[11,"fmt","","",9,null],[11,"clone","","",9,null],[11,"with_value","","put back value `value` (builder method)",9,null],[11,"into_parts","","Split the `PutBack` into its parts.",9,null],[11,"put_back","","Put back a single value to the front of the iterator.",9,null],[11,"next","","",9,null],[11,"size_hint","","",9,null],[11,"all","","",9,null],[11,"fold","","",9,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"put_back","","Puts x in front of the iterator.\nThe values are yielded in order of the most recently put back\nvalues first.",10,null],[11,"next","","",10,null],[11,"size_hint","","",10,null],[11,"clone","","",11,null],[11,"fmt","","",11,null],[11,"next","","",11,null],[11,"size_hint","","",11,null],[11,"clone","","",12,null],[11,"fmt","","",12,null],[11,"next","","",12,null],[11,"size_hint","","",12,null],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"next","","",13,null],[11,"size_hint","","",13,null],[11,"clone","","",14,null],[11,"fmt","","",14,null],[11,"next","","",14,null],[11,"size_hint","","",14,null],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"next","","",15,null],[11,"size_hint","","",15,null],[11,"fmt","","",16,null],[11,"clone","","",16,null],[11,"peek","","Works exactly like `.next()` with the only difference that it doesn&#39;t\nadvance itself. `.peek()` can be called multiple times, to peek\nfurther ahead.",16,null],[11,"next","","",16,null],[11,"size_hint","","",16,null],[11,"clone","","",17,null],[11,"fmt","","",17,null],[11,"next","","",17,null],[11,"size_hint","","",17,null],[11,"clone","","",18,null],[11,"fmt","","",18,null],[11,"next","","",18,null],[11,"size_hint","","",18,null],[11,"fold","","",18,null],[11,"fmt","","",19,null],[11,"next","","",19,null],[11,"size_hint","","",19,null],[11,"fmt","","",20,null],[11,"clone","","",20,null],[11,"next","","",20,null],[11,"size_hint","","",20,null],[11,"fmt","","",21,null],[11,"next","","",21,null],[11,"fmt","","",22,null],[11,"next","","",22,null],[11,"clone","","",23,null],[11,"fmt","","",23,null],[11,"next","","",23,null],[11,"size_hint","","",23,null],[11,"next","","",24,null],[11,"size_hint","","",24,null],[11,"clone","","",24,null],[11,"fmt","","",24,null],[11,"fmt","","",25,null],[11,"clone","","",25,null],[11,"next","","",25,null],[11,"fold","","",25,null],[11,"next_back","","",25,null],[11,"next","","",26,null],[11,"size_hint","","",26,null],[11,"next_back","","",26,null],[11,"next","","",26,null],[11,"size_hint","","",26,null],[11,"next_back","","",26,null],[11,"next","","",26,null],[11,"size_hint","","",26,null],[11,"next_back","","",26,null],[11,"next","","",26,null],[11,"size_hint","","",26,null],[11,"next_back","","",26,null],[11,"next","","",26,null],[11,"size_hint","","",26,null],[11,"next_back","","",26,null],[11,"next","","",26,null],[11,"size_hint","","",26,null],[11,"next_back","","",26,null],[11,"clone","","",26,null],[11,"clone","","",27,null],[11,"fmt","","",28,null],[11,"fmt","","",27,null],[11,"fmt","","",27,null],[11,"fmt","","",27,null],[11,"fmt","","",27,null],[11,"fmt","","",27,null],[11,"fmt","","",27,null],[11,"fmt","","",27,null],[11,"fmt","","",27,null],[11,"fmt","","",27,null],[11,"next","","",29,null],[11,"drop","","",30,null],[11,"next","","",30,null],[11,"next","","",31,null],[11,"drop","","",32,null],[11,"next","","",32,null],[11,"clone","","",33,null],[11,"next","","",33,null],[11,"size_hint","","",33,null],[11,"clone","","",34,null],[11,"next","","",34,null],[11,"size_hint","","",34,null],[11,"fmt","itertools","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"clone","","",2,null],[11,"into_option","","`into_option` creates an `Option` of type `(T, T)`. The returned `Option`\nhas variant `None` if and only if the `MinMaxResult` has variant\n`NoElements`. Otherwise variant `Some(x, y)` is returned where `x &lt;= y`.\nIf `MinMaxResult` has variant `OneElement(x)`, performing this operation\nwill make one clone of `x`.",2,null],[11,"clone","itertools::structs","",35,null],[11,"next","","",35,null],[11,"size_hint","","",35,null],[11,"next_back","","",35,null],[11,"clone","","",5,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"next_back","","",5,null],[11,"new","","",36,{"inputs":[{"name":"a"},{"name":"usize"}],"output":{"name":"self"}}],[11,"next","","",36,null],[11,"size_hint","","",36,null],[11,"next_back","","",36,null],[11,"fmt","","",37,null],[11,"next","","",37,null],[11,"size_hint","","",37,null],[11,"fmt","","",6,null],[11,"clone","","",6,null],[11,"next","","",6,null],[11,"size_hint","","",6,null],[11,"clone","","",38,null],[11,"fmt","","",38,null],[11,"next","","",38,null],[11,"size_hint","","",38,null],[11,"next","","",39,null],[11,"size_hint","","",39,null],[11,"next","","",40,null],[11,"next","","",41,null],[11,"into_buffer","","Return a buffer with the produced items that was not enough to be grouped in a tuple.",41,null],[11,"next","","",42,null],[11,"clone","","",43,null],[11,"next","","",43,null],[11,"size_hint","","",43,null],[11,"clone","","",44,null],[11,"next","","",44,null],[11,"size_hint","","",44,null],[11,"next_back","","",44,null],[11,"fmt","itertools","",3,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"clone","","",3,null],[11,"clone","itertools::structs","",45,null],[11,"new","","Deprecated: renamed to multizip",45,{"inputs":[{"name":"u"}],"output":{"name":"zip"}}],[11,"from","","",45,null],[11,"next","","",45,null],[11,"size_hint","","",45,null],[11,"from","","",45,null],[11,"next","","",45,null],[11,"size_hint","","",45,null],[11,"from","","",45,null],[11,"next","","",45,null],[11,"size_hint","","",45,null],[11,"from","","",45,null],[11,"next","","",45,null],[11,"size_hint","","",45,null],[11,"from","","",45,null],[11,"next","","",45,null],[11,"size_hint","","",45,null],[11,"from","","",45,null],[11,"next","","",45,null],[11,"size_hint","","",45,null],[11,"from","","",45,null],[11,"next","","",45,null],[11,"size_hint","","",45,null],[11,"from","","",45,null],[11,"next","","",45,null],[11,"size_hint","","",45,null],[8,"Itertools","itertools","The trait `Itertools`: extra iterator adaptors and methods for iterators.",null,null],[11,"interleave","","Alternate elements from two iterators until both\nrun out.",46,null],[11,"interleave_shortest","","Alternate elements from two iterators until one of them runs out.",46,null],[11,"intersperse","","An iterator adaptor to insert a particular value\nbetween each element of the adapted iterator.",46,null],[11,"zip_longest","","Create an iterator which iterates over both this and the specified\niterator simultaneously, yielding pairs of two optional elements.",46,null],[11,"zip_eq","","Create an iterator which iterates over both this and the specified\niterator simultaneously, yielding pairs of elements.",46,null],[11,"batching","","A “meta iterator adaptor”. Its closure recives a reference to the\niterator and may pick off as many elements as it likes, to produce the\nnext iterator element.",46,null],[11,"group_by","","Return an *iterable* that can group iterator elements.\nConsecutive elements that map to the same key (“runs”), are assigned\nto the same group.",46,null],[11,"group_by_lazy","","",46,null],[11,"chunks","","Return an *iterable* that can chunk the iterator.",46,null],[11,"chunks_lazy","","",46,null],[11,"tuple_windows","","Return an iterator over all contiguous windows producing tuples of\na specific size (up to 4).",46,null],[11,"tuples","","Return an iterator that groups the items in tuples of a specific size\n(up to 4).",46,null],[11,"tee","","Split into an iterator pair that both yield all elements from\nthe original iterator.",46,null],[11,"step","","Return an iterator adaptor that steps `n` elements in the base iterator\nfor each iteration.",46,null],[11,"merge","","Return an iterator adaptor that merges the two base iterators in\nascending order.  If both base iterators are sorted (ascending), the\nresult is sorted.",46,null],[11,"merge_by","","Return an iterator adaptor that merges the two base iterators in order.\nThis is much like `.merge()` but allows for a custom ordering.",46,null],[11,"kmerge","","Return an iterator adaptor that flattens an iterator of iterators by\nmerging them in ascending order.",46,null],[11,"cartesian_product","","Return an iterator adaptor that iterates over the cartesian product of\nthe element sets of two iterators `self` and `J`.",46,null],[11,"coalesce","","Return an iterator adaptor that uses the passed-in closure to\noptionally merge together consecutive elements.",46,null],[11,"dedup","","Remove duplicates from sections of consecutive identical elements.\nIf the iterator is sorted, all elements will be unique.",46,null],[11,"unique","","Return an iterator adaptor that filters out elements that have\nalready been produced once during the iteration. Duplicates\nare detected using hash and equality.",46,null],[11,"unique_by","","Return an iterator adaptor that filters out elements that have\nalready been produced once during the iteration.",46,null],[11,"take_while_ref","","Return an iterator adaptor that borrows from a `Clone`-able iterator\nto only pick off elements while the predicate `f` returns `true`.",46,null],[11,"while_some","","Return an iterator adaptor that filters `Option&lt;A&gt;` iterator elements\nand produces `A`. Stops on the first `None` encountered.",46,null],[11,"tuple_combinations","","Return an iterator adaptor that iterates over the combinations of the\nelements from an iterator.",46,null],[11,"combinations","","Return an iterator adaptor that iterates over the `n`-length combinations of\nthe elements from an iterator.",46,null],[11,"pad_using","","Return an iterator adaptor that pads the sequence to a minimum length of\n`min` by filling missing elements using a closure `f`.",46,null],[11,"flatten","","Unravel a nested iterator.",46,null],[11,"next_tuple","","Advances the iterator and returns the next items grouped in a tuple of\na specific size (up to 4).",46,null],[11,"find_position","","Find the position and value of the first element satisfying a predicate.",46,null],[11,"dropping","","Consume the first `n` elements from the iterator eagerly,\nand return the same iterator again.",46,null],[11,"dropping_back","","Consume the last `n` elements from the iterator eagerly,\nand return the same iterator again.",46,null],[11,"foreach","","Run the closure `f` eagerly on each element of the iterator.",46,null],[11,"collect_vec","","`.collect_vec()` is simply a type specialization of `.collect()`,\nfor convenience.",46,null],[11,"set_from","","Assign to each reference in `self` from the `from` iterator,\nstopping at the shortest of the two iterators.",46,null],[11,"join","","Combine all iterator elements into one String, seperated by `sep`.",46,null],[11,"format","","Format all iterator elements, separated by `sep`.",46,null],[11,"format_default","","",46,null],[11,"format_with","","Format all iterator elements, separated by `sep`.",46,null],[11,"fold_results","","Fold `Result` values from an iterator.",46,null],[11,"fold_options","","Fold `Option` values from an iterator.",46,null],[11,"fold1","","Accumulator of the elements in the iterator.",46,null],[11,"fold_while","","An iterator method that applies a function, producing a single, final value.",46,null],[11,"sorted","","Collect all iterator elements into a sorted vector in ascending order.",46,null],[11,"sorted_by","","Collect all iterator elements into a sorted vector.",46,null],[11,"partition_map","","Collect all iterator elements into one of two\npartitions. Unlike `Iterator::partition`, each partition may\nhave a distinct type.",46,null],[11,"minmax","","Return the minimum and maximum elements in the iterator.",46,null],[11,"minmax_by_key","","Return the minimum and maximum element of an iterator, as determined by\nthe specified function.",46,null],[11,"minmax_by","","Return the minimum and maximum element of an iterator, as determined by\nthe specified comparison function.",46,null],[14,"iproduct!","","Create an iterator over the “cartesian product” of iterators.",null,null],[14,"izip!","","Create an iterator running multiple iterators in lockstep.",null,null],[11,"is_left","","Return true if the value is the `Left` variant.",0,null],[11,"is_right","","Return true if the value is the `Right` variant.",0,null],[11,"left","","Convert the left side of `Either&lt;L, R&gt;` to an `Option&lt;L&gt;`.",0,null],[11,"right","","Convert the right side of `Either&lt;L, R&gt;` to an `Option&lt;R&gt;`.",0,null],[11,"as_ref","","Convert `&amp;Either&lt;L, R&gt;` to `Either&lt;&amp;L, &amp;R&gt;`.",0,null],[11,"as_mut","","Convert `&amp;mut Either&lt;L, R&gt;` to `Either&lt;&amp;mut L, &amp;mut R&gt;`.",0,null],[11,"flip","","Convert `Either&lt;L, R&gt;` to `Either&lt;R, L&gt;`.",0,null],[11,"map_left","","Apply the function `f` on the value in the `Left` variant if it is present.",0,null],[11,"map_right","","Apply the function `f` on the value in the `Right` variant if it is present.",0,null],[11,"either","","Apply one of two functions depending on contents, unifying their result. If the value is\n`Left(L)` then the first function `f` is applied; if it is `Right(R)` then the second\nfunction `g` is applied.",0,null],[11,"fmt","","",0,null],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"clone","","",0,null],[11,"from","","",0,{"inputs":[{"name":"result"}],"output":{"name":"either"}}],[11,"into","","",0,null],[11,"next","","",0,null],[11,"size_hint","","",0,null],[11,"fold","","",0,null],[11,"next_back","","",0,null],[11,"as_ref","","",0,null],[11,"as_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"fmt","","",0,null]],"paths":[[4,"Either"],[4,"Diff"],[4,"MinMaxResult"],[4,"EitherOrBoth"],[4,"FoldWhile"],[3,"RcIter"],[3,"Unfold"],[3,"Interleave"],[3,"InterleaveShortest"],[3,"PutBack"],[3,"PutBackN"],[3,"Product"],[3,"Batching"],[3,"Step"],[3,"Merge"],[3,"MergeBy"],[3,"MultiPeek"],[3,"Coalesce"],[3,"Dedup"],[3,"TakeWhileRef"],[3,"WhileSome"],[3,"TupleCombinations"],[3,"Combinations"],[3,"UniqueBy"],[3,"Unique"],[3,"Flatten"],[3,"ConsTuples"],[3,"Format"],[3,"FormatWith"],[3,"Groups"],[3,"Group"],[3,"Chunks"],[3,"Chunk"],[3,"Intersperse"],[3,"KMerge"],[3,"PadUsing"],[3,"RepeatN"],[3,"RepeatCall"],[3,"Iterate"],[3,"Tee"],[3,"TupleBuffer"],[3,"Tuples"],[3,"TupleWindows"],[3,"ZipEq"],[3,"ZipLongest"],[3,"Zip"],[8,"Itertools"]]};
searchIndex["libc"] = {"doc":"Crate docs","items":[[3,"group","libc","",null,null],[12,"gr_name","","",0,null],[12,"gr_passwd","","",0,null],[12,"gr_gid","","",0,null],[12,"gr_mem","","",0,null],[3,"utimbuf","","",null,null],[12,"actime","","",1,null],[12,"modtime","","",1,null],[3,"timeval","","",null,null],[12,"tv_sec","","",2,null],[12,"tv_usec","","",2,null],[3,"timespec","","",null,null],[12,"tv_sec","","",3,null],[12,"tv_nsec","","",3,null],[3,"rlimit","","",null,null],[12,"rlim_cur","","",4,null],[12,"rlim_max","","",4,null],[3,"rusage","","",null,null],[12,"ru_utime","","",5,null],[12,"ru_stime","","",5,null],[12,"ru_maxrss","","",5,null],[12,"ru_ixrss","","",5,null],[12,"ru_idrss","","",5,null],[12,"ru_isrss","","",5,null],[12,"ru_minflt","","",5,null],[12,"ru_majflt","","",5,null],[12,"ru_nswap","","",5,null],[12,"ru_inblock","","",5,null],[12,"ru_oublock","","",5,null],[12,"ru_msgsnd","","",5,null],[12,"ru_msgrcv","","",5,null],[12,"ru_nsignals","","",5,null],[12,"ru_nvcsw","","",5,null],[12,"ru_nivcsw","","",5,null],[3,"in_addr","","",null,null],[12,"s_addr","","",6,null],[3,"in6_addr","","",null,null],[12,"s6_addr","","",7,null],[3,"ip_mreq","","",null,null],[12,"imr_multiaddr","","",8,null],[12,"imr_interface","","",8,null],[3,"ipv6_mreq","","",null,null],[12,"ipv6mr_multiaddr","","",9,null],[12,"ipv6mr_interface","","",9,null],[3,"hostent","","",null,null],[12,"h_name","","",10,null],[12,"h_aliases","","",10,null],[12,"h_addrtype","","",10,null],[12,"h_length","","",10,null],[12,"h_addr_list","","",10,null],[3,"iovec","","",null,null],[12,"iov_base","","",11,null],[12,"iov_len","","",11,null],[3,"pollfd","","",null,null],[12,"fd","","",12,null],[12,"events","","",12,null],[12,"revents","","",12,null],[3,"winsize","","",null,null],[12,"ws_row","","",13,null],[12,"ws_col","","",13,null],[12,"ws_xpixel","","",13,null],[12,"ws_ypixel","","",13,null],[3,"linger","","",null,null],[12,"l_onoff","","",14,null],[12,"l_linger","","",14,null],[3,"sockaddr","","",null,null],[12,"sa_family","","",15,null],[12,"sa_data","","",15,null],[3,"sockaddr_in","","",null,null],[12,"sin_family","","",16,null],[12,"sin_port","","",16,null],[12,"sin_addr","","",16,null],[12,"sin_zero","","",16,null],[3,"sockaddr_in6","","",null,null],[12,"sin6_family","","",17,null],[12,"sin6_port","","",17,null],[12,"sin6_flowinfo","","",17,null],[12,"sin6_addr","","",17,null],[12,"sin6_scope_id","","",17,null],[3,"sockaddr_un","","",null,null],[12,"sun_family","","",18,null],[12,"sun_path","","",18,null],[3,"sockaddr_storage","","",null,null],[12,"ss_family","","",19,null],[3,"addrinfo","","",null,null],[12,"ai_flags","","",20,null],[12,"ai_family","","",20,null],[12,"ai_socktype","","",20,null],[12,"ai_protocol","","",20,null],[12,"ai_addrlen","","",20,null],[12,"ai_addr","","",20,null],[12,"ai_canonname","","",20,null],[12,"ai_next","","",20,null],[3,"sockaddr_nl","","",null,null],[12,"nl_family","","",21,null],[12,"nl_pid","","",21,null],[12,"nl_groups","","",21,null],[3,"sockaddr_ll","","",null,null],[12,"sll_family","","",22,null],[12,"sll_protocol","","",22,null],[12,"sll_ifindex","","",22,null],[12,"sll_hatype","","",22,null],[12,"sll_pkttype","","",22,null],[12,"sll_halen","","",22,null],[12,"sll_addr","","",22,null],[3,"fd_set","","",null,null],[3,"tm","","",null,null],[12,"tm_sec","","",23,null],[12,"tm_min","","",23,null],[12,"tm_hour","","",23,null],[12,"tm_mday","","",23,null],[12,"tm_mon","","",23,null],[12,"tm_year","","",23,null],[12,"tm_wday","","",23,null],[12,"tm_yday","","",23,null],[12,"tm_isdst","","",23,null],[12,"tm_gmtoff","","",23,null],[12,"tm_zone","","",23,null],[3,"sched_param","","",null,null],[12,"sched_priority","","",24,null],[3,"Dl_info","","",null,null],[12,"dli_fname","","",25,null],[12,"dli_fbase","","",25,null],[12,"dli_sname","","",25,null],[12,"dli_saddr","","",25,null],[3,"epoll_event","","",null,null],[12,"events","","",26,null],[12,"u64","","",26,null],[3,"utsname","","",null,null],[12,"sysname","","",27,null],[12,"nodename","","",27,null],[12,"release","","",27,null],[12,"version","","",27,null],[12,"machine","","",27,null],[12,"domainname","","",27,null],[3,"lconv","","",null,null],[12,"decimal_point","","",28,null],[12,"thousands_sep","","",28,null],[12,"grouping","","",28,null],[12,"int_curr_symbol","","",28,null],[12,"currency_symbol","","",28,null],[12,"mon_decimal_point","","",28,null],[12,"mon_thousands_sep","","",28,null],[12,"mon_grouping","","",28,null],[12,"positive_sign","","",28,null],[12,"negative_sign","","",28,null],[12,"int_frac_digits","","",28,null],[12,"frac_digits","","",28,null],[12,"p_cs_precedes","","",28,null],[12,"p_sep_by_space","","",28,null],[12,"n_cs_precedes","","",28,null],[12,"n_sep_by_space","","",28,null],[12,"p_sign_posn","","",28,null],[12,"n_sign_posn","","",28,null],[12,"int_p_cs_precedes","","",28,null],[12,"int_p_sep_by_space","","",28,null],[12,"int_n_cs_precedes","","",28,null],[12,"int_n_sep_by_space","","",28,null],[12,"int_p_sign_posn","","",28,null],[12,"int_n_sign_posn","","",28,null],[3,"dirent","","",null,null],[12,"d_ino","","",29,null],[12,"d_off","","",29,null],[12,"d_reclen","","",29,null],[12,"d_type","","",29,null],[12,"d_name","","",29,null],[3,"dirent64","","",null,null],[12,"d_ino","","",30,null],[12,"d_off","","",30,null],[12,"d_reclen","","",30,null],[12,"d_type","","",30,null],[12,"d_name","","",30,null],[3,"rlimit64","","",null,null],[12,"rlim_cur","","",31,null],[12,"rlim_max","","",31,null],[3,"glob_t","","",null,null],[12,"gl_pathc","","",32,null],[12,"gl_pathv","","",32,null],[12,"gl_offs","","",32,null],[12,"gl_flags","","",32,null],[3,"ifaddrs","","",null,null],[12,"ifa_next","","",33,null],[12,"ifa_name","","",33,null],[12,"ifa_flags","","",33,null],[12,"ifa_addr","","",33,null],[12,"ifa_netmask","","",33,null],[12,"ifa_ifu","","",33,null],[12,"ifa_data","","",33,null],[3,"pthread_mutex_t","","",null,null],[3,"pthread_rwlock_t","","",null,null],[3,"pthread_mutexattr_t","","",null,null],[3,"pthread_cond_t","","",null,null],[3,"pthread_condattr_t","","",null,null],[3,"passwd","","",null,null],[12,"pw_name","","",34,null],[12,"pw_passwd","","",34,null],[12,"pw_uid","","",34,null],[12,"pw_gid","","",34,null],[12,"pw_gecos","","",34,null],[12,"pw_dir","","",34,null],[12,"pw_shell","","",34,null],[3,"spwd","","",null,null],[12,"sp_namp","","",35,null],[12,"sp_pwdp","","",35,null],[12,"sp_lstchg","","",35,null],[12,"sp_min","","",35,null],[12,"sp_max","","",35,null],[12,"sp_warn","","",35,null],[12,"sp_inact","","",35,null],[12,"sp_expire","","",35,null],[12,"sp_flag","","",35,null],[3,"statvfs","","",null,null],[12,"f_bsize","","",36,null],[12,"f_frsize","","",36,null],[12,"f_blocks","","",36,null],[12,"f_bfree","","",36,null],[12,"f_bavail","","",36,null],[12,"f_files","","",36,null],[12,"f_ffree","","",36,null],[12,"f_favail","","",36,null],[12,"f_fsid","","",36,null],[12,"f_flag","","",36,null],[12,"f_namemax","","",36,null],[3,"dqblk","","",null,null],[12,"dqb_bhardlimit","","",37,null],[12,"dqb_bsoftlimit","","",37,null],[12,"dqb_curspace","","",37,null],[12,"dqb_ihardlimit","","",37,null],[12,"dqb_isoftlimit","","",37,null],[12,"dqb_curinodes","","",37,null],[12,"dqb_btime","","",37,null],[12,"dqb_itime","","",37,null],[12,"dqb_valid","","",37,null],[3,"signalfd_siginfo","","",null,null],[12,"ssi_signo","","",38,null],[12,"ssi_errno","","",38,null],[12,"ssi_code","","",38,null],[12,"ssi_pid","","",38,null],[12,"ssi_uid","","",38,null],[12,"ssi_fd","","",38,null],[12,"ssi_tid","","",38,null],[12,"ssi_band","","",38,null],[12,"ssi_overrun","","",38,null],[12,"ssi_trapno","","",38,null],[12,"ssi_status","","",38,null],[12,"ssi_int","","",38,null],[12,"ssi_ptr","","",38,null],[12,"ssi_utime","","",38,null],[12,"ssi_stime","","",38,null],[12,"ssi_addr","","",38,null],[3,"fsid_t","","",null,null],[3,"mq_attr","","",null,null],[12,"mq_flags","","",39,null],[12,"mq_maxmsg","","",39,null],[12,"mq_msgsize","","",39,null],[12,"mq_curmsgs","","",39,null],[3,"cpu_set_t","","",null,null],[3,"if_nameindex","","",null,null],[12,"if_index","","",40,null],[12,"if_name","","",40,null],[3,"msginfo","","",null,null],[12,"msgpool","","",41,null],[12,"msgmap","","",41,null],[12,"msgmax","","",41,null],[12,"msgmnb","","",41,null],[12,"msgmni","","",41,null],[12,"msgssz","","",41,null],[12,"msgtql","","",41,null],[12,"msgseg","","",41,null],[3,"__exit_status","","",null,null],[12,"e_termination","","",42,null],[12,"e_exit","","",42,null],[3,"__timeval","","",null,null],[12,"tv_sec","","",43,null],[12,"tv_usec","","",43,null],[3,"utmpx","","",null,null],[12,"ut_type","","",44,null],[12,"ut_pid","","",44,null],[12,"ut_line","","",44,null],[12,"ut_id","","",44,null],[12,"ut_user","","",44,null],[12,"ut_host","","",44,null],[12,"ut_exit","","",44,null],[12,"ut_session","","",44,null],[12,"ut_tv","","",44,null],[12,"ut_addr_v6","","",44,null],[3,"sigaction","","",null,null],[12,"sa_sigaction","","",45,null],[12,"sa_mask","","",45,null],[12,"sa_flags","","",45,null],[3,"stack_t","","",null,null],[12,"ss_sp","","",46,null],[12,"ss_flags","","",46,null],[12,"ss_size","","",46,null],[3,"siginfo_t","","",null,null],[12,"si_signo","","",47,null],[12,"si_errno","","",47,null],[12,"si_code","","",47,null],[12,"_pad","","",47,null],[3,"glob64_t","","",null,null],[12,"gl_pathc","","",48,null],[12,"gl_pathv","","",48,null],[12,"gl_offs","","",48,null],[12,"gl_flags","","",48,null],[3,"ucred","","",null,null],[12,"pid","","",49,null],[12,"uid","","",49,null],[12,"gid","","",49,null],[3,"statfs","","",null,null],[12,"f_type","","",50,null],[12,"f_bsize","","",50,null],[12,"f_blocks","","",50,null],[12,"f_bfree","","",50,null],[12,"f_bavail","","",50,null],[12,"f_files","","",50,null],[12,"f_ffree","","",50,null],[12,"f_fsid","","",50,null],[12,"f_namelen","","",50,null],[12,"f_frsize","","",50,null],[3,"msghdr","","",null,null],[12,"msg_name","","",51,null],[12,"msg_namelen","","",51,null],[12,"msg_iov","","",51,null],[12,"msg_iovlen","","",51,null],[12,"msg_control","","",51,null],[12,"msg_controllen","","",51,null],[12,"msg_flags","","",51,null],[3,"termios","","",null,null],[12,"c_iflag","","",52,null],[12,"c_oflag","","",52,null],[12,"c_cflag","","",52,null],[12,"c_lflag","","",52,null],[12,"c_line","","",52,null],[12,"c_cc","","",52,null],[12,"c_ispeed","","",52,null],[12,"c_ospeed","","",52,null],[3,"flock","","",null,null],[12,"l_type","","",53,null],[12,"l_whence","","",53,null],[12,"l_start","","",53,null],[12,"l_len","","",53,null],[12,"l_pid","","",53,null],[3,"sem_t","","",null,null],[3,"sigset_t","","",null,null],[3,"sysinfo","","",null,null],[12,"uptime","","",54,null],[12,"loads","","",54,null],[12,"totalram","","",54,null],[12,"freeram","","",54,null],[12,"sharedram","","",54,null],[12,"bufferram","","",54,null],[12,"totalswap","","",54,null],[12,"freeswap","","",54,null],[12,"procs","","",54,null],[12,"pad","","",54,null],[12,"totalhigh","","",54,null],[12,"freehigh","","",54,null],[12,"mem_unit","","",54,null],[12,"_f","","",54,null],[3,"msqid_ds","","",null,null],[12,"msg_perm","","",55,null],[12,"msg_stime","","",55,null],[12,"msg_rtime","","",55,null],[12,"msg_ctime","","",55,null],[12,"msg_qnum","","",55,null],[12,"msg_qbytes","","",55,null],[12,"msg_lspid","","",55,null],[12,"msg_lrpid","","",55,null],[3,"stat","","",null,null],[12,"st_dev","","",56,null],[12,"st_ino","","",56,null],[12,"st_nlink","","",56,null],[12,"st_mode","","",56,null],[12,"st_uid","","",56,null],[12,"st_gid","","",56,null],[12,"st_rdev","","",56,null],[12,"st_size","","",56,null],[12,"st_blksize","","",56,null],[12,"st_blocks","","",56,null],[12,"st_atime","","",56,null],[12,"st_atime_nsec","","",56,null],[12,"st_mtime","","",56,null],[12,"st_mtime_nsec","","",56,null],[12,"st_ctime","","",56,null],[12,"st_ctime_nsec","","",56,null],[3,"stat64","","",null,null],[12,"st_dev","","",57,null],[12,"st_ino","","",57,null],[12,"st_nlink","","",57,null],[12,"st_mode","","",57,null],[12,"st_uid","","",57,null],[12,"st_gid","","",57,null],[12,"st_rdev","","",57,null],[12,"st_size","","",57,null],[12,"st_blksize","","",57,null],[12,"st_blocks","","",57,null],[12,"st_atime","","",57,null],[12,"st_atime_nsec","","",57,null],[12,"st_mtime","","",57,null],[12,"st_mtime_nsec","","",57,null],[12,"st_ctime","","",57,null],[12,"st_ctime_nsec","","",57,null],[3,"pthread_attr_t","","",null,null],[3,"_libc_fpxreg","","",null,null],[12,"significand","","",58,null],[12,"exponent","","",58,null],[3,"_libc_xmmreg","","",null,null],[12,"element","","",59,null],[3,"_libc_fpstate","","",null,null],[12,"cwd","","",60,null],[12,"swd","","",60,null],[12,"ftw","","",60,null],[12,"fop","","",60,null],[12,"rip","","",60,null],[12,"rdp","","",60,null],[12,"mxcsr","","",60,null],[12,"mxcr_mask","","",60,null],[12,"_st","","",60,null],[12,"_xmm","","",60,null],[3,"mcontext_t","","",null,null],[12,"gregs","","",61,null],[12,"fpregs","","",61,null],[3,"ucontext_t","","",null,null],[12,"uc_flags","","",62,null],[12,"uc_link","","",62,null],[12,"uc_stack","","",62,null],[12,"uc_mcontext","","",62,null],[12,"uc_sigmask","","",62,null],[3,"ipc_perm","","",null,null],[12,"__key","","",63,null],[12,"uid","","",63,null],[12,"gid","","",63,null],[12,"cuid","","",63,null],[12,"cgid","","",63,null],[12,"mode","","",63,null],[12,"__seq","","",63,null],[3,"shmid_ds","","",null,null],[12,"shm_perm","","",64,null],[12,"shm_segsz","","",64,null],[12,"shm_atime","","",64,null],[12,"shm_dtime","","",64,null],[12,"shm_ctime","","",64,null],[12,"shm_cpid","","",64,null],[12,"shm_lpid","","",64,null],[12,"shm_nattch","","",64,null],[4,"c_void","","",null,null],[4,"FILE","","",null,null],[4,"fpos_t","","",null,null],[4,"DIR","","",null,null],[4,"locale_t","","",null,null],[4,"timezone","","",null,null],[4,"fpos64_t","","",null,null],[5,"FD_CLR","","",null,null],[5,"FD_ISSET","","",null,null],[5,"FD_SET","","",null,null],[5,"FD_ZERO","","",null,null],[5,"WIFSTOPPED","","",null,{"inputs":[{"name":"c_int"}],"output":{"name":"bool"}}],[5,"WSTOPSIG","","",null,{"inputs":[{"name":"c_int"}],"output":{"name":"c_int"}}],[5,"WIFSIGNALED","","",null,{"inputs":[{"name":"c_int"}],"output":{"name":"bool"}}],[5,"WTERMSIG","","",null,{"inputs":[{"name":"c_int"}],"output":{"name":"c_int"}}],[5,"WIFEXITED","","",null,{"inputs":[{"name":"c_int"}],"output":{"name":"bool"}}],[5,"WEXITSTATUS","","",null,{"inputs":[{"name":"c_int"}],"output":{"name":"c_int"}}],[5,"WCOREDUMP","","",null,{"inputs":[{"name":"c_int"}],"output":{"name":"bool"}}],[5,"CPU_ZERO","","",null,null],[5,"CPU_SET","","",null,null],[5,"CPU_CLR","","",null,null],[5,"CPU_ISSET","","",null,{"inputs":[{"name":"usize"},{"name":"cpu_set_t"}],"output":{"name":"bool"}}],[5,"CPU_EQUAL","","",null,{"inputs":[{"name":"cpu_set_t"},{"name":"cpu_set_t"}],"output":{"name":"bool"}}],[5,"isalnum","","",null,null],[5,"isalpha","","",null,null],[5,"iscntrl","","",null,null],[5,"isdigit","","",null,null],[5,"isgraph","","",null,null],[5,"islower","","",null,null],[5,"isprint","","",null,null],[5,"ispunct","","",null,null],[5,"isspace","","",null,null],[5,"isupper","","",null,null],[5,"isxdigit","","",null,null],[5,"tolower","","",null,null],[5,"toupper","","",null,null],[5,"fopen","","",null,null],[5,"freopen","","",null,null],[5,"fflush","","",null,null],[5,"fclose","","",null,null],[5,"remove","","",null,null],[5,"rename","","",null,null],[5,"tmpfile","","",null,null],[5,"setvbuf","","",null,null],[5,"setbuf","","",null,null],[5,"getchar","","",null,null],[5,"putchar","","",null,null],[5,"fgetc","","",null,null],[5,"fgets","","",null,null],[5,"fputc","","",null,null],[5,"fputs","","",null,null],[5,"puts","","",null,null],[5,"ungetc","","",null,null],[5,"fread","","",null,null],[5,"fwrite","","",null,null],[5,"fseek","","",null,null],[5,"ftell","","",null,null],[5,"rewind","","",null,null],[5,"fgetpos","","",null,null],[5,"fsetpos","","",null,null],[5,"feof","","",null,null],[5,"ferror","","",null,null],[5,"perror","","",null,null],[5,"atoi","","",null,null],[5,"strtod","","",null,null],[5,"strtol","","",null,null],[5,"strtoul","","",null,null],[5,"calloc","","",null,null],[5,"malloc","","",null,null],[5,"realloc","","",null,null],[5,"free","","",null,null],[5,"abort","","",null,null],[5,"exit","","",null,null],[5,"_exit","","",null,null],[5,"atexit","","",null,null],[5,"system","","",null,null],[5,"getenv","","",null,null],[5,"strcpy","","",null,null],[5,"strncpy","","",null,null],[5,"strcat","","",null,null],[5,"strncat","","",null,null],[5,"strcmp","","",null,null],[5,"strncmp","","",null,null],[5,"strcoll","","",null,null],[5,"strchr","","",null,null],[5,"strrchr","","",null,null],[5,"strspn","","",null,null],[5,"strcspn","","",null,null],[5,"strdup","","",null,null],[5,"strpbrk","","",null,null],[5,"strstr","","",null,null],[5,"strlen","","",null,null],[5,"strnlen","","",null,null],[5,"strerror","","",null,null],[5,"strtok","","",null,null],[5,"strxfrm","","",null,null],[5,"wcslen","","",null,null],[5,"memchr","","",null,null],[5,"memcmp","","",null,null],[5,"memcpy","","",null,null],[5,"memmove","","",null,null],[5,"memset","","",null,null],[5,"abs","","",null,null],[5,"atof","","",null,null],[5,"labs","","",null,null],[5,"rand","","",null,null],[5,"srand","","",null,null],[5,"getgrnam","","",null,null],[5,"getgrgid","","",null,null],[5,"endpwent","","",null,null],[5,"getpwnam","","",null,null],[5,"getpwuid","","",null,null],[5,"fprintf","","",null,null],[5,"printf","","",null,null],[5,"snprintf","","",null,null],[5,"sprintf","","",null,null],[5,"fscanf","","",null,null],[5,"scanf","","",null,null],[5,"sscanf","","",null,null],[5,"getchar_unlocked","","",null,null],[5,"putchar_unlocked","","",null,null],[5,"socket","","",null,null],[5,"connect","","",null,null],[5,"bind","","",null,null],[5,"listen","","",null,null],[5,"accept","","",null,null],[5,"getpeername","","",null,null],[5,"getsockname","","",null,null],[5,"setsockopt","","",null,null],[5,"socketpair","","",null,null],[5,"sendto","","",null,null],[5,"shutdown","","",null,null],[5,"chmod","","",null,null],[5,"fchmod","","",null,null],[5,"fstat","","",null,null],[5,"mkdir","","",null,null],[5,"stat","","",null,null],[5,"popen","","",null,null],[5,"pclose","","",null,null],[5,"fdopen","","",null,null],[5,"fileno","","",null,null],[5,"open","","",null,null],[5,"creat","","",null,null],[5,"fcntl","","",null,null],[5,"opendir","","",null,null],[5,"readdir_r","","",null,null],[5,"closedir","","",null,null],[5,"rewinddir","","",null,null],[5,"access","","",null,null],[5,"alarm","","",null,null],[5,"chdir","","",null,null],[5,"chown","","",null,null],[5,"lchown","","",null,null],[5,"close","","",null,null],[5,"dup","","",null,null],[5,"dup2","","",null,null],[5,"execv","","",null,null],[5,"execve","","",null,null],[5,"execvp","","",null,null],[5,"fork","","",null,null],[5,"fpathconf","","",null,null],[5,"getcwd","","",null,null],[5,"getegid","","",null,null],[5,"geteuid","","",null,null],[5,"getgid","","",null,null],[5,"getgroups","","",null,null],[5,"getlogin","","",null,null],[5,"getopt","","",null,null],[5,"getpgid","","",null,null],[5,"getpgrp","","",null,null],[5,"getpid","","",null,null],[5,"getppid","","",null,null],[5,"getuid","","",null,null],[5,"isatty","","",null,null],[5,"link","","",null,null],[5,"lseek","","",null,null],[5,"pathconf","","",null,null],[5,"pause","","",null,null],[5,"pipe","","",null,null],[5,"posix_memalign","","",null,null],[5,"read","","",null,null],[5,"rmdir","","",null,null],[5,"setgid","","",null,null],[5,"setpgid","","",null,null],[5,"setsid","","",null,null],[5,"setuid","","",null,null],[5,"sleep","","",null,null],[5,"nanosleep","","",null,null],[5,"tcgetpgrp","","",null,null],[5,"ttyname","","",null,null],[5,"unlink","","",null,null],[5,"wait","","",null,null],[5,"waitpid","","",null,null],[5,"write","","",null,null],[5,"pread","","",null,null],[5,"pwrite","","",null,null],[5,"umask","","",null,null],[5,"utime","","",null,null],[5,"kill","","",null,null],[5,"mlock","","",null,null],[5,"munlock","","",null,null],[5,"mlockall","","",null,null],[5,"munlockall","","",null,null],[5,"mmap","","",null,null],[5,"munmap","","",null,null],[5,"if_nametoindex","","",null,null],[5,"if_indextoname","","",null,null],[5,"lstat","","",null,null],[5,"fsync","","",null,null],[5,"setenv","","",null,null],[5,"unsetenv","","",null,null],[5,"symlink","","",null,null],[5,"ftruncate","","",null,null],[5,"signal","","",null,null],[5,"getrlimit","","",null,null],[5,"setrlimit","","",null,null],[5,"getrusage","","",null,null],[5,"getdtablesize","","",null,null],[5,"realpath","","",null,null],[5,"flock","","",null,null],[5,"gettimeofday","","",null,null],[5,"pthread_self","","",null,null],[5,"pthread_create","","",null,null],[5,"pthread_join","","",null,null],[5,"pthread_attr_init","","",null,null],[5,"pthread_attr_destroy","","",null,null],[5,"pthread_attr_setstacksize","","",null,null],[5,"pthread_attr_setdetachstate","","",null,null],[5,"pthread_detach","","",null,null],[5,"sched_yield","","",null,null],[5,"pthread_key_create","","",null,null],[5,"pthread_key_delete","","",null,null],[5,"pthread_getspecific","","",null,null],[5,"pthread_setspecific","","",null,null],[5,"pthread_mutex_init","","",null,null],[5,"pthread_mutex_destroy","","",null,null],[5,"pthread_mutex_lock","","",null,null],[5,"pthread_mutex_trylock","","",null,null],[5,"pthread_mutex_unlock","","",null,null],[5,"pthread_mutexattr_init","","",null,null],[5,"pthread_mutexattr_destroy","","",null,null],[5,"pthread_mutexattr_settype","","",null,null],[5,"pthread_cond_init","","",null,null],[5,"pthread_cond_wait","","",null,null],[5,"pthread_cond_timedwait","","",null,null],[5,"pthread_cond_signal","","",null,null],[5,"pthread_cond_broadcast","","",null,null],[5,"pthread_cond_destroy","","",null,null],[5,"pthread_condattr_init","","",null,null],[5,"pthread_condattr_destroy","","",null,null],[5,"pthread_rwlock_destroy","","",null,null],[5,"pthread_rwlock_rdlock","","",null,null],[5,"pthread_rwlock_tryrdlock","","",null,null],[5,"pthread_rwlock_wrlock","","",null,null],[5,"pthread_rwlock_trywrlock","","",null,null],[5,"pthread_rwlock_unlock","","",null,null],[5,"pthread_sigmask","","",null,null],[5,"pthread_kill","","",null,null],[5,"strerror_r","","",null,null],[5,"getsockopt","","",null,null],[5,"raise","","",null,null],[5,"sigaction","","",null,null],[5,"sigaltstack","","",null,null],[5,"sigwait","","",null,null],[5,"utimes","","",null,null],[5,"dlopen","","",null,null],[5,"dlerror","","",null,null],[5,"dlsym","","",null,null],[5,"dlclose","","",null,null],[5,"dladdr","","",null,null],[5,"getaddrinfo","","",null,null],[5,"freeaddrinfo","","",null,null],[5,"gai_strerror","","",null,null],[5,"gmtime_r","","",null,null],[5,"localtime_r","","",null,null],[5,"mktime","","",null,null],[5,"time","","",null,null],[5,"localtime","","",null,null],[5,"mknod","","",null,null],[5,"writev","","",null,null],[5,"readv","","",null,null],[5,"uname","","",null,null],[5,"daemon","","",null,null],[5,"gethostname","","",null,null],[5,"chroot","","",null,null],[5,"usleep","","",null,null],[5,"send","","",null,null],[5,"recv","","",null,null],[5,"putenv","","",null,null],[5,"sendmsg","","",null,null],[5,"recvmsg","","",null,null],[5,"poll","","",null,null],[5,"select","","",null,null],[5,"setlocale","","",null,null],[5,"localeconv","","",null,null],[5,"sem_destroy","","",null,null],[5,"sem_open","","",null,null],[5,"sem_close","","",null,null],[5,"sem_unlink","","",null,null],[5,"sem_wait","","",null,null],[5,"sem_trywait","","",null,null],[5,"sem_post","","",null,null],[5,"sem_init","","",null,null],[5,"glob","","",null,null],[5,"globfree","","",null,null],[5,"posix_madvise","","",null,null],[5,"shm_unlink","","",null,null],[5,"seekdir","","",null,null],[5,"telldir","","",null,null],[5,"getsid","","",null,null],[5,"madvise","","",null,null],[5,"readlink","","",null,null],[5,"msync","","",null,null],[5,"sysconf","","",null,null],[5,"recvfrom","","",null,null],[5,"mkfifo","","",null,null],[5,"sigemptyset","","",null,null],[5,"sigaddset","","",null,null],[5,"sigfillset","","",null,null],[5,"sigdelset","","",null,null],[5,"sigismember","","",null,null],[5,"pselect","","",null,null],[5,"fseeko","","",null,null],[5,"ftello","","",null,null],[5,"timegm","","",null,null],[5,"statvfs","","",null,null],[5,"fstatvfs","","",null,null],[5,"tcdrain","","",null,null],[5,"cfgetispeed","","",null,null],[5,"cfgetospeed","","",null,null],[5,"cfsetispeed","","",null,null],[5,"cfsetospeed","","",null,null],[5,"tcgetattr","","",null,null],[5,"tcsetattr","","",null,null],[5,"tcflow","","",null,null],[5,"tcflush","","",null,null],[5,"tcsendbreak","","",null,null],[5,"mkstemp","","",null,null],[5,"mkstemps","","",null,null],[5,"mkdtemp","","",null,null],[5,"futimes","","",null,null],[5,"nl_langinfo","","",null,null],[5,"openlog","","",null,null],[5,"closelog","","",null,null],[5,"setlogmask","","",null,null],[5,"syslog","","",null,null],[5,"nice","","",null,null],[5,"getpwnam_r","","",null,null],[5,"getpwuid_r","","",null,null],[5,"fdatasync","","",null,null],[5,"mincore","","",null,null],[5,"clock_getres","","",null,null],[5,"clock_gettime","","",null,null],[5,"clock_nanosleep","","",null,null],[5,"prctl","","",null,null],[5,"pthread_getattr_np","","",null,null],[5,"pthread_attr_getguardsize","","",null,null],[5,"pthread_attr_getstack","","",null,null],[5,"memalign","","",null,null],[5,"setgroups","","",null,null],[5,"sched_setscheduler","","",null,null],[5,"sched_getscheduler","","",null,null],[5,"sched_get_priority_max","","",null,null],[5,"sched_get_priority_min","","",null,null],[5,"epoll_create","","",null,null],[5,"epoll_create1","","",null,null],[5,"epoll_ctl","","",null,null],[5,"epoll_wait","","",null,null],[5,"pipe2","","",null,null],[5,"mount","","",null,null],[5,"umount","","",null,null],[5,"umount2","","",null,null],[5,"clone","","",null,null],[5,"statfs","","",null,null],[5,"fstatfs","","",null,null],[5,"memrchr","","",null,null],[5,"syscall","","",null,null],[5,"sendfile","","",null,null],[5,"splice","","",null,null],[5,"tee","","",null,null],[5,"vmsplice","","",null,null],[5,"posix_fadvise","","",null,null],[5,"futimens","","",null,null],[5,"utimensat","","",null,null],[5,"duplocale","","",null,null],[5,"freelocale","","",null,null],[5,"newlocale","","",null,null],[5,"uselocale","","",null,null],[5,"creat64","","",null,null],[5,"fstat64","","",null,null],[5,"ftruncate64","","",null,null],[5,"getrlimit64","","",null,null],[5,"lseek64","","",null,null],[5,"lstat64","","",null,null],[5,"mmap64","","",null,null],[5,"open64","","",null,null],[5,"pread64","","",null,null],[5,"pwrite64","","",null,null],[5,"readdir64_r","","",null,null],[5,"setrlimit64","","",null,null],[5,"stat64","","",null,null],[5,"eventfd","","",null,null],[5,"sysinfo","","",null,null],[5,"openat","","",null,null],[5,"faccessat","","",null,null],[5,"fchmodat","","",null,null],[5,"fchownat","","",null,null],[5,"fstatat","","",null,null],[5,"linkat","","",null,null],[5,"mkdirat","","",null,null],[5,"mknodat","","",null,null],[5,"readlinkat","","",null,null],[5,"renameat","","",null,null],[5,"symlinkat","","",null,null],[5,"unlinkat","","",null,null],[5,"pthread_condattr_getclock","","",null,null],[5,"pthread_condattr_setclock","","",null,null],[5,"sched_getaffinity","","",null,null],[5,"sched_setaffinity","","",null,null],[5,"unshare","","",null,null],[5,"setns","","",null,null],[5,"sem_timedwait","","",null,null],[5,"accept4","","",null,null],[5,"pthread_mutex_timedlock","","",null,null],[5,"lutimes","","",null,null],[5,"setpwent","","",null,null],[5,"getpwent","","",null,null],[5,"setspent","","",null,null],[5,"endspent","","",null,null],[5,"getspent","","",null,null],[5,"getspnam","","",null,null],[5,"shm_open","","",null,null],[5,"shmget","","",null,null],[5,"shmat","","",null,null],[5,"shmdt","","",null,null],[5,"shmctl","","",null,null],[5,"ftok","","",null,null],[5,"msgctl","","",null,null],[5,"msgget","","",null,null],[5,"msgrcv","","",null,null],[5,"msgsnd","","",null,null],[5,"mprotect","","",null,null],[5,"__errno_location","","",null,null],[5,"fopen64","","",null,null],[5,"freopen64","","",null,null],[5,"tmpfile64","","",null,null],[5,"fgetpos64","","",null,null],[5,"fsetpos64","","",null,null],[5,"fseeko64","","",null,null],[5,"ftello64","","",null,null],[5,"fallocate","","",null,null],[5,"posix_fallocate","","",null,null],[5,"readahead","","",null,null],[5,"getxattr","","",null,null],[5,"lgetxattr","","",null,null],[5,"fgetxattr","","",null,null],[5,"setxattr","","",null,null],[5,"lsetxattr","","",null,null],[5,"fsetxattr","","",null,null],[5,"listxattr","","",null,null],[5,"llistxattr","","",null,null],[5,"flistxattr","","",null,null],[5,"removexattr","","",null,null],[5,"lremovexattr","","",null,null],[5,"fremovexattr","","",null,null],[5,"signalfd","","",null,null],[5,"pwritev","","",null,null],[5,"preadv","","",null,null],[5,"quotactl","","",null,null],[5,"mq_open","","",null,null],[5,"mq_close","","",null,null],[5,"mq_unlink","","",null,null],[5,"mq_receive","","",null,null],[5,"mq_send","","",null,null],[5,"mq_getattr","","",null,null],[5,"mq_setattr","","",null,null],[5,"epoll_pwait","","",null,null],[5,"dup3","","",null,null],[5,"sethostname","","",null,null],[5,"mkostemp","","",null,null],[5,"mkostemps","","",null,null],[5,"sigtimedwait","","",null,null],[5,"sigwaitinfo","","",null,null],[5,"openpty","","",null,null],[5,"forkpty","","",null,null],[5,"nl_langinfo_l","","",null,null],[5,"getnameinfo","","",null,null],[5,"prlimit","","",null,null],[5,"prlimit64","","",null,null],[5,"getloadavg","","",null,null],[5,"process_vm_readv","","",null,null],[5,"process_vm_writev","","",null,null],[5,"reboot","","",null,null],[5,"mkfifoat","","",null,null],[5,"if_nameindex","","",null,null],[5,"if_freenameindex","","",null,null],[5,"sync_file_range","","",null,null],[5,"getifaddrs","","",null,null],[5,"freeifaddrs","","",null,null],[5,"utmpxname","","",null,null],[5,"getutxent","","",null,null],[5,"getutxid","","",null,null],[5,"getutxline","","",null,null],[5,"pututxline","","",null,null],[5,"setutxent","","",null,null],[5,"endutxent","","",null,null],[5,"sysctl","","",null,null],[5,"ioctl","","",null,null],[5,"backtrace","","",null,null],[5,"glob64","","",null,null],[5,"globfree64","","",null,null],[5,"ptrace","","",null,null],[5,"pthread_attr_getaffinity_np","","",null,null],[5,"pthread_attr_setaffinity_np","","",null,null],[5,"getpriority","","",null,null],[5,"setpriority","","",null,null],[5,"pthread_getaffinity_np","","",null,null],[5,"pthread_setaffinity_np","","",null,null],[5,"sched_getcpu","","",null,null],[5,"getcontext","","",null,null],[5,"setcontext","","",null,null],[5,"makecontext","","",null,null],[5,"swapcontext","","",null,null],[11,"clone","","",56,null],[11,"clone","","",57,null],[11,"clone","","",65,null],[11,"clone","","",58,null],[11,"clone","","",59,null],[11,"clone","","",60,null],[11,"clone","","",61,null],[11,"clone","","",62,null],[11,"clone","","",63,null],[11,"clone","","",64,null],[11,"clone","","",66,null],[11,"clone","","",54,null],[11,"clone","","",55,null],[11,"clone","","",42,null],[11,"clone","","",43,null],[11,"clone","","",44,null],[11,"clone","","",45,null],[11,"clone","","",46,null],[11,"clone","","",47,null],[11,"clone","","",48,null],[11,"clone","","",49,null],[11,"clone","","",50,null],[11,"clone","","",51,null],[11,"clone","","",52,null],[11,"clone","","",53,null],[11,"clone","","",67,null],[11,"clone","","",29,null],[11,"clone","","",30,null],[11,"clone","","",31,null],[11,"clone","","",32,null],[11,"clone","","",33,null],[11,"clone","","",68,null],[11,"clone","","",69,null],[11,"clone","","",70,null],[11,"clone","","",71,null],[11,"clone","","",72,null],[11,"clone","","",34,null],[11,"clone","","",35,null],[11,"clone","","",36,null],[11,"clone","","",37,null],[11,"clone","","",38,null],[11,"clone","","",73,null],[11,"clone","","",39,null],[11,"clone","","",74,null],[11,"clone","","",40,null],[11,"clone","","",41,null],[11,"clone","","",15,null],[11,"clone","","",16,null],[11,"clone","","",17,null],[11,"clone","","",18,null],[11,"clone","","",19,null],[11,"clone","","",20,null],[11,"clone","","",21,null],[11,"clone","","",22,null],[11,"clone","","",75,null],[11,"clone","","",23,null],[11,"clone","","",24,null],[11,"clone","","",25,null],[11,"clone","","",26,null],[11,"clone","","",27,null],[11,"clone","","",28,null],[11,"clone","","",0,null],[11,"clone","","",1,null],[11,"clone","","",2,null],[11,"clone","","",3,null],[11,"clone","","",4,null],[11,"clone","","",5,null],[11,"clone","","",6,null],[11,"clone","","",7,null],[11,"clone","","",8,null],[11,"clone","","",9,null],[11,"clone","","",10,null],[11,"clone","","",11,null],[11,"clone","","",12,null],[11,"clone","","",13,null],[11,"clone","","",14,null],[6,"int8_t","","",null,null],[6,"int16_t","","",null,null],[6,"int32_t","","",null,null],[6,"int64_t","","",null,null],[6,"uint8_t","","",null,null],[6,"uint16_t","","",null,null],[6,"uint32_t","","",null,null],[6,"uint64_t","","",null,null],[6,"c_schar","","",null,null],[6,"c_uchar","","",null,null],[6,"c_short","","",null,null],[6,"c_ushort","","",null,null],[6,"c_int","","",null,null],[6,"c_uint","","",null,null],[6,"c_float","","",null,null],[6,"c_double","","",null,null],[6,"c_longlong","","",null,null],[6,"c_ulonglong","","",null,null],[6,"intmax_t","","",null,null],[6,"uintmax_t","","",null,null],[6,"size_t","","",null,null],[6,"ptrdiff_t","","",null,null],[6,"intptr_t","","",null,null],[6,"uintptr_t","","",null,null],[6,"ssize_t","","",null,null],[6,"pid_t","","",null,null],[6,"uid_t","","",null,null],[6,"gid_t","","",null,null],[6,"in_addr_t","","",null,null],[6,"in_port_t","","",null,null],[6,"sighandler_t","","",null,null],[6,"cc_t","","",null,null],[6,"sa_family_t","","",null,null],[6,"pthread_key_t","","",null,null],[6,"speed_t","","",null,null],[6,"tcflag_t","","",null,null],[6,"loff_t","","",null,null],[6,"clockid_t","","",null,null],[6,"key_t","","",null,null],[6,"id_t","","",null,null],[6,"useconds_t","","",null,null],[6,"dev_t","","",null,null],[6,"socklen_t","","",null,null],[6,"pthread_t","","",null,null],[6,"mode_t","","",null,null],[6,"ino64_t","","",null,null],[6,"off64_t","","",null,null],[6,"blkcnt64_t","","",null,null],[6,"rlim64_t","","",null,null],[6,"shmatt_t","","",null,null],[6,"mqd_t","","",null,null],[6,"msgqnum_t","","",null,null],[6,"msglen_t","","",null,null],[6,"nfds_t","","",null,null],[6,"nl_item","","",null,null],[6,"fsblkcnt_t","","",null,null],[6,"fsfilcnt_t","","",null,null],[6,"rlim_t","","",null,null],[6,"__priority_which_t","","",null,null],[6,"c_long","","",null,null],[6,"c_ulong","","",null,null],[6,"clock_t","","",null,null],[6,"time_t","","",null,null],[6,"suseconds_t","","",null,null],[6,"ino_t","","",null,null],[6,"off_t","","",null,null],[6,"blkcnt_t","","",null,null],[6,"__fsword_t","","",null,null],[6,"c_char","","",null,null],[6,"wchar_t","","",null,null],[6,"nlink_t","","",null,null],[6,"blksize_t","","",null,null],[6,"greg_t","","",null,null],[17,"SIG_DFL","","",null,null],[17,"SIG_IGN","","",null,null],[17,"SIG_ERR","","",null,null],[17,"DT_FIFO","","",null,null],[17,"DT_CHR","","",null,null],[17,"DT_DIR","","",null,null],[17,"DT_BLK","","",null,null],[17,"DT_REG","","",null,null],[17,"DT_LNK","","",null,null],[17,"DT_SOCK","","",null,null],[17,"FD_CLOEXEC","","",null,null],[17,"USRQUOTA","","",null,null],[17,"GRPQUOTA","","",null,null],[17,"SIGIOT","","",null,null],[17,"S_ISUID","","",null,null],[17,"S_ISGID","","",null,null],[17,"S_ISVTX","","",null,null],[17,"POLLIN","","",null,null],[17,"POLLPRI","","",null,null],[17,"POLLOUT","","",null,null],[17,"POLLERR","","",null,null],[17,"POLLHUP","","",null,null],[17,"POLLNVAL","","",null,null],[17,"IF_NAMESIZE","","",null,null],[17,"RTLD_LAZY","","",null,null],[17,"LOG_EMERG","","",null,null],[17,"LOG_ALERT","","",null,null],[17,"LOG_CRIT","","",null,null],[17,"LOG_ERR","","",null,null],[17,"LOG_WARNING","","",null,null],[17,"LOG_NOTICE","","",null,null],[17,"LOG_INFO","","",null,null],[17,"LOG_DEBUG","","",null,null],[17,"LOG_KERN","","",null,null],[17,"LOG_USER","","",null,null],[17,"LOG_MAIL","","",null,null],[17,"LOG_DAEMON","","",null,null],[17,"LOG_AUTH","","",null,null],[17,"LOG_SYSLOG","","",null,null],[17,"LOG_LPR","","",null,null],[17,"LOG_NEWS","","",null,null],[17,"LOG_UUCP","","",null,null],[17,"LOG_LOCAL0","","",null,null],[17,"LOG_LOCAL1","","",null,null],[17,"LOG_LOCAL2","","",null,null],[17,"LOG_LOCAL3","","",null,null],[17,"LOG_LOCAL4","","",null,null],[17,"LOG_LOCAL5","","",null,null],[17,"LOG_LOCAL6","","",null,null],[17,"LOG_LOCAL7","","",null,null],[17,"LOG_PID","","",null,null],[17,"LOG_CONS","","",null,null],[17,"LOG_ODELAY","","",null,null],[17,"LOG_NDELAY","","",null,null],[17,"LOG_NOWAIT","","",null,null],[17,"LOG_PRIMASK","","",null,null],[17,"LOG_FACMASK","","",null,null],[17,"PRIO_PROCESS","","",null,null],[17,"PRIO_PGRP","","",null,null],[17,"PRIO_USER","","",null,null],[17,"PRIO_MIN","","",null,null],[17,"PRIO_MAX","","",null,null],[17,"EXIT_FAILURE","","",null,null],[17,"EXIT_SUCCESS","","",null,null],[17,"RAND_MAX","","",null,null],[17,"EOF","","",null,null],[17,"SEEK_SET","","",null,null],[17,"SEEK_CUR","","",null,null],[17,"SEEK_END","","",null,null],[17,"_IOFBF","","",null,null],[17,"_IONBF","","",null,null],[17,"_IOLBF","","",null,null],[17,"F_DUPFD","","",null,null],[17,"F_GETFD","","",null,null],[17,"F_SETFD","","",null,null],[17,"F_GETFL","","",null,null],[17,"F_SETFL","","",null,null],[17,"F_SETLEASE","","",null,null],[17,"F_GETLEASE","","",null,null],[17,"F_NOTIFY","","",null,null],[17,"F_DUPFD_CLOEXEC","","",null,null],[17,"F_SETPIPE_SZ","","",null,null],[17,"F_GETPIPE_SZ","","",null,null],[17,"SIGTRAP","","",null,null],[17,"PTHREAD_CREATE_JOINABLE","","",null,null],[17,"PTHREAD_CREATE_DETACHED","","",null,null],[17,"CLOCK_REALTIME","","",null,null],[17,"CLOCK_MONOTONIC","","",null,null],[17,"CLOCK_PROCESS_CPUTIME_ID","","",null,null],[17,"CLOCK_THREAD_CPUTIME_ID","","",null,null],[17,"CLOCK_MONOTONIC_RAW","","",null,null],[17,"CLOCK_REALTIME_COARSE","","",null,null],[17,"CLOCK_MONOTONIC_COARSE","","",null,null],[17,"CLOCK_BOOTTIME","","",null,null],[17,"CLOCK_REALTIME_ALARM","","",null,null],[17,"CLOCK_BOOTTIME_ALARM","","",null,null],[17,"TIMER_ABSTIME","","",null,null],[17,"RLIMIT_CPU","","",null,null],[17,"RLIMIT_FSIZE","","",null,null],[17,"RLIMIT_DATA","","",null,null],[17,"RLIMIT_STACK","","",null,null],[17,"RLIMIT_CORE","","",null,null],[17,"RLIMIT_LOCKS","","",null,null],[17,"RLIMIT_SIGPENDING","","",null,null],[17,"RLIMIT_MSGQUEUE","","",null,null],[17,"RLIMIT_NICE","","",null,null],[17,"RLIMIT_RTPRIO","","",null,null],[17,"RUSAGE_SELF","","",null,null],[17,"O_RDONLY","","",null,null],[17,"O_WRONLY","","",null,null],[17,"O_RDWR","","",null,null],[17,"O_TRUNC","","",null,null],[17,"O_CLOEXEC","","",null,null],[17,"SOCK_CLOEXEC","","",null,null],[17,"S_IFIFO","","",null,null],[17,"S_IFCHR","","",null,null],[17,"S_IFBLK","","",null,null],[17,"S_IFDIR","","",null,null],[17,"S_IFREG","","",null,null],[17,"S_IFLNK","","",null,null],[17,"S_IFSOCK","","",null,null],[17,"S_IFMT","","",null,null],[17,"S_IRWXU","","",null,null],[17,"S_IXUSR","","",null,null],[17,"S_IWUSR","","",null,null],[17,"S_IRUSR","","",null,null],[17,"S_IRWXG","","",null,null],[17,"S_IXGRP","","",null,null],[17,"S_IWGRP","","",null,null],[17,"S_IRGRP","","",null,null],[17,"S_IRWXO","","",null,null],[17,"S_IXOTH","","",null,null],[17,"S_IWOTH","","",null,null],[17,"S_IROTH","","",null,null],[17,"F_OK","","",null,null],[17,"R_OK","","",null,null],[17,"W_OK","","",null,null],[17,"X_OK","","",null,null],[17,"STDIN_FILENO","","",null,null],[17,"STDOUT_FILENO","","",null,null],[17,"STDERR_FILENO","","",null,null],[17,"SIGHUP","","",null,null],[17,"SIGINT","","",null,null],[17,"SIGQUIT","","",null,null],[17,"SIGILL","","",null,null],[17,"SIGABRT","","",null,null],[17,"SIGFPE","","",null,null],[17,"SIGKILL","","",null,null],[17,"SIGSEGV","","",null,null],[17,"SIGPIPE","","",null,null],[17,"SIGALRM","","",null,null],[17,"SIGTERM","","",null,null],[17,"PROT_NONE","","",null,null],[17,"PROT_READ","","",null,null],[17,"PROT_WRITE","","",null,null],[17,"PROT_EXEC","","",null,null],[17,"LC_CTYPE","","",null,null],[17,"LC_NUMERIC","","",null,null],[17,"LC_TIME","","",null,null],[17,"LC_COLLATE","","",null,null],[17,"LC_MONETARY","","",null,null],[17,"LC_MESSAGES","","",null,null],[17,"LC_ALL","","",null,null],[17,"LC_CTYPE_MASK","","",null,null],[17,"LC_NUMERIC_MASK","","",null,null],[17,"LC_TIME_MASK","","",null,null],[17,"LC_COLLATE_MASK","","",null,null],[17,"LC_MONETARY_MASK","","",null,null],[17,"LC_MESSAGES_MASK","","",null,null],[17,"MAP_FILE","","",null,null],[17,"MAP_SHARED","","",null,null],[17,"MAP_PRIVATE","","",null,null],[17,"MAP_FIXED","","",null,null],[17,"MAP_FAILED","","",null,null],[17,"MS_ASYNC","","",null,null],[17,"MS_INVALIDATE","","",null,null],[17,"MS_SYNC","","",null,null],[17,"MS_RDONLY","","",null,null],[17,"MS_NOSUID","","",null,null],[17,"MS_NODEV","","",null,null],[17,"MS_NOEXEC","","",null,null],[17,"MS_SYNCHRONOUS","","",null,null],[17,"MS_REMOUNT","","",null,null],[17,"MS_MANDLOCK","","",null,null],[17,"MS_DIRSYNC","","",null,null],[17,"MS_NOATIME","","",null,null],[17,"MS_NODIRATIME","","",null,null],[17,"MS_BIND","","",null,null],[17,"MS_MOVE","","",null,null],[17,"MS_REC","","",null,null],[17,"MS_SILENT","","",null,null],[17,"MS_POSIXACL","","",null,null],[17,"MS_UNBINDABLE","","",null,null],[17,"MS_PRIVATE","","",null,null],[17,"MS_SLAVE","","",null,null],[17,"MS_SHARED","","",null,null],[17,"MS_RELATIME","","",null,null],[17,"MS_KERNMOUNT","","",null,null],[17,"MS_I_VERSION","","",null,null],[17,"MS_STRICTATIME","","",null,null],[17,"MS_ACTIVE","","",null,null],[17,"MS_NOUSER","","",null,null],[17,"MS_MGC_VAL","","",null,null],[17,"MS_MGC_MSK","","",null,null],[17,"MS_RMT_MASK","","",null,null],[17,"EPERM","","",null,null],[17,"ENOENT","","",null,null],[17,"ESRCH","","",null,null],[17,"EINTR","","",null,null],[17,"EIO","","",null,null],[17,"ENXIO","","",null,null],[17,"E2BIG","","",null,null],[17,"ENOEXEC","","",null,null],[17,"EBADF","","",null,null],[17,"ECHILD","","",null,null],[17,"EAGAIN","","",null,null],[17,"ENOMEM","","",null,null],[17,"EACCES","","",null,null],[17,"EFAULT","","",null,null],[17,"ENOTBLK","","",null,null],[17,"EBUSY","","",null,null],[17,"EEXIST","","",null,null],[17,"EXDEV","","",null,null],[17,"ENODEV","","",null,null],[17,"ENOTDIR","","",null,null],[17,"EISDIR","","",null,null],[17,"EINVAL","","",null,null],[17,"ENFILE","","",null,null],[17,"EMFILE","","",null,null],[17,"ENOTTY","","",null,null],[17,"ETXTBSY","","",null,null],[17,"EFBIG","","",null,null],[17,"ENOSPC","","",null,null],[17,"ESPIPE","","",null,null],[17,"EROFS","","",null,null],[17,"EMLINK","","",null,null],[17,"EPIPE","","",null,null],[17,"EDOM","","",null,null],[17,"ERANGE","","",null,null],[17,"EWOULDBLOCK","","",null,null],[17,"EBFONT","","",null,null],[17,"ENOSTR","","",null,null],[17,"ENODATA","","",null,null],[17,"ETIME","","",null,null],[17,"ENOSR","","",null,null],[17,"ENONET","","",null,null],[17,"ENOPKG","","",null,null],[17,"EREMOTE","","",null,null],[17,"ENOLINK","","",null,null],[17,"EADV","","",null,null],[17,"ESRMNT","","",null,null],[17,"ECOMM","","",null,null],[17,"EPROTO","","",null,null],[17,"EDOTDOT","","",null,null],[17,"AF_PACKET","","",null,null],[17,"IPPROTO_RAW","","",null,null],[17,"PROT_GROWSDOWN","","",null,null],[17,"PROT_GROWSUP","","",null,null],[17,"MAP_TYPE","","",null,null],[17,"MADV_NORMAL","","",null,null],[17,"MADV_RANDOM","","",null,null],[17,"MADV_SEQUENTIAL","","",null,null],[17,"MADV_WILLNEED","","",null,null],[17,"MADV_DONTNEED","","",null,null],[17,"MADV_REMOVE","","",null,null],[17,"MADV_DONTFORK","","",null,null],[17,"MADV_DOFORK","","",null,null],[17,"MADV_MERGEABLE","","",null,null],[17,"MADV_UNMERGEABLE","","",null,null],[17,"MADV_HWPOISON","","",null,null],[17,"IFF_UP","","",null,null],[17,"IFF_BROADCAST","","",null,null],[17,"IFF_DEBUG","","",null,null],[17,"IFF_LOOPBACK","","",null,null],[17,"IFF_POINTOPOINT","","",null,null],[17,"IFF_NOTRAILERS","","",null,null],[17,"IFF_RUNNING","","",null,null],[17,"IFF_NOARP","","",null,null],[17,"IFF_PROMISC","","",null,null],[17,"IFF_ALLMULTI","","",null,null],[17,"IFF_MASTER","","",null,null],[17,"IFF_SLAVE","","",null,null],[17,"IFF_MULTICAST","","",null,null],[17,"IFF_PORTSEL","","",null,null],[17,"IFF_AUTOMEDIA","","",null,null],[17,"IFF_DYNAMIC","","",null,null],[17,"AF_UNIX","","",null,null],[17,"AF_INET","","",null,null],[17,"AF_INET6","","",null,null],[17,"AF_NETLINK","","",null,null],[17,"SOCK_RAW","","",null,null],[17,"IPPROTO_TCP","","",null,null],[17,"IPPROTO_IP","","",null,null],[17,"IPPROTO_IPV6","","",null,null],[17,"IP_MULTICAST_TTL","","",null,null],[17,"IP_MULTICAST_LOOP","","",null,null],[17,"IP_TTL","","",null,null],[17,"IP_HDRINCL","","",null,null],[17,"IP_ADD_MEMBERSHIP","","",null,null],[17,"IP_DROP_MEMBERSHIP","","",null,null],[17,"IP_TRANSPARENT","","",null,null],[17,"IPV6_ADD_MEMBERSHIP","","",null,null],[17,"IPV6_DROP_MEMBERSHIP","","",null,null],[17,"TCP_NODELAY","","",null,null],[17,"TCP_MAXSEG","","",null,null],[17,"TCP_CORK","","",null,null],[17,"TCP_KEEPIDLE","","",null,null],[17,"TCP_KEEPINTVL","","",null,null],[17,"TCP_KEEPCNT","","",null,null],[17,"TCP_SYNCNT","","",null,null],[17,"TCP_LINGER2","","",null,null],[17,"TCP_DEFER_ACCEPT","","",null,null],[17,"TCP_WINDOW_CLAMP","","",null,null],[17,"TCP_INFO","","",null,null],[17,"TCP_QUICKACK","","",null,null],[17,"TCP_CONGESTION","","",null,null],[17,"IPV6_MULTICAST_LOOP","","",null,null],[17,"IPV6_V6ONLY","","",null,null],[17,"SO_DEBUG","","",null,null],[17,"MSG_NOSIGNAL","","",null,null],[17,"SHUT_RD","","",null,null],[17,"SHUT_WR","","",null,null],[17,"SHUT_RDWR","","",null,null],[17,"LOCK_SH","","",null,null],[17,"LOCK_EX","","",null,null],[17,"LOCK_NB","","",null,null],[17,"LOCK_UN","","",null,null],[17,"SA_NODEFER","","",null,null],[17,"SA_RESETHAND","","",null,null],[17,"SA_RESTART","","",null,null],[17,"SA_NOCLDSTOP","","",null,null],[17,"SS_ONSTACK","","",null,null],[17,"SS_DISABLE","","",null,null],[17,"PATH_MAX","","",null,null],[17,"FD_SETSIZE","","",null,null],[17,"EPOLLIN","","",null,null],[17,"EPOLLPRI","","",null,null],[17,"EPOLLOUT","","",null,null],[17,"EPOLLRDNORM","","",null,null],[17,"EPOLLRDBAND","","",null,null],[17,"EPOLLWRNORM","","",null,null],[17,"EPOLLWRBAND","","",null,null],[17,"EPOLLMSG","","",null,null],[17,"EPOLLERR","","",null,null],[17,"EPOLLHUP","","",null,null],[17,"EPOLLET","","",null,null],[17,"EPOLL_CTL_ADD","","",null,null],[17,"EPOLL_CTL_MOD","","",null,null],[17,"EPOLL_CTL_DEL","","",null,null],[17,"EPOLL_CLOEXEC","","",null,null],[17,"MNT_DETACH","","",null,null],[17,"MNT_EXPIRE","","",null,null],[17,"Q_GETFMT","","",null,null],[17,"Q_GETINFO","","",null,null],[17,"Q_SETINFO","","",null,null],[17,"QIF_BLIMITS","","",null,null],[17,"QIF_SPACE","","",null,null],[17,"QIF_ILIMITS","","",null,null],[17,"QIF_INODES","","",null,null],[17,"QIF_BTIME","","",null,null],[17,"QIF_ITIME","","",null,null],[17,"QIF_LIMITS","","",null,null],[17,"QIF_USAGE","","",null,null],[17,"QIF_TIMES","","",null,null],[17,"QIF_ALL","","",null,null],[17,"EFD_CLOEXEC","","",null,null],[17,"MNT_FORCE","","",null,null],[17,"Q_SYNC","","",null,null],[17,"Q_QUOTAON","","",null,null],[17,"Q_QUOTAOFF","","",null,null],[17,"Q_GETQUOTA","","",null,null],[17,"Q_SETQUOTA","","",null,null],[17,"TCIOFF","","",null,null],[17,"TCION","","",null,null],[17,"TCOOFF","","",null,null],[17,"TCOON","","",null,null],[17,"TCIFLUSH","","",null,null],[17,"TCOFLUSH","","",null,null],[17,"TCIOFLUSH","","",null,null],[17,"NL0","","",null,null],[17,"NL1","","",null,null],[17,"TAB0","","",null,null],[17,"CR0","","",null,null],[17,"FF0","","",null,null],[17,"BS0","","",null,null],[17,"VT0","","",null,null],[17,"VERASE","","",null,null],[17,"VKILL","","",null,null],[17,"VINTR","","",null,null],[17,"VQUIT","","",null,null],[17,"VLNEXT","","",null,null],[17,"IGNBRK","","",null,null],[17,"BRKINT","","",null,null],[17,"IGNPAR","","",null,null],[17,"PARMRK","","",null,null],[17,"INPCK","","",null,null],[17,"ISTRIP","","",null,null],[17,"INLCR","","",null,null],[17,"IGNCR","","",null,null],[17,"ICRNL","","",null,null],[17,"IXANY","","",null,null],[17,"IMAXBEL","","",null,null],[17,"OPOST","","",null,null],[17,"CS5","","",null,null],[17,"CRTSCTS","","",null,null],[17,"ECHO","","",null,null],[17,"CLONE_VM","","",null,null],[17,"CLONE_FS","","",null,null],[17,"CLONE_FILES","","",null,null],[17,"CLONE_SIGHAND","","",null,null],[17,"CLONE_PTRACE","","",null,null],[17,"CLONE_VFORK","","",null,null],[17,"CLONE_PARENT","","",null,null],[17,"CLONE_THREAD","","",null,null],[17,"CLONE_NEWNS","","",null,null],[17,"CLONE_SYSVSEM","","",null,null],[17,"CLONE_SETTLS","","",null,null],[17,"CLONE_PARENT_SETTID","","",null,null],[17,"CLONE_CHILD_CLEARTID","","",null,null],[17,"CLONE_DETACHED","","",null,null],[17,"CLONE_UNTRACED","","",null,null],[17,"CLONE_CHILD_SETTID","","",null,null],[17,"CLONE_NEWUTS","","",null,null],[17,"CLONE_NEWIPC","","",null,null],[17,"CLONE_NEWUSER","","",null,null],[17,"CLONE_NEWPID","","",null,null],[17,"CLONE_NEWNET","","",null,null],[17,"CLONE_IO","","",null,null],[17,"WNOHANG","","",null,null],[17,"WUNTRACED","","",null,null],[17,"WSTOPPED","","",null,null],[17,"WEXITED","","",null,null],[17,"WCONTINUED","","",null,null],[17,"WNOWAIT","","",null,null],[17,"__WNOTHREAD","","",null,null],[17,"__WALL","","",null,null],[17,"__WCLONE","","",null,null],[17,"SPLICE_F_MOVE","","",null,null],[17,"SPLICE_F_NONBLOCK","","",null,null],[17,"SPLICE_F_MORE","","",null,null],[17,"SPLICE_F_GIFT","","",null,null],[17,"RTLD_LOCAL","","",null,null],[17,"POSIX_FADV_NORMAL","","",null,null],[17,"POSIX_FADV_RANDOM","","",null,null],[17,"POSIX_FADV_SEQUENTIAL","","",null,null],[17,"POSIX_FADV_WILLNEED","","",null,null],[17,"AT_FDCWD","","",null,null],[17,"AT_SYMLINK_NOFOLLOW","","",null,null],[17,"LOG_CRON","","",null,null],[17,"LOG_AUTHPRIV","","",null,null],[17,"LOG_FTP","","",null,null],[17,"LOG_PERROR","","",null,null],[17,"PIPE_BUF","","",null,null],[17,"SI_LOAD_SHIFT","","",null,null],[17,"ABDAY_1","","",null,null],[17,"ABDAY_2","","",null,null],[17,"ABDAY_3","","",null,null],[17,"ABDAY_4","","",null,null],[17,"ABDAY_5","","",null,null],[17,"ABDAY_6","","",null,null],[17,"ABDAY_7","","",null,null],[17,"DAY_1","","",null,null],[17,"DAY_2","","",null,null],[17,"DAY_3","","",null,null],[17,"DAY_4","","",null,null],[17,"DAY_5","","",null,null],[17,"DAY_6","","",null,null],[17,"DAY_7","","",null,null],[17,"ABMON_1","","",null,null],[17,"ABMON_2","","",null,null],[17,"ABMON_3","","",null,null],[17,"ABMON_4","","",null,null],[17,"ABMON_5","","",null,null],[17,"ABMON_6","","",null,null],[17,"ABMON_7","","",null,null],[17,"ABMON_8","","",null,null],[17,"ABMON_9","","",null,null],[17,"ABMON_10","","",null,null],[17,"ABMON_11","","",null,null],[17,"ABMON_12","","",null,null],[17,"CLONE_NEWCGROUP","","",null,null],[17,"MON_1","","",null,null],[17,"MON_2","","",null,null],[17,"MON_3","","",null,null],[17,"MON_4","","",null,null],[17,"MON_5","","",null,null],[17,"MON_6","","",null,null],[17,"MON_7","","",null,null],[17,"MON_8","","",null,null],[17,"MON_9","","",null,null],[17,"MON_10","","",null,null],[17,"MON_11","","",null,null],[17,"MON_12","","",null,null],[17,"AM_STR","","",null,null],[17,"PM_STR","","",null,null],[17,"D_T_FMT","","",null,null],[17,"D_FMT","","",null,null],[17,"T_FMT","","",null,null],[17,"T_FMT_AMPM","","",null,null],[17,"ERA","","",null,null],[17,"ERA_D_FMT","","",null,null],[17,"ALT_DIGITS","","",null,null],[17,"ERA_D_T_FMT","","",null,null],[17,"ERA_T_FMT","","",null,null],[17,"CODESET","","",null,null],[17,"CRNCYSTR","","",null,null],[17,"RUSAGE_THREAD","","",null,null],[17,"RUSAGE_CHILDREN","","",null,null],[17,"RADIXCHAR","","",null,null],[17,"THOUSEP","","",null,null],[17,"YESEXPR","","",null,null],[17,"NOEXPR","","",null,null],[17,"YESSTR","","",null,null],[17,"NOSTR","","",null,null],[17,"FILENAME_MAX","","",null,null],[17,"L_tmpnam","","",null,null],[17,"_PC_LINK_MAX","","",null,null],[17,"_PC_MAX_CANON","","",null,null],[17,"_PC_MAX_INPUT","","",null,null],[17,"_PC_NAME_MAX","","",null,null],[17,"_PC_PATH_MAX","","",null,null],[17,"_PC_PIPE_BUF","","",null,null],[17,"_PC_CHOWN_RESTRICTED","","",null,null],[17,"_PC_NO_TRUNC","","",null,null],[17,"_PC_VDISABLE","","",null,null],[17,"_SC_ARG_MAX","","",null,null],[17,"_SC_CHILD_MAX","","",null,null],[17,"_SC_CLK_TCK","","",null,null],[17,"_SC_NGROUPS_MAX","","",null,null],[17,"_SC_OPEN_MAX","","",null,null],[17,"_SC_STREAM_MAX","","",null,null],[17,"_SC_TZNAME_MAX","","",null,null],[17,"_SC_JOB_CONTROL","","",null,null],[17,"_SC_SAVED_IDS","","",null,null],[17,"_SC_REALTIME_SIGNALS","","",null,null],[17,"_SC_PRIORITY_SCHEDULING","","",null,null],[17,"_SC_TIMERS","","",null,null],[17,"_SC_ASYNCHRONOUS_IO","","",null,null],[17,"_SC_PRIORITIZED_IO","","",null,null],[17,"_SC_SYNCHRONIZED_IO","","",null,null],[17,"_SC_FSYNC","","",null,null],[17,"_SC_MAPPED_FILES","","",null,null],[17,"_SC_MEMLOCK","","",null,null],[17,"_SC_MEMLOCK_RANGE","","",null,null],[17,"_SC_MEMORY_PROTECTION","","",null,null],[17,"_SC_MESSAGE_PASSING","","",null,null],[17,"_SC_SEMAPHORES","","",null,null],[17,"_SC_SHARED_MEMORY_OBJECTS","","",null,null],[17,"_SC_AIO_LISTIO_MAX","","",null,null],[17,"_SC_AIO_MAX","","",null,null],[17,"_SC_AIO_PRIO_DELTA_MAX","","",null,null],[17,"_SC_DELAYTIMER_MAX","","",null,null],[17,"_SC_MQ_OPEN_MAX","","",null,null],[17,"_SC_MQ_PRIO_MAX","","",null,null],[17,"_SC_VERSION","","",null,null],[17,"_SC_PAGESIZE","","",null,null],[17,"_SC_PAGE_SIZE","","",null,null],[17,"_SC_RTSIG_MAX","","",null,null],[17,"_SC_SEM_NSEMS_MAX","","",null,null],[17,"_SC_SEM_VALUE_MAX","","",null,null],[17,"_SC_SIGQUEUE_MAX","","",null,null],[17,"_SC_TIMER_MAX","","",null,null],[17,"_SC_BC_BASE_MAX","","",null,null],[17,"_SC_BC_DIM_MAX","","",null,null],[17,"_SC_BC_SCALE_MAX","","",null,null],[17,"_SC_BC_STRING_MAX","","",null,null],[17,"_SC_COLL_WEIGHTS_MAX","","",null,null],[17,"_SC_EXPR_NEST_MAX","","",null,null],[17,"_SC_LINE_MAX","","",null,null],[17,"_SC_RE_DUP_MAX","","",null,null],[17,"_SC_2_VERSION","","",null,null],[17,"_SC_2_C_BIND","","",null,null],[17,"_SC_2_C_DEV","","",null,null],[17,"_SC_2_FORT_DEV","","",null,null],[17,"_SC_2_FORT_RUN","","",null,null],[17,"_SC_2_SW_DEV","","",null,null],[17,"_SC_2_LOCALEDEF","","",null,null],[17,"_SC_IOV_MAX","","",null,null],[17,"_SC_THREADS","","",null,null],[17,"_SC_THREAD_SAFE_FUNCTIONS","","",null,null],[17,"_SC_GETGR_R_SIZE_MAX","","",null,null],[17,"_SC_GETPW_R_SIZE_MAX","","",null,null],[17,"_SC_LOGIN_NAME_MAX","","",null,null],[17,"_SC_TTY_NAME_MAX","","",null,null],[17,"_SC_THREAD_DESTRUCTOR_ITERATIONS","","",null,null],[17,"_SC_THREAD_KEYS_MAX","","",null,null],[17,"_SC_THREAD_STACK_MIN","","",null,null],[17,"_SC_THREAD_THREADS_MAX","","",null,null],[17,"_SC_THREAD_ATTR_STACKADDR","","",null,null],[17,"_SC_THREAD_ATTR_STACKSIZE","","",null,null],[17,"_SC_THREAD_PRIORITY_SCHEDULING","","",null,null],[17,"_SC_THREAD_PRIO_INHERIT","","",null,null],[17,"_SC_THREAD_PRIO_PROTECT","","",null,null],[17,"_SC_NPROCESSORS_ONLN","","",null,null],[17,"_SC_ATEXIT_MAX","","",null,null],[17,"_SC_XOPEN_VERSION","","",null,null],[17,"_SC_XOPEN_XCU_VERSION","","",null,null],[17,"_SC_XOPEN_UNIX","","",null,null],[17,"_SC_XOPEN_CRYPT","","",null,null],[17,"_SC_XOPEN_ENH_I18N","","",null,null],[17,"_SC_XOPEN_SHM","","",null,null],[17,"_SC_2_CHAR_TERM","","",null,null],[17,"_SC_2_UPE","","",null,null],[17,"_SC_XBS5_ILP32_OFF32","","",null,null],[17,"_SC_XBS5_ILP32_OFFBIG","","",null,null],[17,"_SC_XBS5_LPBIG_OFFBIG","","",null,null],[17,"_SC_XOPEN_LEGACY","","",null,null],[17,"_SC_XOPEN_REALTIME","","",null,null],[17,"_SC_XOPEN_REALTIME_THREADS","","",null,null],[17,"_SC_HOST_NAME_MAX","","",null,null],[17,"RLIM_SAVED_MAX","","",null,null],[17,"RLIM_SAVED_CUR","","",null,null],[17,"GLOB_ERR","","",null,null],[17,"GLOB_MARK","","",null,null],[17,"GLOB_NOSORT","","",null,null],[17,"GLOB_DOOFFS","","",null,null],[17,"GLOB_NOCHECK","","",null,null],[17,"GLOB_APPEND","","",null,null],[17,"GLOB_NOESCAPE","","",null,null],[17,"GLOB_NOSPACE","","",null,null],[17,"GLOB_ABORTED","","",null,null],[17,"GLOB_NOMATCH","","",null,null],[17,"POSIX_MADV_NORMAL","","",null,null],[17,"POSIX_MADV_RANDOM","","",null,null],[17,"POSIX_MADV_SEQUENTIAL","","",null,null],[17,"POSIX_MADV_WILLNEED","","",null,null],[17,"S_IEXEC","","",null,null],[17,"S_IWRITE","","",null,null],[17,"S_IREAD","","",null,null],[17,"F_LOCK","","",null,null],[17,"F_TEST","","",null,null],[17,"F_TLOCK","","",null,null],[17,"F_ULOCK","","",null,null],[17,"ST_RDONLY","","",null,null],[17,"ST_NOSUID","","",null,null],[17,"ST_NODEV","","",null,null],[17,"ST_NOEXEC","","",null,null],[17,"ST_SYNCHRONOUS","","",null,null],[17,"ST_MANDLOCK","","",null,null],[17,"ST_WRITE","","",null,null],[17,"ST_APPEND","","",null,null],[17,"ST_IMMUTABLE","","",null,null],[17,"ST_NOATIME","","",null,null],[17,"ST_NODIRATIME","","",null,null],[17,"RTLD_NEXT","","",null,null],[17,"RTLD_DEFAULT","","",null,null],[17,"RTLD_NODELETE","","",null,null],[17,"RTLD_NOW","","",null,null],[17,"TCP_MD5SIG","","",null,null],[17,"PTHREAD_MUTEX_INITIALIZER","","",null,null],[17,"PTHREAD_COND_INITIALIZER","","",null,null],[17,"PTHREAD_RWLOCK_INITIALIZER","","",null,null],[17,"PTHREAD_MUTEX_NORMAL","","",null,null],[17,"PTHREAD_MUTEX_RECURSIVE","","",null,null],[17,"PTHREAD_MUTEX_ERRORCHECK","","",null,null],[17,"PTHREAD_MUTEX_DEFAULT","","",null,null],[17,"__SIZEOF_PTHREAD_COND_T","","",null,null],[17,"SCHED_OTHER","","",null,null],[17,"SCHED_FIFO","","",null,null],[17,"SCHED_RR","","",null,null],[17,"SCHED_BATCH","","",null,null],[17,"SCHED_IDLE","","",null,null],[17,"IPC_PRIVATE","","",null,null],[17,"IPC_CREAT","","",null,null],[17,"IPC_EXCL","","",null,null],[17,"IPC_NOWAIT","","",null,null],[17,"IPC_RMID","","",null,null],[17,"IPC_SET","","",null,null],[17,"IPC_STAT","","",null,null],[17,"IPC_INFO","","",null,null],[17,"MSG_STAT","","",null,null],[17,"MSG_INFO","","",null,null],[17,"MSG_NOERROR","","",null,null],[17,"MSG_EXCEPT","","",null,null],[17,"MSG_COPY","","",null,null],[17,"SHM_R","","",null,null],[17,"SHM_W","","",null,null],[17,"SHM_RDONLY","","",null,null],[17,"SHM_RND","","",null,null],[17,"SHM_REMAP","","",null,null],[17,"SHM_EXEC","","",null,null],[17,"SHM_LOCK","","",null,null],[17,"SHM_UNLOCK","","",null,null],[17,"SHM_HUGETLB","","",null,null],[17,"SHM_NORESERVE","","",null,null],[17,"EPOLLRDHUP","","",null,null],[17,"EPOLLONESHOT","","",null,null],[17,"QFMT_VFS_OLD","","",null,null],[17,"QFMT_VFS_V0","","",null,null],[17,"SFD_CLOEXEC","","",null,null],[17,"EFD_SEMAPHORE","","",null,null],[17,"NCCS","","",null,null],[17,"LOG_NFACILITIES","","",null,null],[17,"SEM_FAILED","","",null,null],[17,"RB_AUTOBOOT","","",null,null],[17,"RB_HALT_SYSTEM","","",null,null],[17,"RB_ENABLE_CAD","","",null,null],[17,"RB_DISABLE_CAD","","",null,null],[17,"RB_POWER_OFF","","",null,null],[17,"RB_SW_SUSPEND","","",null,null],[17,"RB_KEXEC","","",null,null],[17,"SYNC_FILE_RANGE_WAIT_BEFORE","","",null,null],[17,"SYNC_FILE_RANGE_WRITE","","",null,null],[17,"SYNC_FILE_RANGE_WAIT_AFTER","","",null,null],[17,"EAI_SYSTEM","","",null,null],[17,"__UT_LINESIZE","","",null,null],[17,"__UT_NAMESIZE","","",null,null],[17,"__UT_HOSTSIZE","","",null,null],[17,"EMPTY","","",null,null],[17,"RUN_LVL","","",null,null],[17,"BOOT_TIME","","",null,null],[17,"NEW_TIME","","",null,null],[17,"OLD_TIME","","",null,null],[17,"INIT_PROCESS","","",null,null],[17,"LOGIN_PROCESS","","",null,null],[17,"USER_PROCESS","","",null,null],[17,"DEAD_PROCESS","","",null,null],[17,"ACCOUNTING","","",null,null],[17,"RLIMIT_RSS","","",null,null],[17,"RLIMIT_NOFILE","","",null,null],[17,"RLIMIT_AS","","",null,null],[17,"RLIMIT_NPROC","","",null,null],[17,"RLIMIT_MEMLOCK","","",null,null],[17,"RLIM_INFINITY","","",null,null],[17,"RLIMIT_RTTIME","","",null,null],[17,"RLIMIT_NLIMITS","","",null,null],[17,"O_APPEND","","",null,null],[17,"O_CREAT","","",null,null],[17,"O_EXCL","","",null,null],[17,"O_NOCTTY","","",null,null],[17,"O_NONBLOCK","","",null,null],[17,"O_SYNC","","",null,null],[17,"O_RSYNC","","",null,null],[17,"O_DSYNC","","",null,null],[17,"O_FSYNC","","",null,null],[17,"SOCK_NONBLOCK","","",null,null],[17,"LC_PAPER","","",null,null],[17,"LC_NAME","","",null,null],[17,"LC_ADDRESS","","",null,null],[17,"LC_TELEPHONE","","",null,null],[17,"LC_MEASUREMENT","","",null,null],[17,"LC_IDENTIFICATION","","",null,null],[17,"LC_PAPER_MASK","","",null,null],[17,"LC_NAME_MASK","","",null,null],[17,"LC_ADDRESS_MASK","","",null,null],[17,"LC_TELEPHONE_MASK","","",null,null],[17,"LC_MEASUREMENT_MASK","","",null,null],[17,"LC_IDENTIFICATION_MASK","","",null,null],[17,"LC_ALL_MASK","","",null,null],[17,"MAP_ANON","","",null,null],[17,"MAP_ANONYMOUS","","",null,null],[17,"MAP_GROWSDOWN","","",null,null],[17,"MAP_DENYWRITE","","",null,null],[17,"MAP_EXECUTABLE","","",null,null],[17,"MAP_POPULATE","","",null,null],[17,"MAP_NONBLOCK","","",null,null],[17,"MAP_STACK","","",null,null],[17,"EDEADLK","","",null,null],[17,"ENAMETOOLONG","","",null,null],[17,"ENOLCK","","",null,null],[17,"ENOSYS","","",null,null],[17,"ENOTEMPTY","","",null,null],[17,"ELOOP","","",null,null],[17,"ENOMSG","","",null,null],[17,"EIDRM","","",null,null],[17,"ECHRNG","","",null,null],[17,"EL2NSYNC","","",null,null],[17,"EL3HLT","","",null,null],[17,"EL3RST","","",null,null],[17,"ELNRNG","","",null,null],[17,"EUNATCH","","",null,null],[17,"ENOCSI","","",null,null],[17,"EL2HLT","","",null,null],[17,"EBADE","","",null,null],[17,"EBADR","","",null,null],[17,"EXFULL","","",null,null],[17,"ENOANO","","",null,null],[17,"EBADRQC","","",null,null],[17,"EBADSLT","","",null,null],[17,"EMULTIHOP","","",null,null],[17,"EOVERFLOW","","",null,null],[17,"ENOTUNIQ","","",null,null],[17,"EBADFD","","",null,null],[17,"EBADMSG","","",null,null],[17,"EREMCHG","","",null,null],[17,"ELIBACC","","",null,null],[17,"ELIBBAD","","",null,null],[17,"ELIBSCN","","",null,null],[17,"ELIBMAX","","",null,null],[17,"ELIBEXEC","","",null,null],[17,"EILSEQ","","",null,null],[17,"ERESTART","","",null,null],[17,"ESTRPIPE","","",null,null],[17,"EUSERS","","",null,null],[17,"ENOTSOCK","","",null,null],[17,"EDESTADDRREQ","","",null,null],[17,"EMSGSIZE","","",null,null],[17,"EPROTOTYPE","","",null,null],[17,"ENOPROTOOPT","","",null,null],[17,"EPROTONOSUPPORT","","",null,null],[17,"ESOCKTNOSUPPORT","","",null,null],[17,"EOPNOTSUPP","","",null,null],[17,"EPFNOSUPPORT","","",null,null],[17,"EAFNOSUPPORT","","",null,null],[17,"EADDRINUSE","","",null,null],[17,"EADDRNOTAVAIL","","",null,null],[17,"ENETDOWN","","",null,null],[17,"ENETUNREACH","","",null,null],[17,"ENETRESET","","",null,null],[17,"ECONNABORTED","","",null,null],[17,"ECONNRESET","","",null,null],[17,"ENOBUFS","","",null,null],[17,"EISCONN","","",null,null],[17,"ENOTCONN","","",null,null],[17,"ESHUTDOWN","","",null,null],[17,"ETOOMANYREFS","","",null,null],[17,"ETIMEDOUT","","",null,null],[17,"ECONNREFUSED","","",null,null],[17,"EHOSTDOWN","","",null,null],[17,"EHOSTUNREACH","","",null,null],[17,"EALREADY","","",null,null],[17,"EINPROGRESS","","",null,null],[17,"ESTALE","","",null,null],[17,"EUCLEAN","","",null,null],[17,"ENOTNAM","","",null,null],[17,"ENAVAIL","","",null,null],[17,"EISNAM","","",null,null],[17,"EREMOTEIO","","",null,null],[17,"EDQUOT","","",null,null],[17,"ENOMEDIUM","","",null,null],[17,"EMEDIUMTYPE","","",null,null],[17,"ECANCELED","","",null,null],[17,"ENOKEY","","",null,null],[17,"EKEYEXPIRED","","",null,null],[17,"EKEYREVOKED","","",null,null],[17,"EKEYREJECTED","","",null,null],[17,"EOWNERDEAD","","",null,null],[17,"ENOTRECOVERABLE","","",null,null],[17,"EHWPOISON","","",null,null],[17,"ERFKILL","","",null,null],[17,"SOCK_STREAM","","",null,null],[17,"SOCK_DGRAM","","",null,null],[17,"SOCK_SEQPACKET","","",null,null],[17,"SOL_SOCKET","","",null,null],[17,"SO_REUSEADDR","","",null,null],[17,"SO_TYPE","","",null,null],[17,"SO_ERROR","","",null,null],[17,"SO_DONTROUTE","","",null,null],[17,"SO_BROADCAST","","",null,null],[17,"SO_SNDBUF","","",null,null],[17,"SO_RCVBUF","","",null,null],[17,"SO_KEEPALIVE","","",null,null],[17,"SO_OOBINLINE","","",null,null],[17,"SO_LINGER","","",null,null],[17,"SO_REUSEPORT","","",null,null],[17,"SO_ACCEPTCONN","","",null,null],[17,"TCP_COOKIE_TRANSACTIONS","","",null,null],[17,"TCP_THIN_LINEAR_TIMEOUTS","","",null,null],[17,"TCP_THIN_DUPACK","","",null,null],[17,"TCP_USER_TIMEOUT","","",null,null],[17,"TCP_REPAIR","","",null,null],[17,"TCP_REPAIR_QUEUE","","",null,null],[17,"TCP_QUEUE_SEQ","","",null,null],[17,"TCP_REPAIR_OPTIONS","","",null,null],[17,"TCP_FASTOPEN","","",null,null],[17,"TCP_TIMESTAMP","","",null,null],[17,"SA_ONSTACK","","",null,null],[17,"SA_SIGINFO","","",null,null],[17,"SA_NOCLDWAIT","","",null,null],[17,"SIGCHLD","","",null,null],[17,"SIGBUS","","",null,null],[17,"SIGUSR1","","",null,null],[17,"SIGUSR2","","",null,null],[17,"SIGCONT","","",null,null],[17,"SIGSTOP","","",null,null],[17,"SIGTSTP","","",null,null],[17,"SIGURG","","",null,null],[17,"SIGIO","","",null,null],[17,"SIGSYS","","",null,null],[17,"SIGSTKFLT","","",null,null],[17,"SIGUNUSED","","",null,null],[17,"SIGTTIN","","",null,null],[17,"SIGTTOU","","",null,null],[17,"SIGXCPU","","",null,null],[17,"SIGXFSZ","","",null,null],[17,"SIGVTALRM","","",null,null],[17,"SIGPROF","","",null,null],[17,"SIGWINCH","","",null,null],[17,"SIGPOLL","","",null,null],[17,"SIGPWR","","",null,null],[17,"SIG_SETMASK","","",null,null],[17,"SIG_BLOCK","","",null,null],[17,"SIG_UNBLOCK","","",null,null],[17,"POLLRDNORM","","",null,null],[17,"POLLWRNORM","","",null,null],[17,"POLLRDBAND","","",null,null],[17,"POLLWRBAND","","",null,null],[17,"FALLOC_FL_KEEP_SIZE","","",null,null],[17,"FALLOC_FL_PUNCH_HOLE","","",null,null],[17,"BUFSIZ","","",null,null],[17,"TMP_MAX","","",null,null],[17,"FOPEN_MAX","","",null,null],[17,"POSIX_FADV_DONTNEED","","",null,null],[17,"POSIX_FADV_NOREUSE","","",null,null],[17,"POSIX_MADV_DONTNEED","","",null,null],[17,"_SC_2_C_VERSION","","",null,null],[17,"O_ACCMODE","","",null,null],[17,"O_ASYNC","","",null,null],[17,"O_NDELAY","","",null,null],[17,"ST_RELATIME","","",null,null],[17,"NI_MAXHOST","","",null,null],[17,"ADFS_SUPER_MAGIC","","",null,null],[17,"AFFS_SUPER_MAGIC","","",null,null],[17,"CODA_SUPER_MAGIC","","",null,null],[17,"CRAMFS_MAGIC","","",null,null],[17,"EFS_SUPER_MAGIC","","",null,null],[17,"EXT2_SUPER_MAGIC","","",null,null],[17,"EXT3_SUPER_MAGIC","","",null,null],[17,"EXT4_SUPER_MAGIC","","",null,null],[17,"HPFS_SUPER_MAGIC","","",null,null],[17,"HUGETLBFS_MAGIC","","",null,null],[17,"ISOFS_SUPER_MAGIC","","",null,null],[17,"JFFS2_SUPER_MAGIC","","",null,null],[17,"MINIX_SUPER_MAGIC","","",null,null],[17,"MINIX_SUPER_MAGIC2","","",null,null],[17,"MINIX2_SUPER_MAGIC","","",null,null],[17,"MINIX2_SUPER_MAGIC2","","",null,null],[17,"MSDOS_SUPER_MAGIC","","",null,null],[17,"NCP_SUPER_MAGIC","","",null,null],[17,"NFS_SUPER_MAGIC","","",null,null],[17,"OPENPROM_SUPER_MAGIC","","",null,null],[17,"PROC_SUPER_MAGIC","","",null,null],[17,"QNX4_SUPER_MAGIC","","",null,null],[17,"REISERFS_SUPER_MAGIC","","",null,null],[17,"SMB_SUPER_MAGIC","","",null,null],[17,"TMPFS_MAGIC","","",null,null],[17,"USBDEVICE_SUPER_MAGIC","","",null,null],[17,"VEOF","","",null,null],[17,"IUTF8","","",null,null],[17,"CPU_SETSIZE","","",null,null],[17,"QFMT_VFS_V1","","",null,null],[17,"PTRACE_TRACEME","","",null,null],[17,"PTRACE_PEEKTEXT","","",null,null],[17,"PTRACE_PEEKDATA","","",null,null],[17,"PTRACE_PEEKUSER","","",null,null],[17,"PTRACE_POKETEXT","","",null,null],[17,"PTRACE_POKEDATA","","",null,null],[17,"PTRACE_POKEUSER","","",null,null],[17,"PTRACE_CONT","","",null,null],[17,"PTRACE_KILL","","",null,null],[17,"PTRACE_SINGLESTEP","","",null,null],[17,"PTRACE_ATTACH","","",null,null],[17,"PTRACE_DETACH","","",null,null],[17,"PTRACE_SYSCALL","","",null,null],[17,"PTRACE_SETOPTIONS","","",null,null],[17,"PTRACE_GETEVENTMSG","","",null,null],[17,"PTRACE_GETSIGINFO","","",null,null],[17,"PTRACE_SETSIGINFO","","",null,null],[17,"PTRACE_GETREGSET","","",null,null],[17,"PTRACE_SETREGSET","","",null,null],[17,"PTRACE_SEIZE","","",null,null],[17,"PTRACE_INTERRUPT","","",null,null],[17,"PTRACE_LISTEN","","",null,null],[17,"PTRACE_PEEKSIGINFO","","",null,null],[17,"MADV_DODUMP","","",null,null],[17,"MADV_DONTDUMP","","",null,null],[17,"EPOLLWAKEUP","","",null,null],[17,"MADV_HUGEPAGE","","",null,null],[17,"MADV_NOHUGEPAGE","","",null,null],[17,"MAP_HUGETLB","","",null,null],[17,"EFD_NONBLOCK","","",null,null],[17,"F_GETLK","","",null,null],[17,"F_GETOWN","","",null,null],[17,"F_SETOWN","","",null,null],[17,"F_SETLK","","",null,null],[17,"F_SETLKW","","",null,null],[17,"SEEK_DATA","","",null,null],[17,"SEEK_HOLE","","",null,null],[17,"SFD_NONBLOCK","","",null,null],[17,"TCSANOW","","",null,null],[17,"TCSADRAIN","","",null,null],[17,"TCSAFLUSH","","",null,null],[17,"TIOCGSOFTCAR","","",null,null],[17,"TIOCSSOFTCAR","","",null,null],[17,"TIOCLINUX","","",null,null],[17,"TIOCGSERIAL","","",null,null],[17,"TIOCEXCL","","",null,null],[17,"TIOCNXCL","","",null,null],[17,"TIOCSCTTY","","",null,null],[17,"TIOCSTI","","",null,null],[17,"TIOCMGET","","",null,null],[17,"TIOCMBIS","","",null,null],[17,"TIOCMBIC","","",null,null],[17,"TIOCMSET","","",null,null],[17,"TIOCCONS","","",null,null],[17,"RTLD_DEEPBIND","","",null,null],[17,"RTLD_GLOBAL","","",null,null],[17,"RTLD_NOLOAD","","",null,null],[17,"LINUX_REBOOT_MAGIC1","","",null,null],[17,"LINUX_REBOOT_MAGIC2","","",null,null],[17,"LINUX_REBOOT_MAGIC2A","","",null,null],[17,"LINUX_REBOOT_MAGIC2B","","",null,null],[17,"LINUX_REBOOT_MAGIC2C","","",null,null],[17,"LINUX_REBOOT_CMD_RESTART","","",null,null],[17,"LINUX_REBOOT_CMD_HALT","","",null,null],[17,"LINUX_REBOOT_CMD_CAD_ON","","",null,null],[17,"LINUX_REBOOT_CMD_CAD_OFF","","",null,null],[17,"LINUX_REBOOT_CMD_POWER_OFF","","",null,null],[17,"LINUX_REBOOT_CMD_RESTART2","","",null,null],[17,"LINUX_REBOOT_CMD_SW_SUSPEND","","",null,null],[17,"LINUX_REBOOT_CMD_KEXEC","","",null,null],[17,"NETLINK_ROUTE","","",null,null],[17,"NETLINK_UNUSED","","",null,null],[17,"NETLINK_USERSOCK","","",null,null],[17,"NETLINK_FIREWALL","","",null,null],[17,"NETLINK_SOCK_DIAG","","",null,null],[17,"NETLINK_NFLOG","","",null,null],[17,"NETLINK_XFRM","","",null,null],[17,"NETLINK_SELINUX","","",null,null],[17,"NETLINK_ISCSI","","",null,null],[17,"NETLINK_AUDIT","","",null,null],[17,"NETLINK_FIB_LOOKUP","","",null,null],[17,"NETLINK_CONNECTOR","","",null,null],[17,"NETLINK_NETFILTER","","",null,null],[17,"NETLINK_IP6_FW","","",null,null],[17,"NETLINK_DNRTMSG","","",null,null],[17,"NETLINK_KOBJECT_UEVENT","","",null,null],[17,"NETLINK_GENERIC","","",null,null],[17,"NETLINK_SCSITRANSPORT","","",null,null],[17,"NETLINK_ECRYPTFS","","",null,null],[17,"NETLINK_RDMA","","",null,null],[17,"NETLINK_CRYPTO","","",null,null],[17,"NETLINK_INET_DIAG","","",null,null],[17,"MAX_LINKS","","",null,null],[17,"NLM_F_REQUEST","","",null,null],[17,"NLM_F_MULTI","","",null,null],[17,"NLM_F_ACK","","",null,null],[17,"NLM_F_ECHO","","",null,null],[17,"NLM_F_DUMP_INTR","","",null,null],[17,"NLM_F_DUMP_FILTERED","","",null,null],[17,"NLM_F_ROOT","","",null,null],[17,"NLM_F_MATCH","","",null,null],[17,"NLM_F_ATOMIC","","",null,null],[17,"NLM_F_DUMP","","",null,null],[17,"NLM_F_REPLACE","","",null,null],[17,"NLM_F_EXCL","","",null,null],[17,"NLM_F_CREATE","","",null,null],[17,"NLM_F_APPEND","","",null,null],[17,"NLMSG_NOOP","","",null,null],[17,"NLMSG_ERROR","","",null,null],[17,"NLMSG_DONE","","",null,null],[17,"NLMSG_OVERRUN","","",null,null],[17,"NLMSG_MIN_TYPE","","",null,null],[17,"NETLINK_ADD_MEMBERSHIP","","",null,null],[17,"NETLINK_DROP_MEMBERSHIP","","",null,null],[17,"NETLINK_PKTINFO","","",null,null],[17,"NETLINK_BROADCAST_ERROR","","",null,null],[17,"NETLINK_NO_ENOBUFS","","",null,null],[17,"NETLINK_RX_RING","","",null,null],[17,"NETLINK_TX_RING","","",null,null],[17,"NETLINK_LISTEN_ALL_NSID","","",null,null],[17,"NETLINK_LIST_MEMBERSHIPS","","",null,null],[17,"NETLINK_CAP_ACK","","",null,null],[17,"NLA_F_NESTED","","",null,null],[17,"NLA_F_NET_BYTEORDER","","",null,null],[17,"NLA_TYPE_MASK","","",null,null],[17,"PTHREAD_STACK_MIN","","",null,null],[17,"__SIZEOF_PTHREAD_RWLOCK_T","","",null,null],[17,"__SIZEOF_PTHREAD_CONDATTR_T","","",null,null],[17,"__SIZEOF_PTHREAD_MUTEX_T","","",null,null],[17,"__SIZEOF_PTHREAD_MUTEXATTR_T","","",null,null],[17,"O_DIRECT","","",null,null],[17,"O_DIRECTORY","","",null,null],[17,"O_NOFOLLOW","","",null,null],[17,"MAP_LOCKED","","",null,null],[17,"MAP_NORESERVE","","",null,null],[17,"MAP_32BIT","","",null,null],[17,"EDEADLOCK","","",null,null],[17,"SO_PEERCRED","","",null,null],[17,"SO_RCVLOWAT","","",null,null],[17,"SO_SNDLOWAT","","",null,null],[17,"SO_RCVTIMEO","","",null,null],[17,"SO_SNDTIMEO","","",null,null],[17,"FIOCLEX","","",null,null],[17,"FIONBIO","","",null,null],[17,"PTRACE_GETFPREGS","","",null,null],[17,"PTRACE_SETFPREGS","","",null,null],[17,"PTRACE_GETFPXREGS","","",null,null],[17,"PTRACE_SETFPXREGS","","",null,null],[17,"PTRACE_GETREGS","","",null,null],[17,"PTRACE_SETREGS","","",null,null],[17,"PTRACE_O_EXITKILL","","",null,null],[17,"PTRACE_O_TRACECLONE","","",null,null],[17,"PTRACE_O_TRACEEXEC","","",null,null],[17,"PTRACE_O_TRACEEXIT","","",null,null],[17,"PTRACE_O_TRACEFORK","","",null,null],[17,"PTRACE_O_TRACESYSGOOD","","",null,null],[17,"PTRACE_O_TRACEVFORK","","",null,null],[17,"PTRACE_O_TRACEVFORKDONE","","",null,null],[17,"PTRACE_O_TRACESECCOMP","","",null,null],[17,"PTRACE_O_SUSPEND_SECCOMP","","",null,null],[17,"PTRACE_PEEKSIGINFO_SHARED","","",null,null],[17,"SYS_gettid","","",null,null],[17,"SYS_perf_event_open","","",null,null],[17,"MCL_CURRENT","","",null,null],[17,"MCL_FUTURE","","",null,null],[17,"SIGSTKSZ","","",null,null],[17,"CBAUD","","",null,null],[17,"TAB1","","",null,null],[17,"TAB2","","",null,null],[17,"TAB3","","",null,null],[17,"CR1","","",null,null],[17,"CR2","","",null,null],[17,"CR3","","",null,null],[17,"FF1","","",null,null],[17,"BS1","","",null,null],[17,"VT1","","",null,null],[17,"VWERASE","","",null,null],[17,"VREPRINT","","",null,null],[17,"VSUSP","","",null,null],[17,"VSTART","","",null,null],[17,"VSTOP","","",null,null],[17,"VDISCARD","","",null,null],[17,"VTIME","","",null,null],[17,"IXON","","",null,null],[17,"IXOFF","","",null,null],[17,"ONLCR","","",null,null],[17,"CSIZE","","",null,null],[17,"CS6","","",null,null],[17,"CS7","","",null,null],[17,"CS8","","",null,null],[17,"CSTOPB","","",null,null],[17,"CREAD","","",null,null],[17,"PARENB","","",null,null],[17,"PARODD","","",null,null],[17,"HUPCL","","",null,null],[17,"CLOCAL","","",null,null],[17,"ECHOKE","","",null,null],[17,"ECHOE","","",null,null],[17,"ECHOK","","",null,null],[17,"ECHONL","","",null,null],[17,"ECHOPRT","","",null,null],[17,"ECHOCTL","","",null,null],[17,"ISIG","","",null,null],[17,"ICANON","","",null,null],[17,"PENDIN","","",null,null],[17,"NOFLSH","","",null,null],[17,"VEOL","","",null,null],[17,"VEOL2","","",null,null],[17,"VMIN","","",null,null],[17,"IEXTEN","","",null,null],[17,"TOSTOP","","",null,null],[17,"FLUSHO","","",null,null],[17,"EXTPROC","","",null,null],[17,"TCGETS","","",null,null],[17,"TCSETS","","",null,null],[17,"TCSETSW","","",null,null],[17,"TCSETSF","","",null,null],[17,"TCGETA","","",null,null],[17,"TCSETA","","",null,null],[17,"TCSETAW","","",null,null],[17,"TCSETAF","","",null,null],[17,"TCSBRK","","",null,null],[17,"TCXONC","","",null,null],[17,"TCFLSH","","",null,null],[17,"TIOCINQ","","",null,null],[17,"TIOCGPGRP","","",null,null],[17,"TIOCSPGRP","","",null,null],[17,"TIOCOUTQ","","",null,null],[17,"TIOCGWINSZ","","",null,null],[17,"TIOCSWINSZ","","",null,null],[17,"FIONREAD","","",null,null]],"paths":[[3,"group"],[3,"utimbuf"],[3,"timeval"],[3,"timespec"],[3,"rlimit"],[3,"rusage"],[3,"in_addr"],[3,"in6_addr"],[3,"ip_mreq"],[3,"ipv6_mreq"],[3,"hostent"],[3,"iovec"],[3,"pollfd"],[3,"winsize"],[3,"linger"],[3,"sockaddr"],[3,"sockaddr_in"],[3,"sockaddr_in6"],[3,"sockaddr_un"],[3,"sockaddr_storage"],[3,"addrinfo"],[3,"sockaddr_nl"],[3,"sockaddr_ll"],[3,"tm"],[3,"sched_param"],[3,"Dl_info"],[3,"epoll_event"],[3,"utsname"],[3,"lconv"],[3,"dirent"],[3,"dirent64"],[3,"rlimit64"],[3,"glob_t"],[3,"ifaddrs"],[3,"passwd"],[3,"spwd"],[3,"statvfs"],[3,"dqblk"],[3,"signalfd_siginfo"],[3,"mq_attr"],[3,"if_nameindex"],[3,"msginfo"],[3,"__exit_status"],[3,"__timeval"],[3,"utmpx"],[3,"sigaction"],[3,"stack_t"],[3,"siginfo_t"],[3,"glob64_t"],[3,"ucred"],[3,"statfs"],[3,"msghdr"],[3,"termios"],[3,"flock"],[3,"sysinfo"],[3,"msqid_ds"],[3,"stat"],[3,"stat64"],[3,"_libc_fpxreg"],[3,"_libc_xmmreg"],[3,"_libc_fpstate"],[3,"mcontext_t"],[3,"ucontext_t"],[3,"ipc_perm"],[3,"shmid_ds"],[3,"pthread_attr_t"],[3,"sigset_t"],[3,"sem_t"],[3,"pthread_mutex_t"],[3,"pthread_rwlock_t"],[3,"pthread_mutexattr_t"],[3,"pthread_cond_t"],[3,"pthread_condattr_t"],[3,"fsid_t"],[3,"cpu_set_t"],[3,"fd_set"]]};
searchIndex["num_iter"] = {"doc":"External iterators for generic mathematics","items":[[3,"Range","num_iter","An iterator over the range [start, stop)",null,null],[3,"RangeInclusive","","An iterator over the range [start, stop]",null,null],[3,"RangeStep","","An iterator over the range [start, stop) by `step`. It handles overflow by stopping.",null,null],[3,"RangeStepInclusive","","An iterator over the range [start, stop] by `step`. It handles overflow by stopping.",null,null],[5,"range","","Returns an iterator over the given range [start, stop) (that is, starting\nat start (inclusive), and ending at stop (exclusive)).",null,{"inputs":[{"name":"a"},{"name":"a"}],"output":{"name":"range"}}],[5,"range_inclusive","","Return an iterator over the range [start, stop]",null,{"inputs":[{"name":"a"},{"name":"a"}],"output":{"name":"rangeinclusive"}}],[5,"range_step","","Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.",null,{"inputs":[{"name":"a"},{"name":"a"},{"name":"a"}],"output":{"name":"rangestep"}}],[5,"range_step_inclusive","","Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.",null,{"inputs":[{"name":"a"},{"name":"a"},{"name":"a"}],"output":{"name":"rangestepinclusive"}}],[11,"clone","","",0,null],[11,"next","","",0,null],[11,"size_hint","","",0,null],[11,"next_back","","",0,null],[11,"clone","","",1,null],[11,"next","","",1,null],[11,"size_hint","","",1,null],[11,"next_back","","",1,null],[11,"clone","","",2,null],[11,"next","","",2,null],[11,"clone","","",3,null],[11,"next","","",3,null]],"paths":[[3,"Range"],[3,"RangeInclusive"],[3,"RangeStep"],[3,"RangeStepInclusive"]]};
searchIndex["num_integer"] = {"doc":"Integer trait and functions.","items":[[5,"div_rem","num_integer","Simultaneous integer division and modulus",null,null],[5,"div_floor","","Floored integer division",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"mod_floor","","Floored integer modulus",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"div_mod_floor","","Simultaneous floored integer division and modulus",null,null],[5,"gcd","","Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\nresult is always positive.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"lcm","","Calculates the Lowest Common Multiple (LCM) of the number and `other`.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[8,"Integer","","",null,null],[10,"div_floor","","Floored integer division.",0,null],[10,"mod_floor","","Floored integer modulo, satisfying:",0,null],[10,"gcd","","Greatest Common Divisor (GCD).",0,null],[10,"lcm","","Lowest Common Multiple (LCM).",0,null],[10,"divides","","Deprecated, use `is_multiple_of` instead.",0,null],[10,"is_multiple_of","","Returns `true` if `other` is a multiple of `self`.",0,null],[10,"is_even","","Returns `true` if the number is even.",0,null],[10,"is_odd","","Returns `true` if the number is odd.",0,null],[10,"div_rem","","Simultaneous truncated integer division and modulus.\nReturns `(quotient, remainder)`.",0,null],[11,"div_mod_floor","","Simultaneous floored integer division and modulus.\nReturns `(quotient, remainder)`.",0,null]],"paths":[[8,"Integer"]]};
searchIndex["num_complex"] = {"doc":"Complex numbers.","items":[[3,"Complex","num_complex","A complex number in Cartesian form.",null,null],[12,"re","","Real portion of the complex number",0,null],[12,"im","","Imaginary portion of the complex number",0,null],[6,"Complex32","","",null,null],[6,"Complex64","","",null,null],[11,"default","","",0,{"inputs":[],"output":{"name":"complex"}}],[11,"fmt","","",0,null],[11,"hash","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"decode","","",0,{"inputs":[{"name":"__dt"}],"output":{"name":"result"}}],[11,"encode","","",0,null],[11,"new","","Create a new Complex",0,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"complex"}}],[11,"i","","Returns imaginary unit",0,{"inputs":[],"output":{"name":"complex"}}],[11,"norm_sqr","","Returns the square of the norm (since `T` doesn&#39;t necessarily\nhave a sqrt function), i.e. `re^2 + im^2`.",0,null],[11,"scale","","Multiplies `self` by the scalar `t`.",0,null],[11,"unscale","","Divides `self` by the scalar `t`.",0,null],[11,"conj","","Returns the complex conjugate. i.e. `re - i im`",0,null],[11,"inv","","Returns `1/self`",0,null],[11,"norm","","Calculate |self|",0,null],[11,"arg","","Calculate the principal Arg of self.",0,null],[11,"to_polar","","Convert to polar form (r, theta), such that `self = r * exp(i\n* theta)`",0,null],[11,"from_polar","","Convert a polar representation into a complex number.",0,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"complex"}}],[11,"exp","","Computes `e^(self)`, where `e` is the base of the natural logarithm.",0,null],[11,"ln","","Computes the principal value of natural logarithm of `self`.",0,null],[11,"sqrt","","Computes the principal value of the square root of `self`.",0,null],[11,"powf","","Raises `self` to a floating point power.",0,null],[11,"log","","Returns the logarithm of `self` with respect to an arbitrary base.",0,null],[11,"powc","","Raises `self` to a complex power.",0,null],[11,"expf","","Raises a floating point number to the complex power `self`.",0,null],[11,"sin","","Computes the sine of `self`.",0,null],[11,"cos","","Computes the cosine of `self`.",0,null],[11,"tan","","Computes the tangent of `self`.",0,null],[11,"asin","","Computes the principal value of the inverse sine of `self`.",0,null],[11,"acos","","Computes the principal value of the inverse cosine of `self`.",0,null],[11,"atan","","Computes the principal value of the inverse tangent of `self`.",0,null],[11,"sinh","","Computes the hyperbolic sine of `self`.",0,null],[11,"cosh","","Computes the hyperbolic cosine of `self`.",0,null],[11,"tanh","","Computes the hyperbolic tangent of `self`.",0,null],[11,"asinh","","Computes the principal value of inverse hyperbolic sine of `self`.",0,null],[11,"acosh","","Computes the principal value of inverse hyperbolic cosine of `self`.",0,null],[11,"atanh","","Computes the principal value of inverse hyperbolic tangent of `self`.",0,null],[11,"is_nan","","Checks if the given complex number is NaN",0,null],[11,"is_infinite","","Checks if the given complex number is infinite",0,null],[11,"is_finite","","Checks if the given complex number is finite",0,null],[11,"is_normal","","Checks if the given complex number is normal",0,null],[11,"from","","",0,{"inputs":[{"name":"t"}],"output":{"name":"complex"}}],[11,"from","","",0,{"inputs":[{"name":"t"}],"output":{"name":"complex"}}],[11,"add","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,null],[11,"sub","","",0,null],[11,"mul","","",0,null],[11,"mul","","",0,null],[11,"div","","",0,null],[11,"div","","",0,null],[11,"neg","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,null],[11,"mul","","",0,null],[11,"div","","",0,null],[11,"add","","",0,null],[11,"sub","","",0,null],[11,"mul","","",0,null],[11,"div","","",0,null],[11,"zero","","",0,{"inputs":[],"output":{"name":"complex"}}],[11,"is_zero","","",0,null],[11,"one","","",0,{"inputs":[],"output":{"name":"complex"}}],[11,"fmt","","",0,null]],"paths":[[3,"Complex"]]};
searchIndex["csv"] = {"doc":"This crate provides a streaming CSV (comma separated values) writer and\nreader that works with the `serialize` crate to do type based encoding\nand decoding. There are two primary goals of this project:","items":[[3,"Encoded","csv","A record to be encoded.",null,null],[3,"Decoded","","A record to be decoded.",null,null],[3,"Reader","","A CSV reader.",null,null],[3,"DecodedRecords","","An iterator of decoded records.",null,null],[3,"StringRecords","","An iterator of `String` records.",null,null],[3,"ByteRecords","","An iterator of `ByteString` records.",null,null],[3,"Writer","","A CSV writer.",null,null],[3,"LocatableError","","An error tagged with a location at which it occurred.",null,null],[12,"record","","The record number (starting at 1).",0,null],[12,"field","","The field number (starting at 1).",0,null],[12,"err","","The error.",0,null],[4,"NextField","","NextField is the result of parsing a single CSV field.",null,null],[13,"Data","","A single CSV field as a borrowed slice of the parser&#39;s internal buffer.",1,null],[13,"Error","","A CSV error found during parsing. When an error is found, it is\nfirst returned. All subsequent calls of `next_bytes` will return\n`EndOfCsv`. (EOF is exempt from this. Depending on the state of the\nparser, an EOF could trigger `Data`, `EndOfRecord` and `EndOfCsv`,\nall in succession.)",1,null],[13,"EndOfRecord","","Indicates the end of a record.",1,null],[13,"EndOfCsv","","Indicates the end of the CSV data. Once this state is entered, the\nparser can never leave it.",1,null],[4,"RecordTerminator","","A record terminator.",null,null],[13,"CRLF","","Parses `\\r`, `\\n` or `\\r\\n` as a single record terminator.",2,null],[13,"Any","","Parses the byte given as a record terminator.",2,null],[4,"QuoteStyle","","The quoting style to use when writing CSV data.",null,null],[13,"Always","","This puts quotes around every field. Always.",3,null],[13,"Necessary","","This puts quotes around fields only when necessary.",3,null],[13,"Never","","This *never* writes quotes.",3,null],[4,"Error","","An error produced by an operation on CSV data.",null,null],[13,"Encode","","An error reported by the type-based encoder.",4,null],[13,"Decode","","An error reported by the type-based decoder.",4,null],[13,"Parse","","An error reported by the CSV parser.",4,null],[13,"Io","","An error originating from reading or writing to the underlying buffer.",4,null],[13,"Index","","An error originating from using a CSV index.",4,null],[4,"ParseError","","A description of a CSV parse error.",null,null],[13,"UnequalLengths","","A record was found that has a different size than other records.",5,null],[12,"expected","csv::ParseError","Expected a record with this many fields.",5,null],[12,"got","","Got a record with this many fields.",5,null],[13,"InvalidUtf8","csv","An error occurred when trying to convert a field to a Unicode string.",5,null],[0,"index","","This sub-module provides experimental CSV record indexing.",null,null],[3,"Indexed","csv::index","A type for representing CSV data with a basic record index.",null,null],[5,"create_index","","Creates a new index for the given CSV reader.",null,{"inputs":[{"name":"reader"},{"name":"w"}],"output":{"name":"result"}}],[11,"deref","","",6,null],[11,"deref_mut","","",6,null],[11,"open","","Opens a new index corresponding to the CSV reader given.",6,{"inputs":[{"name":"reader"},{"name":"i"}],"output":{"name":"result"}}],[11,"seek","","Seeks to `i`th record.",6,null],[11,"count","","Returns the number of CSV records in the index in `O(1)` time.",6,null],[11,"new","csv","Creates a new encodable record. The value returned can be passed to\n`Encodable::encode`.",7,{"inputs":[],"output":{"name":"encoded"}}],[11,"unwrap","","Once a record has been encoded into this value, `unwrap` can be used\nto access the raw CSV record.",7,null],[11,"emit_nil","","",7,null],[11,"emit_usize","","",7,null],[11,"emit_u64","","",7,null],[11,"emit_u32","","",7,null],[11,"emit_u16","","",7,null],[11,"emit_u8","","",7,null],[11,"emit_isize","","",7,null],[11,"emit_i64","","",7,null],[11,"emit_i32","","",7,null],[11,"emit_i16","","",7,null],[11,"emit_i8","","",7,null],[11,"emit_bool","","",7,null],[11,"emit_f64","","",7,null],[11,"emit_f32","","",7,null],[11,"emit_char","","",7,null],[11,"emit_str","","",7,null],[11,"emit_enum","","",7,null],[11,"emit_enum_variant","","",7,null],[11,"emit_enum_variant_arg","","",7,null],[11,"emit_enum_struct_variant","","",7,null],[11,"emit_enum_struct_variant_field","","",7,null],[11,"emit_struct","","",7,null],[11,"emit_struct_field","","",7,null],[11,"emit_tuple","","",7,null],[11,"emit_tuple_arg","","",7,null],[11,"emit_tuple_struct","","",7,null],[11,"emit_tuple_struct_arg","","",7,null],[11,"emit_option","","",7,null],[11,"emit_option_none","","",7,null],[11,"emit_option_some","","",7,null],[11,"emit_seq","","",7,null],[11,"emit_seq_elt","","",7,null],[11,"emit_map","","",7,null],[11,"emit_map_elt_key","","",7,null],[11,"emit_map_elt_val","","",7,null],[11,"new","","Creates a new decodable record from a record of byte strings.",8,{"inputs":[{"name":"vec"}],"output":{"name":"decoded"}}],[11,"error","","",8,null],[11,"read_nil","","",8,null],[11,"read_usize","","",8,null],[11,"read_u64","","",8,null],[11,"read_u32","","",8,null],[11,"read_u16","","",8,null],[11,"read_u8","","",8,null],[11,"read_isize","","",8,null],[11,"read_i64","","",8,null],[11,"read_i32","","",8,null],[11,"read_i16","","",8,null],[11,"read_i8","","",8,null],[11,"read_bool","","",8,null],[11,"read_f64","","",8,null],[11,"read_f32","","",8,null],[11,"read_char","","",8,null],[11,"read_str","","",8,null],[11,"read_enum","","",8,null],[11,"read_enum_variant","","",8,null],[11,"read_enum_variant_arg","","",8,null],[11,"read_enum_struct_variant","","",8,null],[11,"read_enum_struct_variant_field","","",8,null],[11,"read_struct","","",8,null],[11,"read_struct_field","","",8,null],[11,"read_tuple","","",8,null],[11,"read_tuple_arg","","",8,null],[11,"read_tuple_struct","","",8,null],[11,"read_tuple_struct_arg","","",8,null],[11,"read_option","","",8,null],[11,"read_seq","","",8,null],[11,"read_seq_elt","","",8,null],[11,"read_map","","",8,null],[11,"read_map_elt_key","","",8,null],[11,"read_map_elt_val","","",8,null],[11,"clone","","",2,null],[11,"eq","","",2,null],[11,"from_reader","","Creates a new CSV reader from an arbitrary `io::Read`.",9,{"inputs":[{"name":"r"}],"output":{"name":"reader"}}],[11,"from_file","","Creates a new CSV reader for the data at the file path given.",9,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"from_string","","Creates a CSV reader for an in memory string buffer.",9,{"inputs":[{"name":"s"}],"output":{"name":"reader"}}],[11,"from_bytes","","Creates a CSV reader for an in memory buffer of bytes.",9,{"inputs":[{"name":"v"}],"output":{"name":"reader"}}],[11,"decode","","Uses type-based decoding to read a single record from CSV data.",9,null],[11,"records","","Returns an iterator of records in the CSV data where each field is\na `String`.",9,null],[11,"headers","","Returns a *copy* of the first record in the CSV data as strings.",9,null],[11,"delimiter","","The delimiter to use when reading CSV data.",9,null],[11,"has_headers","","Whether to treat the first row as a special header row.",9,null],[11,"flexible","","Whether to allow flexible length records when reading CSV data.",9,null],[11,"record_terminator","","Set the record terminator to use when reading CSV data.",9,null],[11,"quote","","Set the quote character to use when reading CSV data.",9,null],[11,"escape","","Set the escape character to use when reading CSV data.",9,null],[11,"double_quote","","Enable double quote escapes.",9,null],[11,"ascii","","A convenience method for reading ASCII delimited text.",9,null],[11,"fmt","","",1,null],[11,"into_iter_result","","Transform NextField into an iterator result.",1,null],[11,"is_end","","Returns true if and only if the end of CSV data has been reached.",1,null],[11,"unwrap","","Returns the underlying field data.",1,null],[11,"byte_headers","","This is just like `headers`, except fields are `ByteString`s instead\nof `String`s.",9,null],[11,"byte_records","","This is just like `records`, except fields are `ByteString`s instead\nof `String`s.",9,null],[11,"done","","Returns `true` if the CSV parser has reached its final state. When\nthis method returns `true`, all iterators will always return `None`.",9,null],[11,"next_bytes","","An iterator over fields in the current record.",9,null],[11,"next_str","","This is just like `next_bytes` except it converts each field to\na Unicode string in place.",9,null],[11,"byte_offset","","Returns the byte offset at which the current record started.",9,null],[11,"seek","","Seeks the underlying reader to the file cursor specified.",9,null],[11,"next","","",10,null],[11,"next","","",11,null],[11,"next","","",12,null],[11,"clone","","",3,null],[11,"from_file","","Creates a new `Writer` that writes CSV data to the file path given.",13,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"from_writer","","Creates a new CSV writer that writes to the `io::Write` given.",13,{"inputs":[{"name":"w"}],"output":{"name":"writer"}}],[11,"from_buffer","","Creates a new CSV writer that writes to the buffer given.",13,{"inputs":[{"name":"bufwriter"}],"output":{"name":"writer"}}],[11,"from_memory","","Creates a new CSV writer that writes to an in memory buffer. At any\ntime, `as_string` or `as_bytes` can be called to retrieve the\ncumulative CSV data.",13,{"inputs":[],"output":{"name":"writer"}}],[11,"as_string","","Returns the written CSV data as a string.",13,null],[11,"as_bytes","","Returns the encoded CSV data as raw bytes.",13,null],[11,"into_string","","Convert the Writer into a string of written CSV data",13,null],[11,"into_bytes","","Convert the Writer into a vector of encoded CSV bytes.",13,null],[11,"encode","","Writes a record by encoding any `Encodable` value.",13,null],[11,"write","","Writes a record of strings (Unicode or raw bytes).",13,null],[11,"flush","","Flushes the underlying buffer.",13,null],[11,"delimiter","","The delimiter to use when writing CSV data.",13,null],[11,"flexible","","Whether to allow flexible length records when writing CSV data.",13,null],[11,"record_terminator","","Sets the record terminator to use when writing CSV data.",13,null],[11,"quote_style","","Set the quoting style to use when writing CSV data.",13,null],[11,"quote","","Set the quote character to use when writing CSV data.",13,null],[11,"escape","","Set the escape character to use when writing CSV data.",13,null],[11,"double_quote","","Set the quoting escape mechanism.",13,null],[6,"Result","","A convenience type for representing the result of most CSV reader/writer\noperations.",null,null],[6,"ByteString","","A convenience type for referring to a plain byte string.",null,null],[8,"BorrowBytes","","A trait that permits borrowing byte vectors.",null,null],[10,"borrow_bytes","","Borrow a byte vector.",14,null],[11,"fmt","","",4,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"fmt","","",4,null],[11,"fmt","","",0,null],[11,"fmt","","",5,null],[11,"description","","",4,null],[11,"cause","","",4,null],[11,"from","","",4,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"borrow_bytes","","",15,null]],"paths":[[3,"LocatableError"],[4,"NextField"],[4,"RecordTerminator"],[4,"QuoteStyle"],[4,"Error"],[4,"ParseError"],[3,"Indexed"],[3,"Encoded"],[3,"Decoded"],[3,"Reader"],[3,"DecodedRecords"],[3,"StringRecords"],[3,"ByteRecords"],[3,"Writer"],[8,"BorrowBytes"],[6,"ByteString"]]};
searchIndex["rustc_serialize"] = {"doc":"Support code for encoding and decoding types.","items":[[0,"base64","rustc_serialize","Base64 binary-to-text encoding",null,null],[3,"Config","rustc_serialize::base64","Contains configuration parameters for `to_base64`.",null,null],[12,"char_set","","Character set to use",0,null],[12,"newline","","Newline to use",0,null],[12,"pad","","True to pad output with `=` characters",0,null],[12,"line_length","","`Some(len)` to wrap lines at `len`, `None` to disable line wrapping",0,null],[4,"CharacterSet","","Available encoding character sets",null,null],[13,"Standard","","The standard character set (uses `+` and `/`)",1,null],[13,"UrlSafe","","The URL safe character set (uses `-` and `_`)",1,null],[4,"Newline","","Available newline types",null,null],[13,"LF","","A linefeed (i.e. Unix-style newline)",2,null],[13,"CRLF","","A carriage return and a linefeed (i.e. Windows-style newline)",2,null],[4,"FromBase64Error","","Errors that can occur when decoding a base64 encoded string",null,null],[13,"InvalidBase64Byte","","The input contained a character not part of the base64 format",3,null],[13,"InvalidBase64Length","","The input had an invalid length",3,null],[7,"STANDARD","","Configuration for RFC 4648 standard base64 encoding",null,null],[7,"URL_SAFE","","Configuration for RFC 4648 base64url encoding",null,null],[7,"MIME","","Configuration for RFC 2045 MIME base64 encoding",null,null],[8,"ToBase64","","A trait for converting a value to base64 encoding.",null,null],[10,"to_base64","","Converts the value of `self` to a base64 value following the specified\nformat configuration, returning the owned string.",4,null],[8,"FromBase64","","A trait for converting from base64 encoded values.",null,null],[10,"from_base64","","Converts the value of `self`, interpreted as base64 encoded data, into\nan owned vector of bytes, returning the vector.",5,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"fmt","","",2,null],[11,"clone","","",2,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"description","","",3,null],[11,"fmt","","",3,null],[0,"hex","rustc_serialize","Hex binary-to-text encoding",null,null],[4,"FromHexError","rustc_serialize::hex","Errors that can occur when decoding a hex encoded string",null,null],[13,"InvalidHexCharacter","","The input contained a character not part of the hex format",6,null],[13,"InvalidHexLength","","The input had an invalid length",6,null],[8,"ToHex","","A trait for converting a value to hexadecimal encoding",null,null],[10,"to_hex","","Converts the value of `self` to a hex value, returning the owned\nstring.",7,null],[8,"FromHex","","A trait for converting hexadecimal encoded values",null,null],[10,"from_hex","","Converts the value of `self`, interpreted as hexadecimal encoded data,\ninto an owned vector of bytes, returning the vector.",8,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"description","","",6,null],[11,"fmt","","",6,null],[0,"json","rustc_serialize","JSON parsing and serialization",null,null],[3,"PrettyJson","rustc_serialize::json","",null,null],[3,"AsJson","","",null,null],[3,"AsPrettyJson","","",null,null],[3,"Encoder","","A structure for implementing serialization to JSON.",null,null],[3,"Stack","","A Stack represents the current position of the parser in the logical\nstructure of the JSON stream.\nFor example foo.bar[3].x",null,null],[3,"Parser","","A streaming JSON parser implemented as an iterator of JsonEvent, consuming\nan iterator of char.",null,null],[3,"Builder","","A Builder consumes a json::Parser to create a generic Json structure.",null,null],[3,"Decoder","","A structure to decode JSON to values in rust.",null,null],[4,"Json","","Represents a json value",null,null],[13,"I64","","",9,null],[13,"U64","","",9,null],[13,"F64","","",9,null],[13,"String","","",9,null],[13,"Boolean","","",9,null],[13,"Array","","",9,null],[13,"Object","","",9,null],[13,"Null","","",9,null],[4,"ErrorCode","","The errors that can arise while parsing a JSON stream.",null,null],[13,"InvalidSyntax","","",10,null],[13,"InvalidNumber","","",10,null],[13,"EOFWhileParsingObject","","",10,null],[13,"EOFWhileParsingArray","","",10,null],[13,"EOFWhileParsingValue","","",10,null],[13,"EOFWhileParsingString","","",10,null],[13,"KeyMustBeAString","","",10,null],[13,"ExpectedColon","","",10,null],[13,"TrailingCharacters","","",10,null],[13,"TrailingComma","","",10,null],[13,"InvalidEscape","","",10,null],[13,"InvalidUnicodeCodePoint","","",10,null],[13,"LoneLeadingSurrogateInHexEscape","","",10,null],[13,"UnexpectedEndOfHexEscape","","",10,null],[13,"UnrecognizedHex","","",10,null],[13,"NotFourDigit","","",10,null],[13,"ControlCharacterInString","","",10,null],[13,"NotUtf8","","",10,null],[4,"ParserError","","",null,null],[13,"SyntaxError","","msg, line, col",11,null],[13,"IoError","","",11,null],[4,"DecoderError","","",null,null],[13,"ParseError","","",12,null],[13,"ExpectedError","","",12,null],[13,"MissingFieldError","","",12,null],[13,"UnknownVariantError","","",12,null],[13,"ApplicationError","","",12,null],[13,"EOF","","",12,null],[4,"EncoderError","","",null,null],[13,"FmtError","","",13,null],[13,"BadHashmapKey","","",13,null],[4,"JsonEvent","","The output of the streaming parser.",null,null],[13,"ObjectStart","","",14,null],[13,"ObjectEnd","","",14,null],[13,"ArrayStart","","",14,null],[13,"ArrayEnd","","",14,null],[13,"BooleanValue","","",14,null],[13,"I64Value","","",14,null],[13,"U64Value","","",14,null],[13,"F64Value","","",14,null],[13,"StringValue","","",14,null],[13,"NullValue","","",14,null],[13,"Error","","",14,null],[4,"StackElement","","StackElements compose a Stack.\nFor example, Key(&quot;foo&quot;), Key(&quot;bar&quot;), Index(3) and Key(&quot;x&quot;) are the\nStackElements compositing the stack that represents foo.bar[3].x",null,null],[13,"Index","","",15,null],[13,"Key","","",15,null],[5,"error_str","","Returns a readable error string for a given error code.",null,{"inputs":[{"name":"errorcode"}],"output":{"name":"str"}}],[5,"decode","","Shortcut function to decode a JSON `&amp;str` into an object",null,{"inputs":[{"name":"str"}],"output":{"name":"decoderesult"}}],[5,"encode","","Shortcut function to encode a `T` into a JSON `String`",null,{"inputs":[{"name":"t"}],"output":{"name":"encoderesult"}}],[5,"as_json","","Create an `AsJson` wrapper which can be used to print a value as JSON\non-the-fly via `write!`",null,{"inputs":[{"name":"t"}],"output":{"name":"asjson"}}],[5,"as_pretty_json","","Create an `AsPrettyJson` wrapper which can be used to print a value as JSON\non-the-fly via `write!`",null,{"inputs":[{"name":"t"}],"output":{"name":"asprettyjson"}}],[6,"Array","","",null,null],[6,"Object","","",null,null],[6,"BuilderError","","",null,null],[6,"EncodeResult","","",null,null],[6,"DecodeResult","","",null,null],[8,"ToJson","","A trait for converting values to JSON",null,null],[10,"to_json","","Converts the value of `self` to an instance of JSON",16,null],[11,"fmt","","",9,null],[11,"partial_cmp","","",9,null],[11,"lt","","",9,null],[11,"le","","",9,null],[11,"gt","","",9,null],[11,"ge","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"clone","","",9,null],[11,"eq","","",10,null],[11,"clone","","",10,null],[11,"fmt","","",11,null],[11,"eq","","",11,null],[11,"fmt","","",12,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"fmt","","",13,null],[11,"clone","","",13,null],[11,"fmt","","",10,null],[11,"description","","",12,null],[11,"cause","","",12,null],[11,"fmt","","",12,null],[11,"from","","",12,{"inputs":[{"name":"parsererror"}],"output":{"name":"decodererror"}}],[11,"description","","",11,null],[11,"fmt","","",11,null],[11,"from","","",11,{"inputs":[{"name":"error"}],"output":{"name":"parsererror"}}],[11,"description","","",13,null],[11,"fmt","","",13,null],[11,"from","","",13,{"inputs":[{"name":"error"}],"output":{"name":"encodererror"}}],[11,"new_pretty","","Creates a new encoder whose output will be written in human-readable\nJSON to the specified writer",17,{"inputs":[{"name":"write"}],"output":{"name":"encoder"}}],[11,"new","","Creates a new encoder whose output will be written in compact\nJSON to the specified writer",17,{"inputs":[{"name":"write"}],"output":{"name":"encoder"}}],[11,"set_indent","","Set the number of spaces to indent for each level.\nThis is safe to set during encoding.",17,null],[11,"emit_nil","","",17,null],[11,"emit_usize","","",17,null],[11,"emit_u64","","",17,null],[11,"emit_u32","","",17,null],[11,"emit_u16","","",17,null],[11,"emit_u8","","",17,null],[11,"emit_isize","","",17,null],[11,"emit_i64","","",17,null],[11,"emit_i32","","",17,null],[11,"emit_i16","","",17,null],[11,"emit_i8","","",17,null],[11,"emit_bool","","",17,null],[11,"emit_f64","","",17,null],[11,"emit_f32","","",17,null],[11,"emit_char","","",17,null],[11,"emit_str","","",17,null],[11,"emit_enum","","",17,null],[11,"emit_enum_variant","","",17,null],[11,"emit_enum_variant_arg","","",17,null],[11,"emit_enum_struct_variant","","",17,null],[11,"emit_enum_struct_variant_field","","",17,null],[11,"emit_struct","","",17,null],[11,"emit_struct_field","","",17,null],[11,"emit_tuple","","",17,null],[11,"emit_tuple_arg","","",17,null],[11,"emit_tuple_struct","","",17,null],[11,"emit_tuple_struct_arg","","",17,null],[11,"emit_option","","",17,null],[11,"emit_option_none","","",17,null],[11,"emit_option_some","","",17,null],[11,"emit_seq","","",17,null],[11,"emit_seq_elt","","",17,null],[11,"emit_map","","",17,null],[11,"emit_map_elt_key","","",17,null],[11,"emit_map_elt_val","","",17,null],[11,"encode","","",9,null],[11,"from_reader","","Decodes a json value from an `&amp;mut io::Read`",9,{"inputs":[{"name":"read"}],"output":{"name":"result"}}],[11,"from_str","","Decodes a json value from a string",9,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"pretty","","Borrow this json object as a pretty object to generate a pretty\nrepresentation for it via `Display`.",9,null],[11,"find","","If the Json value is an Object, returns the value associated with the provided key.\nOtherwise, returns None.",9,null],[11,"find_path","","Attempts to get a nested Json Object for each key in `keys`.\nIf any key is found not to exist, find_path will return None.\nOtherwise, it will return the Json value associated with the final key.",9,null],[11,"search","","If the Json value is an Object, performs a depth-first search until\na value associated with the provided key is found. If no value is found\nor the Json value is not an Object, returns None.",9,null],[11,"is_object","","Returns true if the Json value is an Object. Returns false otherwise.",9,null],[11,"as_object","","If the Json value is an Object, returns the associated BTreeMap.\nReturns None otherwise.",9,null],[11,"as_object_mut","","If the Json value is an Object, returns the associated mutable BTreeMap.\nReturns None otherwise.",9,null],[11,"is_array","","Returns true if the Json value is an Array. Returns false otherwise.",9,null],[11,"as_array","","If the Json value is an Array, returns the associated vector.\nReturns None otherwise.",9,null],[11,"as_array_mut","","If the Json value is an Array, returns the associated mutable vector.\nReturns None otherwise.",9,null],[11,"is_string","","Returns true if the Json value is a String. Returns false otherwise.",9,null],[11,"as_string","","If the Json value is a String, returns the associated str.\nReturns None otherwise.",9,null],[11,"is_number","","Returns true if the Json value is a Number. Returns false otherwise.",9,null],[11,"is_i64","","Returns true if the Json value is a i64. Returns false otherwise.",9,null],[11,"is_u64","","Returns true if the Json value is a u64. Returns false otherwise.",9,null],[11,"is_f64","","Returns true if the Json value is a f64. Returns false otherwise.",9,null],[11,"as_i64","","If the Json value is a number, return or cast it to a i64.\nReturns None otherwise.",9,null],[11,"as_u64","","If the Json value is a number, return or cast it to a u64.\nReturns None otherwise.",9,null],[11,"as_f64","","If the Json value is a number, return or cast it to a f64.\nReturns None otherwise.",9,null],[11,"is_boolean","","Returns true if the Json value is a Boolean. Returns false otherwise.",9,null],[11,"as_boolean","","If the Json value is a Boolean, returns the associated bool.\nReturns None otherwise.",9,null],[11,"is_null","","Returns true if the Json value is a Null. Returns false otherwise.",9,null],[11,"as_null","","If the Json value is a Null, returns ().\nReturns None otherwise.",9,null],[11,"index","","",9,null],[11,"index","","",9,null],[11,"fmt","","",14,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"fmt","","",15,null],[11,"clone","","",15,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"new","","",18,{"inputs":[],"output":{"name":"stack"}}],[11,"len","","Returns The number of elements in the Stack.",18,null],[11,"is_empty","","Returns true if the stack is empty.",18,null],[11,"get","","Provides access to the StackElement at a given index.\nlower indices are at the bottom of the stack while higher indices are\nat the top.",18,null],[11,"is_equal_to","","Compares this stack with an array of StackElements.",18,null],[11,"starts_with","","Returns true if the bottom-most elements of this stack are the same as\nthe ones passed as parameter.",18,null],[11,"ends_with","","Returns true if the top-most elements of this stack are the same as\nthe ones passed as parameter.",18,null],[11,"top","","Returns the top-most element (if any).",18,null],[11,"next","","",19,null],[11,"new","","Creates the JSON parser.",19,{"inputs":[{"name":"t"}],"output":{"name":"parser"}}],[11,"stack","","Provides access to the current position in the logical structure of the\nJSON stream.",19,null],[11,"new","","Create a JSON Builder.",20,{"inputs":[{"name":"t"}],"output":{"name":"builder"}}],[11,"build","","",20,null],[11,"new","","Creates a new decoder instance for decoding the specified JSON value.",21,{"inputs":[{"name":"json"}],"output":{"name":"decoder"}}],[11,"read_nil","","",21,null],[11,"read_usize","","",21,null],[11,"read_u8","","",21,null],[11,"read_u16","","",21,null],[11,"read_u32","","",21,null],[11,"read_u64","","",21,null],[11,"read_isize","","",21,null],[11,"read_i8","","",21,null],[11,"read_i16","","",21,null],[11,"read_i32","","",21,null],[11,"read_i64","","",21,null],[11,"read_f32","","",21,null],[11,"read_f64","","",21,null],[11,"read_bool","","",21,null],[11,"read_char","","",21,null],[11,"read_str","","",21,null],[11,"read_enum","","",21,null],[11,"read_enum_variant","","",21,null],[11,"read_enum_variant_arg","","",21,null],[11,"read_enum_struct_variant","","",21,null],[11,"read_enum_struct_variant_field","","",21,null],[11,"read_struct","","",21,null],[11,"read_struct_field","","",21,null],[11,"read_tuple","","",21,null],[11,"read_tuple_arg","","",21,null],[11,"read_tuple_struct","","",21,null],[11,"read_tuple_struct_arg","","",21,null],[11,"read_option","","",21,null],[11,"read_seq","","",21,null],[11,"read_seq_elt","","",21,null],[11,"read_map","","",21,null],[11,"read_map_elt_key","","",21,null],[11,"read_map_elt_val","","",21,null],[11,"error","","",21,null],[11,"to_json","","",9,null],[11,"fmt","","Encodes a json value into a string",9,null],[11,"fmt","","Encodes a json value into a string",22,null],[11,"fmt","","Encodes a json value into a string",23,null],[11,"indent","","Set the indentation level for the emitted JSON",24,null],[11,"fmt","","Encodes a json value into a string",24,null],[11,"from_str","","",9,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[8,"Decoder","rustc_serialize","",null,null],[16,"Error","","",25,null],[10,"read_nil","","",25,null],[10,"read_usize","","",25,null],[10,"read_u64","","",25,null],[10,"read_u32","","",25,null],[10,"read_u16","","",25,null],[10,"read_u8","","",25,null],[10,"read_isize","","",25,null],[10,"read_i64","","",25,null],[10,"read_i32","","",25,null],[10,"read_i16","","",25,null],[10,"read_i8","","",25,null],[10,"read_bool","","",25,null],[10,"read_f64","","",25,null],[10,"read_f32","","",25,null],[10,"read_char","","",25,null],[10,"read_str","","",25,null],[10,"read_enum","","",25,null],[10,"read_enum_variant","","",25,null],[10,"read_enum_variant_arg","","",25,null],[10,"read_enum_struct_variant","","",25,null],[10,"read_enum_struct_variant_field","","",25,null],[10,"read_struct","","",25,null],[10,"read_struct_field","","",25,null],[10,"read_tuple","","",25,null],[10,"read_tuple_arg","","",25,null],[10,"read_tuple_struct","","",25,null],[10,"read_tuple_struct_arg","","",25,null],[10,"read_option","","",25,null],[10,"read_seq","","",25,null],[10,"read_seq_elt","","",25,null],[10,"read_map","","",25,null],[10,"read_map_elt_key","","",25,null],[10,"read_map_elt_val","","",25,null],[10,"error","","",25,null],[8,"Encoder","","",null,null],[16,"Error","","",26,null],[10,"emit_nil","","",26,null],[10,"emit_usize","","",26,null],[10,"emit_u64","","",26,null],[10,"emit_u32","","",26,null],[10,"emit_u16","","",26,null],[10,"emit_u8","","",26,null],[10,"emit_isize","","",26,null],[10,"emit_i64","","",26,null],[10,"emit_i32","","",26,null],[10,"emit_i16","","",26,null],[10,"emit_i8","","",26,null],[10,"emit_bool","","",26,null],[10,"emit_f64","","",26,null],[10,"emit_f32","","",26,null],[10,"emit_char","","",26,null],[10,"emit_str","","",26,null],[10,"emit_enum","","",26,null],[10,"emit_enum_variant","","",26,null],[10,"emit_enum_variant_arg","","",26,null],[10,"emit_enum_struct_variant","","",26,null],[10,"emit_enum_struct_variant_field","","",26,null],[10,"emit_struct","","",26,null],[10,"emit_struct_field","","",26,null],[10,"emit_tuple","","",26,null],[10,"emit_tuple_arg","","",26,null],[10,"emit_tuple_struct","","",26,null],[10,"emit_tuple_struct_arg","","",26,null],[10,"emit_option","","",26,null],[10,"emit_option_none","","",26,null],[10,"emit_option_some","","",26,null],[10,"emit_seq","","",26,null],[10,"emit_seq_elt","","",26,null],[10,"emit_map","","",26,null],[10,"emit_map_elt_key","","",26,null],[10,"emit_map_elt_val","","",26,null],[8,"Decodable","","",null,null],[10,"decode","","",27,{"inputs":[{"name":"d"}],"output":{"name":"result"}}],[8,"Encodable","","",null,null],[10,"encode","","",28,null],[8,"DecoderHelpers","","",null,null],[10,"read_to_vec","","",29,null],[8,"EncoderHelpers","","",null,null],[10,"emit_from_vec","","",30,null]],"paths":[[3,"Config"],[4,"CharacterSet"],[4,"Newline"],[4,"FromBase64Error"],[8,"ToBase64"],[8,"FromBase64"],[4,"FromHexError"],[8,"ToHex"],[8,"FromHex"],[4,"Json"],[4,"ErrorCode"],[4,"ParserError"],[4,"DecoderError"],[4,"EncoderError"],[4,"JsonEvent"],[4,"StackElement"],[8,"ToJson"],[3,"Encoder"],[3,"Stack"],[3,"Parser"],[3,"Builder"],[3,"Decoder"],[3,"PrettyJson"],[3,"AsJson"],[3,"AsPrettyJson"],[8,"Decoder"],[8,"Encoder"],[8,"Decodable"],[8,"Encodable"],[8,"DecoderHelpers"],[8,"EncoderHelpers"]]};
searchIndex["custom_derive"] = {"doc":"This crate provides a macro that enables the use of custom `derive` attributes.","items":[],"paths":[]};
searchIndex["quick_error"] = {"doc":"A macro which makes errors easy to write","items":[[3,"Context","quick_error","",null,null],[12,"0","","",0,null],[12,"1","","",0,null],[8,"ResultExt","","",null,null],[10,"context","","",1,null],[11,"fmt","","",0,null],[14,"quick_error!","","Main macro that does all the work",null,null]],"paths":[[3,"Context"],[8,"ResultExt"]]};
searchIndex["bit_set"] = {"doc":"An implementation of a set using a bit vector as an underlying\nrepresentation for holding unsigned numerical elements.","items":[[3,"BitSet","bit_set","",null,null],[3,"Iter","","An iterator for `BitSet`.",null,null],[3,"Union","","",null,null],[3,"Intersection","","",null,null],[3,"Difference","","",null,null],[3,"SymmetricDifference","","",null,null],[11,"clone","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","",0,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[11,"eq","","",0,null],[11,"new","","Creates a new empty `BitSet`.",0,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Creates a new `BitSet` with initially no contents, able to\nhold `nbits` elements without resizing.",0,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from_bit_vec","","Creates a new `BitSet` from the given bit vector.",0,{"inputs":[{"name":"bitvec"}],"output":{"name":"self"}}],[11,"from_bytes","","",0,null],[11,"capacity","","Returns the capacity in bits for this bit vector. Inserting any\nelement less than this amount will not trigger a resizing.",0,null],[11,"reserve_len","","Reserves capacity for the given `BitSet` to contain `len` distinct elements. In the case\nof `BitSet` this means reallocations will not occur as long as all inserted elements\nare less than `len`.",0,null],[11,"reserve_len_exact","","Reserves the minimum capacity for the given `BitSet` to contain `len` distinct elements.\nIn the case of `BitSet` this means reallocations will not occur as long as all inserted\nelements are less than `len`.",0,null],[11,"into_bit_vec","","Consumes this set to return the underlying bit vector.",0,null],[11,"get_ref","","Returns a reference to the underlying bit vector.",0,null],[11,"shrink_to_fit","","Truncates the underlying vector to the least length required.",0,null],[11,"iter","","Iterator over each usize stored in the `BitSet`.",0,null],[11,"union","","Iterator over each usize stored in `self` union `other`.\nSee [union_with](#method.union_with) for an efficient in-place version.",0,null],[11,"intersection","","Iterator over each usize stored in `self` intersect `other`.\nSee [intersect_with](#method.intersect_with) for an efficient in-place version.",0,null],[11,"difference","","Iterator over each usize stored in the `self` setminus `other`.\nSee [difference_with](#method.difference_with) for an efficient in-place version.",0,null],[11,"symmetric_difference","","Iterator over each usize stored in the symmetric difference of `self` and `other`.\nSee [symmetric_difference_with](#method.symmetric_difference_with) for\nan efficient in-place version.",0,null],[11,"union_with","","Unions in-place with the specified other bit vector.",0,null],[11,"intersect_with","","Intersects in-place with the specified other bit vector.",0,null],[11,"difference_with","","Makes this bit vector the difference with the specified other bit vector\nin-place.",0,null],[11,"symmetric_difference_with","","Makes this bit vector the symmetric difference with the specified other\nbit vector in-place.",0,null],[11,"len","","Returns the number of set bits in this set.",0,null],[11,"is_empty","","Returns whether there are no bits set in this set",0,null],[11,"clear","","Clears all bits in this set",0,null],[11,"contains","","Returns `true` if this set contains the specified integer.",0,null],[11,"is_disjoint","","Returns `true` if the set has no elements in common with `other`.\nThis is equivalent to checking for an empty intersection.",0,null],[11,"is_subset","","Returns `true` if the set is a subset of another.",0,null],[11,"is_superset","","Returns `true` if the set is a superset of another.",0,null],[11,"insert","","Adds a value to the set. Returns `true` if the value was not already\npresent in the set.",0,null],[11,"remove","","Removes a value from the set. Returns `true` if the value was\npresent in the set.",0,null],[11,"fmt","","",0,null],[11,"hash","","",0,null],[11,"clone","","",1,null],[11,"clone","","",2,null],[11,"clone","","",3,null],[11,"clone","","",4,null],[11,"clone","","",5,null],[11,"next","","",1,null],[11,"size_hint","","",1,null],[11,"next","","",2,null],[11,"size_hint","","",2,null],[11,"next","","",3,null],[11,"size_hint","","",3,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next","","",5,null],[11,"size_hint","","",5,null]],"paths":[[3,"BitSet"],[3,"Iter"],[3,"Union"],[3,"Intersection"],[3,"Difference"],[3,"SymmetricDifference"]]};
searchIndex["matrixmultiply"] = {"doc":"","items":[[5,"sgemm","matrixmultiply","General matrix multiplication (f32)",null,null],[5,"dgemm","","General matrix multiplication (f64)",null,null]],"paths":[]};
searchIndex["void"] = {"doc":"# Void","items":[[4,"Void","void","The empty type for cases which can&#39;t occur.",null,null],[5,"unreachable","","A safe version of `intrinsincs::unreachable`.",null,null],[8,"ResultVoidExt","","Extensions to `Result&lt;T, Void&gt;`",null,null],[10,"void_unwrap","","Get the value out of a wrapper.",0,null],[8,"ResultVoidErrExt","","Extensions to `Result&lt;Void, E&gt;`",null,null],[10,"void_unwrap_err","","Get the error out of a wrapper.",1,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"partial_cmp","","",2,null]],"paths":[[8,"ResultVoidExt"],[8,"ResultVoidErrExt"],[4,"Void"]]};
searchIndex["either"] = {"doc":"The enum [**Either**](enum.Either.html).","items":[[4,"Either","either","`Either` represents an alternative holding one value out of\neither of the two possible values.",null,null],[13,"Left","","A value of type `L`.",0,null],[13,"Right","","A value of type `R`.",0,null],[11,"fmt","","",0,null],[11,"hash","","",0,null],[11,"cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"lt","","",0,null],[11,"le","","",0,null],[11,"gt","","",0,null],[11,"ge","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"clone","","",0,null],[11,"is_left","","Return true if the value is the `Left` variant.",0,null],[11,"is_right","","Return true if the value is the `Right` variant.",0,null],[11,"left","","Convert the left side of `Either&lt;L, R&gt;` to an `Option&lt;L&gt;`.",0,null],[11,"right","","Convert the right side of `Either&lt;L, R&gt;` to an `Option&lt;R&gt;`.",0,null],[11,"as_ref","","Convert `&amp;Either&lt;L, R&gt;` to `Either&lt;&amp;L, &amp;R&gt;`.",0,null],[11,"as_mut","","Convert `&amp;mut Either&lt;L, R&gt;` to `Either&lt;&amp;mut L, &amp;mut R&gt;`.",0,null],[11,"flip","","Convert `Either&lt;L, R&gt;` to `Either&lt;R, L&gt;`.",0,null],[11,"map_left","","Apply the function `f` on the value in the `Left` variant if it is present.",0,null],[11,"map_right","","Apply the function `f` on the value in the `Right` variant if it is present.",0,null],[11,"either","","Apply one of two functions depending on contents, unifying their result. If the value is\n`Left(L)` then the first function `f` is applied; if it is `Right(R)` then the second\nfunction `g` is applied.",0,null],[11,"from","","",0,{"inputs":[{"name":"result"}],"output":{"name":"self"}}],[11,"into","","",0,null],[11,"next","","",0,null],[11,"size_hint","","",0,null],[11,"fold","","",0,null],[11,"next_back","","",0,null],[11,"as_ref","","",0,null],[11,"as_mut","","",0,null],[11,"deref","","",0,null],[11,"deref_mut","","",0,null],[11,"fmt","","",0,null],[14,"try_left!","","Macro for unwrapping the left side of an `Either`, which fails early\nwith the opposite side. Can only be used in functions that return\n`Either` because of the early return of `Right` that it provides.",null,null],[14,"try_right!","","Dual to `try_left!`, see its documentation for more information.",null,null]],"paths":[[4,"Either"]]};
searchIndex["newtype_derive"] = {"doc":"This crate provides several macros for deriving implementations of various traits for &quot;newtype&quot; wrappers (*i.e.* tuple structs with a single element).  That is, given a tuple struct with exactly one field (*e.g.* `struct Buckets(i32)`), these macros will derive &quot;obvious&quot; implementations of traits such as `Add`, `Neg`, `Index`, `Deref`, `From`, etc.","items":[[14,"NewtypeAdd!","newtype_derive","",null,null],[14,"NewtypeAddAssign!","","",null,null],[14,"NewtypeBitAnd!","","",null,null],[14,"NewtypeBitAndAssign!","","",null,null],[14,"NewtypeBitOr!","","",null,null],[14,"NewtypeBitOrAssign!","","",null,null],[14,"NewtypeBitXor!","","",null,null],[14,"NewtypeBitXorAssign!","","",null,null],[14,"NewtypeDiv!","","",null,null],[14,"NewtypeDivAssign!","","",null,null],[14,"NewtypeMul!","","",null,null],[14,"NewtypeMulAssign!","","",null,null],[14,"NewtypeRem!","","",null,null],[14,"NewtypeRemAssign!","","",null,null],[14,"NewtypeSub!","","",null,null],[14,"NewtypeSubAssign!","","",null,null],[14,"NewtypeShl!","","",null,null],[14,"NewtypeShlAssign!","","",null,null],[14,"NewtypeShr!","","",null,null],[14,"NewtypeShrAssign!","","",null,null],[14,"NewtypeNeg!","","",null,null],[14,"NewtypeNot!","","",null,null],[14,"NewtypeDeref!","","",null,null],[14,"NewtypeDerefMut!","","",null,null],[14,"NewtypeIndex!","","",null,null],[14,"NewtypeIndexMut!","","",null,null],[14,"NewtypeFrom!","","",null,null],[14,"NewtypeBinary!","","",null,null],[14,"NewtypeDebug!","","",null,null],[14,"NewtypeDisplay!","","",null,null],[14,"NewtypeLowerExp!","","",null,null],[14,"NewtypeLowerHex!","","",null,null],[14,"NewtypeOctal!","","",null,null],[14,"NewtypePointer!","","",null,null],[14,"NewtypeUpperExp!","","",null,null],[14,"NewtypeUpperHex!","","",null,null]],"paths":[]};
searchIndex["num_traits"] = {"doc":"Numeric traits for generic mathematics","items":[[3,"ParseFloatError","num_traits","",null,null],[12,"kind","","",0,null],[4,"FloatErrorKind","","",null,null],[13,"Empty","","",1,null],[13,"Invalid","","",1,null],[0,"identities","","",null,null],[5,"zero","num_traits::identities","Returns the additive identity, `0`.",null,{"inputs":[],"output":{"name":"t"}}],[5,"one","","Returns the multiplicative identity, `1`.",null,{"inputs":[],"output":{"name":"t"}}],[8,"Zero","","Defines an additive identity element for `Self`.",null,null],[10,"zero","","Returns the additive identity element of `Self`, `0`.",2,{"inputs":[],"output":{"name":"self"}}],[10,"is_zero","","Returns `true` if `self` is equal to the additive identity.",2,null],[8,"One","","Defines a multiplicative identity element for `Self`.",null,null],[10,"one","","Returns the multiplicative identity element of `Self`, `1`.",3,{"inputs":[],"output":{"name":"self"}}],[0,"sign","num_traits","",null,null],[5,"abs","num_traits::sign","Computes the absolute value.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[5,"abs_sub","","The positive difference of two numbers.",null,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"t"}}],[5,"signum","","Returns the sign of the number.",null,{"inputs":[{"name":"t"}],"output":{"name":"t"}}],[8,"Signed","","Useful functions for signed numbers (i.e. numbers that can be negative).",null,null],[10,"abs","","Computes the absolute value.",4,null],[10,"abs_sub","","The positive difference of two numbers.",4,null],[10,"signum","","Returns the sign of the number.",4,null],[10,"is_positive","","Returns true if the number is positive and false if the number is zero or negative.",4,null],[10,"is_negative","","Returns true if the number is negative and false if the number is zero or positive.",4,null],[8,"Unsigned","","A trait for values which cannot be negative",null,null],[0,"ops","num_traits","",null,null],[0,"saturating","num_traits::ops","",null,null],[8,"Saturating","num_traits::ops::saturating","Saturating math operations",null,null],[10,"saturating_add","","Saturating addition operator.\nReturns a+b, saturating at the numeric bounds instead of overflowing.",5,null],[10,"saturating_sub","","Saturating subtraction operator.\nReturns a-b, saturating at the numeric bounds instead of overflowing.",5,null],[0,"checked","num_traits::ops","",null,null],[8,"CheckedAdd","num_traits::ops::checked","Performs addition that returns `None` instead of wrapping around on\noverflow.",null,null],[10,"checked_add","","Adds two numbers, checking for overflow. If overflow happens, `None` is\nreturned.",6,null],[8,"CheckedSub","","Performs subtraction that returns `None` instead of wrapping around on underflow.",null,null],[10,"checked_sub","","Subtracts two numbers, checking for underflow. If underflow happens,\n`None` is returned.",7,null],[8,"CheckedMul","","Performs multiplication that returns `None` instead of wrapping around on underflow or\noverflow.",null,null],[10,"checked_mul","","Multiplies two numbers, checking for underflow or overflow. If underflow\nor overflow happens, `None` is returned.",8,null],[8,"CheckedDiv","","Performs division that returns `None` instead of panicking on division by zero and instead of\nwrapping around on underflow and overflow.",null,null],[10,"checked_div","","Divides two numbers, checking for underflow, overflow and division by\nzero. If any of that happens, `None` is returned.",9,null],[0,"bounds","num_traits","",null,null],[8,"Bounded","num_traits::bounds","Numbers which have upper and lower bounds",null,null],[10,"min_value","","returns the smallest finite number this type can represent",10,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","returns the largest finite number this type can represent",10,{"inputs":[],"output":{"name":"self"}}],[0,"float","num_traits","",null,null],[8,"Float","num_traits::float","",null,null],[10,"nan","","Returns the `NaN` value.",11,{"inputs":[],"output":{"name":"self"}}],[10,"infinity","","Returns the infinite value.",11,{"inputs":[],"output":{"name":"self"}}],[10,"neg_infinity","","Returns the negative infinite value.",11,{"inputs":[],"output":{"name":"self"}}],[10,"neg_zero","","Returns `-0.0`.",11,{"inputs":[],"output":{"name":"self"}}],[10,"min_value","","Returns the smallest finite value that this type can represent.",11,{"inputs":[],"output":{"name":"self"}}],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",11,{"inputs":[],"output":{"name":"self"}}],[11,"epsilon","","Returns epsilon, a small positive value.",11,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","Returns the largest finite value that this type can represent.",11,{"inputs":[],"output":{"name":"self"}}],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",11,null],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and\nfalse otherwise.",11,null],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",11,null],[10,"is_normal","","Returns `true` if the number is neither zero, infinite,\n[subnormal][subnormal], or `NaN`.",11,null],[10,"classify","","Returns the floating point category of the number. If only one property\nis going to be tested, it is generally faster to use the specific\npredicate instead.",11,null],[10,"floor","","Returns the largest integer less than or equal to a number.",11,null],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",11,null],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from\n`0.0`.",11,null],[10,"trunc","","Return the integer part of a number.",11,null],[10,"fract","","Returns the fractional part of a number.",11,null],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the\nnumber is `Float::nan()`.",11,null],[10,"signum","","Returns a number that represents the sign of `self`.",11,null],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0` and\n`Float::infinity()`.",11,null],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0` and\n`Float::neg_infinity()`.",11,null],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding\nerror. This produces a more accurate result with better performance than\na separate multiplication operation followed by an add.",11,null],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",11,null],[10,"powi","","Raise a number to an integer power.",11,null],[10,"powf","","Raise a number to a floating point power.",11,null],[10,"sqrt","","Take the square root of a number.",11,null],[10,"exp","","Returns `e^(self)`, (the exponential function).",11,null],[10,"exp2","","Returns `2^(self)`.",11,null],[10,"ln","","Returns the natural logarithm of the number.",11,null],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",11,null],[10,"log2","","Returns the base 2 logarithm of the number.",11,null],[10,"log10","","Returns the base 10 logarithm of the number.",11,null],[11,"to_degrees","","Converts radians to degrees.",11,null],[11,"to_radians","","Converts degrees to radians.",11,null],[10,"max","","Returns the maximum of the two numbers.",11,null],[10,"min","","Returns the minimum of the two numbers.",11,null],[10,"abs_sub","","The positive difference of two numbers.",11,null],[10,"cbrt","","Take the cubic root of a number.",11,null],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given\nlegs of length `x` and `y`.",11,null],[10,"sin","","Computes the sine of a number (in radians).",11,null],[10,"cos","","Computes the cosine of a number (in radians).",11,null],[10,"tan","","Computes the tangent of a number (in radians).",11,null],[10,"asin","","Computes the arcsine of a number. Return value is in radians in\nthe range [-pi/2, pi/2] or NaN if the number is outside the range\n[-1, 1].",11,null],[10,"acos","","Computes the arccosine of a number. Return value is in radians in\nthe range [0, pi] or NaN if the number is outside the range\n[-1, 1].",11,null],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the\nrange [-pi/2, pi/2];",11,null],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",11,null],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns\n`(sin(x), cos(x))`.",11,null],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the\nnumber is close to zero.",11,null],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if\nthe operations were performed separately.",11,null],[10,"sinh","","Hyperbolic sine function.",11,null],[10,"cosh","","Hyperbolic cosine function.",11,null],[10,"tanh","","Hyperbolic tangent function.",11,null],[10,"asinh","","Inverse hyperbolic sine function.",11,null],[10,"acosh","","Inverse hyperbolic cosine function.",11,null],[10,"atanh","","Inverse hyperbolic tangent function.",11,null],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively.\nThe original number can be recovered by `sign * mantissa * 2 ^ exponent`.\nThe floating point encoding is documented in the [Reference][floating-point].",11,null],[8,"FloatConst","","",null,null],[10,"E","","Return Euler’s number.",12,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_1_PI","","Return `1.0 / π`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_1_SQRT_2","","Return `1.0 / sqrt(2.0)`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_2_PI","","Return `2.0 / π`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_2_SQRT_PI","","Return `2.0 / sqrt(π)`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_2","","Return `π / 2.0`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_3","","Return `π / 3.0`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_4","","Return `π / 4.0`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_6","","Return `π / 6.0`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"FRAC_PI_8","","Return `π / 8.0`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"LN_10","","Return `ln(10.0)`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"LN_2","","Return `ln(2.0)`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"LOG10_E","","Return `log10(e)`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"LOG2_E","","Return `log2(e)`.",12,{"inputs":[],"output":{"name":"self"}}],[10,"PI","","Return Archimedes’ constant.",12,{"inputs":[],"output":{"name":"self"}}],[10,"SQRT_2","","Return `sqrt(2.0)`.",12,{"inputs":[],"output":{"name":"self"}}],[0,"cast","num_traits","",null,null],[5,"cast","num_traits::cast","Cast from one machine scalar to another.",null,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[8,"ToPrimitive","","A generic trait for converting a value to a number.",null,null],[11,"to_isize","","Converts the value of `self` to an `isize`.",13,null],[11,"to_i8","","Converts the value of `self` to an `i8`.",13,null],[11,"to_i16","","Converts the value of `self` to an `i16`.",13,null],[11,"to_i32","","Converts the value of `self` to an `i32`.",13,null],[10,"to_i64","","Converts the value of `self` to an `i64`.",13,null],[11,"to_usize","","Converts the value of `self` to a `usize`.",13,null],[11,"to_u8","","Converts the value of `self` to an `u8`.",13,null],[11,"to_u16","","Converts the value of `self` to an `u16`.",13,null],[11,"to_u32","","Converts the value of `self` to an `u32`.",13,null],[10,"to_u64","","Converts the value of `self` to an `u64`.",13,null],[11,"to_f32","","Converts the value of `self` to an `f32`.",13,null],[11,"to_f64","","Converts the value of `self` to an `f64`.",13,null],[8,"FromPrimitive","","A generic trait for converting a number to a value.",null,null],[11,"from_isize","","Convert an `isize` to return an optional value of this type. If the\nvalue cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"isize"}],"output":{"name":"option"}}],[11,"from_i8","","Convert an `i8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"i8"}],"output":{"name":"option"}}],[11,"from_i16","","Convert an `i16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"i16"}],"output":{"name":"option"}}],[11,"from_i32","","Convert an `i32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"i32"}],"output":{"name":"option"}}],[10,"from_i64","","Convert an `i64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"i64"}],"output":{"name":"option"}}],[11,"from_usize","","Convert a `usize` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_u8","","Convert an `u8` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"from_u16","","Convert an `u16` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_u32","","Convert an `u32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[10,"from_u64","","Convert an `u64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_f32","","Convert a `f32` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"f32"}],"output":{"name":"option"}}],[11,"from_f64","","Convert a `f64` to return an optional value of this type. If the\ntype cannot be represented by this value, the `None` is returned.",14,{"inputs":[{"name":"f64"}],"output":{"name":"option"}}],[8,"NumCast","","An interface for casting between machine scalars.",null,null],[10,"from","","Creates a number from another value that can be converted into\na primitive via the `ToPrimitive` trait.",15,{"inputs":[{"name":"t"}],"output":{"name":"option"}}],[0,"int","num_traits","",null,null],[8,"PrimInt","num_traits::int","",null,null],[10,"count_ones","","Returns the number of ones in the binary representation of `self`.",16,null],[10,"count_zeros","","Returns the number of zeros in the binary representation of `self`.",16,null],[10,"leading_zeros","","Returns the number of leading zeros in the binary representation\nof `self`.",16,null],[10,"trailing_zeros","","Returns the number of trailing zeros in the binary representation\nof `self`.",16,null],[10,"rotate_left","","Shifts the bits to the left by a specified amount amount, `n`, wrapping\nthe truncated bits to the end of the resulting integer.",16,null],[10,"rotate_right","","Shifts the bits to the right by a specified amount amount, `n`, wrapping\nthe truncated bits to the beginning of the resulting integer.",16,null],[10,"signed_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling\nzeros in the least significant bits.",16,null],[10,"signed_shr","","Shifts the bits to the right by a specified amount amount, `n`, copying\nthe &quot;sign bit&quot; in the most significant bits even for unsigned types.",16,null],[10,"unsigned_shl","","Shifts the bits to the left by a specified amount amount, `n`, filling\nzeros in the least significant bits.",16,null],[10,"unsigned_shr","","Shifts the bits to the right by a specified amount amount, `n`, filling\nzeros in the most significant bits.",16,null],[10,"swap_bytes","","Reverses the byte order of the integer.",16,null],[10,"from_be","","Convert an integer from big endian to the target&#39;s endianness.",16,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"from_le","","Convert an integer from little endian to the target&#39;s endianness.",16,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"to_be","","Convert `self` to big endian from the target&#39;s endianness.",16,null],[10,"to_le","","Convert `self` to little endian from the target&#39;s endianness.",16,null],[10,"pow","","Raises self to the power of `exp`, using exponentiation by squaring.",16,null],[0,"pow","num_traits","",null,null],[5,"pow","num_traits::pow","Raises a value to the power of exp, using exponentiation by squaring.",null,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"t"}}],[5,"checked_pow","","Raises a value to the power of exp, returning `None` if an overflow occurred.",null,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"option"}}],[8,"Num","num_traits","The base trait for numeric types",null,null],[16,"FromStrRadixErr","","",17,null],[10,"from_str_radix","","Convert from a string and radix &lt;= 36.",17,{"inputs":[{"name":"str"},{"name":"u32"}],"output":{"name":"result"}}],[11,"fmt","","",1,null],[11,"fmt","","",0,null]],"paths":[[3,"ParseFloatError"],[4,"FloatErrorKind"],[8,"Zero"],[8,"One"],[8,"Signed"],[8,"Saturating"],[8,"CheckedAdd"],[8,"CheckedSub"],[8,"CheckedMul"],[8,"CheckedDiv"],[8,"Bounded"],[8,"Float"],[8,"FloatConst"],[8,"ToPrimitive"],[8,"FromPrimitive"],[8,"NumCast"],[8,"PrimInt"],[8,"Num"]]};
searchIndex["ieee754"] = {"doc":"Low-level manipulations of IEEE754 floating-point numbers.","items":[[3,"Iter","ieee754","An iterator over floating point numbers.",null,null],[8,"Ieee754","","Types that are IEEE754 floating point numbers.",null,null],[10,"upto","","Iterate over each value of `T` in `[self, lim]`.",0,null],[16,"Bits","","A type that represents the raw bits of `Self`.",0,null],[16,"Exponent","","A type large enough to store the exponent of `Self`.",0,null],[16,"Signif","","A type large enough to store the significand of `Self`.",0,null],[10,"next","","Return the next value after `self`.",0,null],[10,"prev","","Return the previous value before `self`.",0,null],[10,"bits","","View `self` as a collection of bits.",0,null],[10,"from_bits","","View a collections of bits as a floating point number.",0,{"inputs":[{"name":"bits"}],"output":{"name":"self"}}],[10,"exponent_bias","","Get the bias of the stored exponent.",0,null],[10,"decompose","","Break `self` into the three constituent parts of an IEEE754 float.",0,null],[10,"recompose","","Create a `Self` out of the three constituent parts of an IEEE754 float.",0,{"inputs":[{"name":"bool"},{"name":"exponent"},{"name":"signif"}],"output":{"name":"self"}}],[11,"next","","",1,null],[11,"next_back","","",1,null]],"paths":[[8,"Ieee754"],[3,"Iter"]]};
searchIndex["c_vec"] = {"doc":"Library to interface with chunks of memory allocated in C.","items":[[3,"CVec","c_vec","The type representing a foreign chunk of memory",null,null],[3,"CSlice","","The type representing an &#39;unsafe&#39; foreign chunk of memory",null,null],[11,"drop","","",0,null],[11,"new","","Create a `CVec` from a raw pointer to a buffer with a given length.",0,null],[11,"new_with_dtor","","Create a `CVec` from a foreign buffer, with a given length,\nand a function to run upon destruction.",0,null],[11,"get","","Retrieves an element at a given index, returning `None` if the requested\nindex is greater than the length of the vector.",0,null],[11,"get_mut","","Retrieves a mutable element at a given index, returning `None` if the\nrequested index is greater than the length of the vector.",0,null],[11,"into_inner","","Unwrap the pointer without running the destructor",0,null],[11,"len","","Returns the number of items in this vector.",0,null],[11,"is_empty","","Returns whether this vector is empty.",0,null],[11,"as_cslice","","Convert to CSlice",0,null],[11,"as_ref","","View the stored data as a slice.",0,null],[11,"as_mut","","View the stored data as a slice.",0,null],[11,"new","","Create a `CSlice` from a raw pointer to a buffer with a given length.",1,null],[11,"get","","Retrieves an element at a given index, returning `None` if the requested\nindex is greater than the length of the vector.",1,null],[11,"get_mut","","Retrieves a mutable element at a given index, returning `None` if the\nrequested index is greater than the length of the vector.",1,null],[11,"len","","Returns the number of items in this vector.",1,null],[11,"is_empty","","Returns whether this vector is empty.",1,null],[11,"as_ref","","View the stored data as a slice.",1,null],[11,"as_mut","","View the stored data as a slice.",1,null],[11,"index","","",1,null],[11,"index_mut","","",1,null]],"paths":[[3,"CVec"],[3,"CSlice"]]};
searchIndex["byteorder"] = {"doc":"This crate provides convenience methods for encoding and decoding numbers\nin either big-endian or little-endian order.","items":[[4,"BigEndian","byteorder","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",2,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",2,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",2,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",2,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",2,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",2,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",2,null],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",2,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",2,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",2,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",2,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",2,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",2,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",2,null],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[11,"write_uint","","",3,null],[11,"read_u16","","",4,null],[11,"read_u32","","",4,null],[11,"read_u64","","",4,null],[11,"read_uint","","",4,null],[11,"write_u16","","",4,null],[11,"write_u32","","",4,null],[11,"write_u64","","",4,null],[11,"write_uint","","",4,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null]],"paths":[[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
searchIndex["bit_vec"] = {"doc":"Collections implemented with bit vectors.","items":[[3,"BitVec","bit_vec","The bitvector type.",null,null],[3,"Iter","","An iterator for `BitVec`.",null,null],[3,"IntoIter","","",null,null],[3,"Blocks","","An iterator over the blocks of a `BitVec`.",null,null],[8,"BitBlock","","Abstracts over a pile of bits (basically unsigned primitives)",null,null],[10,"bits","","How many bits it has",0,{"inputs":[],"output":{"name":"usize"}}],[11,"bytes","","How many bytes it has",0,{"inputs":[],"output":{"name":"usize"}}],[10,"from_byte","","Convert a byte into this type (lowest-order bits set)",0,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[10,"count_ones","","Count the number of 1&#39;s in the bitwise repr",0,null],[10,"zero","","Get `0`",0,{"inputs":[],"output":{"name":"self"}}],[10,"one","","Get `1`",0,{"inputs":[],"output":{"name":"self"}}],[11,"index","","",1,null],[11,"new","","Creates an empty `BitVec`.",1,{"inputs":[],"output":{"name":"self"}}],[11,"from_elem","","Creates a `BitVec` that holds `nbits` elements, setting each element\nto `bit`.",1,{"inputs":[{"name":"usize"},{"name":"bool"}],"output":{"name":"self"}}],[11,"with_capacity","","Constructs a new, empty `BitVec` with the specified capacity.",1,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from_bytes","","Transforms a byte-vector into a `BitVec`. Each byte becomes eight bits,\nwith the most significant bits of each byte coming first. Each\nbit becomes `true` if equal to 1 or `false` if equal to 0.",1,null],[11,"from_fn","","Creates a `BitVec` of the specified length where the value at each index\nis `f(index)`.",1,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"self"}}],[11,"blocks","","Iterator over the underlying blocks of data",1,null],[11,"storage","","Exposes the raw block storage of this BitVec",1,null],[11,"storage_mut","","Exposes the raw block storage of this BitVec",1,null],[11,"get","","Retrieves the value at index `i`, or `None` if the index is out of bounds.",1,null],[11,"set","","Sets the value of a bit at an index `i`.",1,null],[11,"set_all","","Sets all bits to 1.",1,null],[11,"negate","","Flips all bits.",1,null],[11,"union","","Calculates the union of two bitvectors. This acts like the bitwise `or`\nfunction.",1,null],[11,"intersect","","Calculates the intersection of two bitvectors. This acts like the\nbitwise `and` function.",1,null],[11,"difference","","Calculates the difference between two bitvectors.",1,null],[11,"all","","Returns `true` if all bits are 1.",1,null],[11,"iter","","Returns an iterator over the elements of the vector in order.",1,null],[11,"none","","Returns `true` if all bits are 0.",1,null],[11,"any","","Returns `true` if any bit is 1.",1,null],[11,"to_bytes","","Organises the bits into bytes, such that the first bit in the\n`BitVec` becomes the high-order bit of the first byte. If the\nsize of the `BitVec` is not a multiple of eight then trailing bits\nwill be filled-in with `false`.",1,null],[11,"eq_vec","","Compares a `BitVec` to a slice of `bool`s.\nBoth the `BitVec` and slice must have the same length.",1,null],[11,"truncate","","Shortens a `BitVec`, dropping excess elements.",1,null],[11,"reserve","","Reserves capacity for at least `additional` more bits to be inserted in the given\n`BitVec`. The collection may reserve more space to avoid frequent reallocations.",1,null],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more bits to be inserted in the\ngiven `BitVec`. Does nothing if the capacity is already sufficient.",1,null],[11,"capacity","","Returns the capacity in bits for this bit vector. Inserting any\nelement less than this amount will not trigger a resizing.",1,null],[11,"grow","","Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.",1,null],[11,"pop","","Removes the last bit from the BitVec, and returns it. Returns None if the BitVec is empty.",1,null],[11,"push","","Pushes a `bool` onto the end.",1,null],[11,"len","","Returns the total number of bits in this vector",1,null],[11,"set_len","","Sets the number of bits that this BitVec considers initialized.",1,null],[11,"is_empty","","Returns true if there are no bits in this vector",1,null],[11,"clear","","Clears all bits in this vector.",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","",1,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",1,null],[11,"clone","","",1,null],[11,"clone_from","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"fmt","","",1,null],[11,"hash","","",1,null],[11,"eq","","",1,null],[11,"clone","","",2,null],[11,"next","","",2,null],[11,"size_hint","","",2,null],[11,"next_back","","",2,null],[11,"next","","",3,null],[11,"next_back","","",3,null],[11,"into_iter","","",1,null],[11,"clone","","",4,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next_back","","",4,null]],"paths":[[8,"BitBlock"],[3,"BitVec"],[3,"Iter"],[3,"IntoIter"],[3,"Blocks"]]};
searchIndex["lazy_static"] = {"doc":"A macro for declaring lazily evaluated statics.","items":[[14,"lazy_static!","lazy_static","",null,null]],"paths":[]};
searchIndex["log"] = {"doc":"A lightweight logging facade.","items":[[3,"LogRecord","log","The &quot;payload&quot; of a log message.",null,null],[3,"LogMetadata","","Metadata about a log message.",null,null],[3,"LogLocation","","The location of a log message.",null,null],[3,"MaxLogLevelFilter","","A token providing read and write access to the global maximum log level\nfilter.",null,null],[3,"SetLoggerError","","The type returned by `set_logger` if `set_logger` has already been called.",null,null],[3,"ShutdownLoggerError","","The type returned by `shutdown_logger_raw` if `shutdown_logger_raw` has\nalready been called or if `set_logger_raw` has not been called yet.",null,null],[4,"LogLevel","","An enum representing the available verbosity levels of the logging framework",null,null],[13,"Error","","The &quot;error&quot; level.",0,null],[13,"Warn","","The &quot;warn&quot; level.",0,null],[13,"Info","","The &quot;info&quot; level.",0,null],[13,"Debug","","The &quot;debug&quot; level.",0,null],[13,"Trace","","The &quot;trace&quot; level.",0,null],[4,"LogLevelFilter","","An enum representing the available verbosity level filters of the logging\nframework.",null,null],[13,"Off","","A level lower than all log levels.",1,null],[13,"Error","","Corresponds to the `Error` log level.",1,null],[13,"Warn","","Corresponds to the `Warn` log level.",1,null],[13,"Info","","Corresponds to the `Info` log level.",1,null],[13,"Debug","","Corresponds to the `Debug` log level.",1,null],[13,"Trace","","Corresponds to the `Trace` log level.",1,null],[5,"max_log_level","","Returns the current maximum log level.",null,{"inputs":[],"output":{"name":"loglevelfilter"}}],[5,"set_logger","","Sets the global logger.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"set_logger_raw","","Sets the global logger from a raw pointer.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"shutdown_logger","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[5,"shutdown_logger_raw","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[8,"Log","","A trait encapsulating the operations required of a logger",null,null],[10,"enabled","","Determines if a log message with the specified metadata would be\nlogged.",2,null],[10,"log","","Logs the `LogRecord`.",2,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,null],[11,"max","","Returns the most verbose logging level.",0,{"inputs":[],"output":{"name":"loglevel"}}],[11,"to_log_level_filter","","Converts the `LogLevel` to the equivalent `LogLevelFilter`.",0,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"partial_cmp","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"from_str","","",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",1,null],[11,"max","","Returns the most verbose logging level filter.",1,{"inputs":[],"output":{"name":"loglevelfilter"}}],[11,"to_log_level","","Converts `self` to the equivalent `LogLevel`.",1,null],[11,"args","","The message body.",3,null],[11,"metadata","","Metadata about the log directive.",3,null],[11,"location","","The location of the log directive.",3,null],[11,"level","","The verbosity level of the message.",3,null],[11,"target","","The name of the target of the directive.",3,null],[11,"level","","The verbosity level of the message.",4,null],[11,"target","","The name of the target of the directive.",4,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"module_path","","The module path of the message.",5,null],[11,"file","","The source file containing the message.",5,null],[11,"line","","The line containing the message.",5,null],[11,"fmt","","",6,null],[11,"get","","Gets the current maximum log level filter.",6,null],[11,"set","","Sets the maximum log level.",6,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"description","","",7,null],[11,"fmt","","",8,null],[11,"fmt","","",8,null],[11,"description","","",8,null],[14,"log!","","The standard logging macro.",null,null],[14,"error!","","Logs a message at the error level.",null,null],[14,"warn!","","Logs a message at the warn level.",null,null],[14,"info!","","Logs a message at the info level.",null,null],[14,"debug!","","Logs a message at the debug level.",null,null],[14,"trace!","","Logs a message at the trace level.",null,null],[14,"log_enabled!","","Determines if a message logged at the specified level in that module will\nbe logged.",null,null]],"paths":[[4,"LogLevel"],[4,"LogLevelFilter"],[8,"Log"],[3,"LogRecord"],[3,"LogMetadata"],[3,"LogLocation"],[3,"MaxLogLevelFilter"],[3,"SetLoggerError"],[3,"ShutdownLoggerError"]]};
searchIndex["vec_map"] = {"doc":"A simple map based on a vector for small integer keys. Space requirements\nare O(highest integer key).","items":[[3,"VecMap","vec_map","A map optimized for small integer keys.",null,null],[3,"VacantEntry","","A vacant Entry.",null,null],[3,"OccupiedEntry","","An occupied Entry.",null,null],[3,"Iter","","An iterator over the key-value pairs of a map.",null,null],[3,"IterMut","","An iterator over the key-value pairs of a map, with the\nvalues being mutable.",null,null],[3,"Keys","","An iterator over the keys of a map.",null,null],[3,"Values","","An iterator over the values of a map.",null,null],[3,"IntoIter","","A consuming iterator over the key-value pairs of a map.",null,null],[3,"Drain","","A draining iterator over the key-value pairs of a map.",null,null],[4,"Entry","","A view into a single entry in a map, which may either be vacant or occupied.",null,null],[13,"Vacant","","A vacant Entry",0,null],[13,"Occupied","","An occupied Entry",0,null],[11,"clone","","",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"hash","","",1,null],[11,"new","","Creates an empty `VecMap`.",1,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Creates an empty `VecMap` with space for at least `capacity`\nelements before resizing.",1,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Returns the number of elements the `VecMap` can hold without\nreallocating.",1,null],[11,"reserve_len","","Reserves capacity for the given `VecMap` to contain `len` distinct keys.\nIn the case of `VecMap` this means reallocations will not occur as long\nas all inserted keys are less than `len`.",1,null],[11,"reserve_len_exact","","Reserves the minimum capacity for the given `VecMap` to contain `len` distinct keys.\nIn the case of `VecMap` this means reallocations will not occur as long as all inserted\nkeys are less than `len`.",1,null],[11,"keys","","Returns an iterator visiting all keys in ascending order of the keys.\nThe iterator&#39;s element type is `usize`.",1,null],[11,"values","","Returns an iterator visiting all values in ascending order of the keys.\nThe iterator&#39;s element type is `&amp;&#39;r V`.",1,null],[11,"iter","","Returns an iterator visiting all key-value pairs in ascending order of the keys.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r V)`.",1,null],[11,"iter_mut","","Returns an iterator visiting all key-value pairs in ascending order of the keys,\nwith mutable references to the values.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r mut V)`.",1,null],[11,"append","","Moves all elements from `other` into the map while overwriting existing keys.",1,null],[11,"split_off","","Splits the collection into two at the given key.",1,null],[11,"drain","","Returns an iterator visiting all key-value pairs in ascending order of\nthe keys, emptying (but not consuming) the original `VecMap`.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r V)`. Keeps the allocated memory for reuse.",1,null],[11,"len","","Returns the number of elements in the map.",1,null],[11,"is_empty","","Returns true if the map contains no elements.",1,null],[11,"clear","","Clears the map, removing all key-value pairs.",1,null],[11,"get","","Returns a reference to the value corresponding to the key.",1,null],[11,"contains_key","","Returns true if the map contains a value for the specified key.",1,null],[11,"get_mut","","Returns a mutable reference to the value corresponding to the key.",1,null],[11,"insert","","Inserts a key-value pair into the map. If the key already had a value\npresent in the map, that value is returned. Otherwise, `None` is returned.",1,null],[11,"remove","","Removes a key from the map, returning the value at the key if the key\nwas previously in the map.",1,null],[11,"entry","","Gets the given key&#39;s corresponding entry in the map for in-place manipulation.",1,null],[11,"or_insert","","Ensures a value is in the entry by inserting the default if empty, and\nreturns a mutable reference to the value in the entry.",0,null],[11,"or_insert_with","","Ensures a value is in the entry by inserting the result of the default\nfunction if empty, and returns a mutable reference to the value in the\nentry.",0,null],[11,"insert","","Sets the value of the entry with the VacantEntry&#39;s key,\nand returns a mutable reference to it.",2,null],[11,"get","","Gets a reference to the value in the entry.",3,null],[11,"get_mut","","Gets a mutable reference to the value in the entry.",3,null],[11,"into_mut","","Converts the entry into a mutable reference to its value.",3,null],[11,"insert","","Sets the value of the entry with the OccupiedEntry&#39;s key,\nand returns the entry&#39;s old value.",3,null],[11,"remove","","Takes the value of the entry out of the map, and returns it.",3,null],[11,"eq","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"fmt","","",1,null],[11,"from_iter","","",1,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"into_iter","","Returns an iterator visiting all key-value pairs in ascending order of\nthe keys, consuming the original `VecMap`.\nThe iterator&#39;s element type is `(usize, &amp;&#39;r V)`.",1,null],[11,"extend","","",1,null],[11,"extend","","",1,null],[11,"index","","",1,null],[11,"index","","",1,null],[11,"index_mut","","",1,null],[11,"index_mut","","",1,null],[11,"clone","","",4,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"next_back","","",4,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"next_back","","",5,null],[11,"clone","","",6,null],[11,"clone","","",7,null],[11,"next","","",8,null],[11,"size_hint","","",8,null],[11,"next_back","","",8,null],[11,"next","","",6,null],[11,"size_hint","","",6,null],[11,"next_back","","",6,null],[11,"next","","",7,null],[11,"size_hint","","",7,null],[11,"next_back","","",7,null],[11,"next","","",9,null],[11,"size_hint","","",9,null],[11,"next_back","","",9,null]],"paths":[[4,"Entry"],[3,"VecMap"],[3,"VacantEntry"],[3,"OccupiedEntry"],[3,"Iter"],[3,"IterMut"],[3,"Keys"],[3,"Values"],[3,"Drain"],[3,"IntoIter"]]};
searchIndex["approx"] = {"doc":"A crate that provides facilities for testing the approximate equality of floating-point\nbased types, using either relative difference, or units in the last place (ULPs)\ncomparisons.","items":[[3,"Relative","approx","The requisite parameters for testing for approximate equality.",null,null],[12,"lhs","","The left-hand side of the approximate equality comparison.",0,null],[12,"rhs","","The right-hand side of the approximate equality comparison.",0,null],[12,"epsilon","","The tolerance to use when testing values that are close together.",0,null],[12,"max_relative","","The relative tolerance for testing values that are far-apart.",0,null],[3,"Ulps","","The requisite parameters for testing for approximate equality.",null,null],[12,"lhs","","The left-hand side of the approximate equality comparison.",1,null],[12,"rhs","","The right-hand side of the approximate equality comparison.",1,null],[12,"epsilon","","The tolerance to use when testing values that are close together.",1,null],[12,"max_ulps","","The ULPs to tolerate when testing values that are far-apart.",1,null],[8,"ApproxEq","","Equality comparisons based on floating point tolerances.",null,null],[16,"Epsilon","","Used for specifying relative comparisons.",2,null],[10,"default_epsilon","","The default tolerance to use when testing values that are close together.",2,{"inputs":[],"output":{"name":"epsilon"}}],[10,"default_max_relative","","The default relative tolerance for testing values that are far-apart.",2,{"inputs":[],"output":{"name":"epsilon"}}],[10,"default_max_ulps","","The default ULPs to tolerate when testing values that are far-apart.",2,{"inputs":[],"output":{"name":"u32"}}],[10,"relative_eq","","A test for equality that uses a relative comparison if the values are far apart.",2,null],[11,"relative_ne","","The inverse of `ApproxEq::relative_eq`.",2,null],[10,"ulps_eq","","A test for equality that uses units in the last place (ULP) if the values are far apart.",2,null],[11,"ulps_ne","","The inverse of `ApproxEq::ulps_eq`.",2,null],[11,"new","","The beginning of a chained equality expression, using a relative based comparison.",0,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"relative"}}],[11,"epsilon","","Replace the epsilon value with the one specified.",0,null],[11,"max_relative","","Replace the maximum relative value with the one specified.",0,null],[11,"eq","","Peform the equality comparison",0,null],[11,"ne","","Peform the inequality comparison",0,null],[11,"new","","The beginning of a chained equality expression, using an ULPs based comparison.",1,{"inputs":[{"name":"t"},{"name":"t"}],"output":{"name":"ulps"}}],[11,"epsilon","","Replace the epsilon value with the one specified.",1,null],[11,"max_ulps","","Replace the max ulps value with the one specified.",1,null],[11,"eq","","Peform the equality comparison",1,null],[11,"ne","","Peform the inequality comparison",1,null],[14,"relative_eq!","","Predicate for testing the approximate equality of two values.",null,null],[14,"relative_ne!","","Predicate for testing the approximate inequality of two values.",null,null],[14,"assert_relative_eq!","","",null,null],[14,"assert_relative_ne!","","",null,null],[14,"ulps_eq!","","Predicate for testing the approximate equality of two values using a maximum ULPs (Units\nin Last Place).",null,null],[14,"ulps_ne!","","Predicate for testing the approximate inequality of two values using a maximum ULPs (Units\nin Last Place).",null,null],[14,"assert_ulps_eq!","","",null,null],[14,"assert_ulps_ne!","","",null,null]],"paths":[[3,"Relative"],[3,"Ulps"],[8,"ApproxEq"]]};
initSearch(searchIndex);
